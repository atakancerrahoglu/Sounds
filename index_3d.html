<!DOCTYPE html>
<html lang="tr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Enhanced 3D Traffic Racer</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: linear-gradient(to bottom, #1e3c72, #2a5298); /* Koyu mavi arka plan */
            font-family: 'Arial', sans-serif;
            overflow: hidden;
            user-select: none;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            width: 100vw;
        }

        canvas {
            display: block;
            cursor: crosshair;
            position: absolute; /* Canvas'ƒ±n diƒüer UI elemanlarƒ±nƒ±n arkasƒ±nda olmasƒ±nƒ± saƒülar */
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }

        /* T√ºm UI elemanlarƒ± i√ßin genel stil */
        .ui-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 100; /* UI elemanlarƒ±nƒ±n canvas'ƒ±n √∂n√ºnde olmasƒ±nƒ± saƒülar */
            pointer-events: none; /* Varsayƒ±lan olarak olaylarƒ± ge√ßirme */
        }

        /* Giri≈ü ekranlarƒ± i√ßin genel stil */
        .screen {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: linear-gradient(135deg, rgba(0,0,0,0.8), rgba(20,20,20,0.8));
            color: white;
            padding: 30px;
            border-radius: 15px;
            text-align: center;
            z-index: 200;
            border: 2px solid rgba(255,255,255,0.2);
            backdrop-filter: blur(10px);
            max-width: 90%;
            pointer-events: all; /* Ekranlar aktifken olaylarƒ± yakala */
            display: none; /* Varsayƒ±lan olarak gizli */
        }

        /* Yeni ƒ∞lk Giri≈ü Ekranƒ± (Pre-Intro) Stilleri */
        #preIntroScreen {
            display: none; /* Ba≈ülangƒ±√ßta gizli olacak */
            flex-direction: column;
            justify-content: center;
            align-items: center;
            padding: 40px 30px;
            background: black; /* Siyah arka plan */
        }

        #kuatamaLoadingScreen {
            display: flex;
            /* background-color: black; */ /* Canvas'ƒ±n g√∂r√ºnmesini engellememesi i√ßin kaldƒ±rƒ±ldƒ± */
            width: 100vw;
            height: 100vh;
            top: 0;
            left: 0;
            transform: none;
            border-radius: 0;
            position: absolute;
            z-index: 999;
        }

        #preIntroScreen h1.company-logo {
            font-family: 'Arial Black', sans-serif;
            font-size: 64px; /* Daha b√ºy√ºk */
            font-weight: bold;
            color: #FF8C00; /* Koyu turuncu */
            text-shadow:
                0 0 15px rgba(255,140,0,0.9), /* Parlaklƒ±k */
                0 0 30px rgba(255,140,0,0.7), /* Daha fazla parlaklƒ±k */
                5px 5px 15px rgba(0,0,0,0.9); /* Derinlik */
            margin-bottom: 40px;
            -webkit-text-stroke: 3px #A0522D; /* Daha koyu turuncu-kahverengi kenarlƒ±k */
            letter-spacing: 5px; /* Harf aralƒ±ƒüƒ± */
        }

        #preIntroScreen .credits {
            margin-top: 40px;
            text-align: center;
        }

        #preIntroScreen .credits p {
            font-size: 18px;
            margin: 5px 0;
            color: #FF8C00; /* Turuncu */
            text-shadow:
                0 0 8px rgba(255,140,0,0.8),
                0 0 15px rgba(255,140,0,0.5);
            font-weight: bold;
        }

        /* Y√ºkleme Ekranƒ± Stilleri (≈üimdi ikinci ekran olacak) */
        #loadingScreen {
            flex-direction: column;
            justify-content: center;
            align-items: center;
            padding: 40px 30px;
        }

        /* ƒ∞lk Giri≈ü Ekranƒ± (≈üimdi √º√ß√ºnc√º ekran olacak) */
        #firstEntryScreen {
            flex-direction: column;
            justify-content: center;
            align-items: center;
            padding: 40px 30px;
        }

        #firstEntryScreen h1.company-logo {
            font-family: 'Arial Black', sans-serif;
            font-size: 56px; /* Daha b√ºy√ºk */
            font-weight: bold;
            color: #FF8C00; /* Koyu turuncu */
            text-shadow:
                0 0 10px rgba(255,140,0,0.7), /* Parlaklƒ±k */
                0 0 20px rgba(255,140,0,0.5), /* Daha fazla parlaklƒ±k */
                5px 5px 10px rgba(0,0,0,0.8); /* Derinlik */
            margin-bottom: 25px; /* Altƒ±ndaki ba≈ülƒ±ktan daha fazla bo≈üluk */
            -webkit-text-stroke: 2px #A0522D; /* Daha koyu turuncu-kahverengi kenarlƒ±k */
            letter-spacing: 3px; /* Harf aralƒ±ƒüƒ± */
        }

        #firstEntryScreen h2.game-title {
            font-family: 'Arial', sans-serif;
            font-size: 38px; /* B√ºy√ºk */
            font-weight: bold;
            color: #C0C0C0; /* Metalik gri */
            text-shadow:
                0 0 5px rgba(192,192,192,0.5), /* Hafif parlaklƒ±k */
                0 0 10px rgba(192,192,192,0.3), /* Daha da hafif parlaklƒ±k */
                3px 3px 6px rgba(0,0,0,0.7); /* Derinlik */
            margin-bottom: 30px; /* ƒ∞sim giri≈üinden √∂nce bo≈üluk */
            -webkit-text-stroke: 1px #808080; /* Koyu gri kenarlƒ±k */
            letter-spacing: 2px;
        }

        #firstEntryScreen .input-group {
            margin-bottom: 20px;
        }

        #firstEntryScreen label {
            display: block;
            margin-bottom: 10px;
            font-size: 20px;
            color: #E0E0E0;
            text-shadow: 1px 1px 3px rgba(0,0,0,0.6);
        }

        #firstEntryScreen input[type="text"] {
            padding: 12px 15px;
            border-radius: 8px;
            border: 2px solid #555;
            background-color: rgba(255,255,255,0.1);
            color: white;
            font-size: 18px;
            width: 250px;
            max-width: 80%;
            text-align: center;
            box-shadow: inset 0 0 8px rgba(0,0,0,0.5);
            transition: border-color 0.3s ease;
        }

        #firstEntryScreen input[type="text"]:focus {
            outline: none;
            border-color: #007bff;
            box-shadow: inset 0 0 8px rgba(0,123,255,0.5), 0 0 10px rgba(0,123,255,0.3);
        }

        /* ƒ∞kinci Giri≈ü Ekranƒ± Stilleri */
        #secondStartScreen {
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            padding: 50px 30px;
        }

        #secondStartScreen .welcome-message {
            font-size: 28px;
            color: #E0E0E0;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.7);
            margin-bottom: 40px; /* Butondan √∂nce bo≈üluk */
        }

        /* Ortak Buton Stilleri */
        button {
            background: linear-gradient(45deg, #66BB6A, #4CAF50); /* Daha a√ßƒ±k ye≈üil */
            color: white;
            border: 2px solid rgba(255,255,255,0.3); /* Belirgin √ßer√ßeve */
            padding: 15px 30px; /* Daha b√ºy√ºk butonlar */
            font-size: 20px; /* Daha b√ºy√ºk font */
            border-radius: 10px; /* Daha yuvarlak k√∂≈üeler */
            cursor: pointer;
            margin-top: 20px; /* Butonlar arasƒ± bo≈üluk */
            transition: all 0.2s ease; /* Daha hƒ±zlƒ± ge√ßi≈ü */
            box-shadow: 0 6px 15px rgba(0,0,0,0.4); /* Hafif g√∂lge */
            font-weight: bold;
            letter-spacing: 1px;
        }

        button:hover {
            transform: translateY(-3px);
            box-shadow: 0 8px 20px rgba(0,0,0,0.6);
            background: linear-gradient(45deg, #76C77C, #5CBF60); /* Hover rengi */
        }

        button:active {
            background: linear-gradient(45deg, #388E3C, #4CAF50); /* Daha koyu ye≈üil */
            transform: translateY(0px);
            box-shadow: 0 2px 8px rgba(0,0,0,0.5);
        }

        /* GAZLA Butonu i√ßin √∂zel stil */
        #gasButton {
            padding: 25px 50px;
            font-size: 36px;
            border-radius: 20px;
            background: linear-gradient(45deg, #FF4500, #FF6347); /* Turuncu tonlarƒ± */
            border: 3px solid rgba(255,255,255,0.5);
            box-shadow: 0 10px 25px rgba(255,69,0,0.6);
            text-shadow: 0 0 10px rgba(0,0,0,0.8);
        }

        #gasButton:hover {
            background: linear-gradient(45deg, #FF6347, #FF7F50);
            box-shadow: 0 12px 30px rgba(255,69,0,0.8);
            transform: translateY(-5px);
        }
        #gasButton:active {
            background: linear-gradient(45deg, #CC3300, #DD4400);
            box-shadow: 0 5px 15px rgba(255,69,0,0.5);
            transform: translateY(0px);
        }


        /* Oyun ƒ∞√ßi UI Elemanlarƒ± */
        .ui, .top-info, .health-bar-container, .combo, .score-feedback,
        .speed-controls, .rocket-btn, .mobile-controls, .speed-display, .game-over {
            display: none; /* Ba≈ülangƒ±√ßta hepsi gizli */
            pointer-events: none; /* Varsayƒ±lan olarak olaylarƒ± ge√ßirme */
        }

        /* Oyun ba≈üladƒ±ƒüƒ±nda g√∂r√ºn√ºr olacak UI elemanlarƒ± */
        body.game-active .ui,
        body.game-active .top-info,
        body.game-active .health-bar-container,
        body.game-active .speed-controls,
        body.game-active .rocket-btn, /* Roket tu≈üu eklendi */
        body.game-active .mobile-controls,
        body.game-active .cockpit-console, /* Kokpit konsolu g√∂r√ºn√ºr olacak */
        body.game-active .speed-display-new {
            display: block; /* Veya flex, duruma g√∂re */
            pointer-events: auto; /* Oyun ba≈üladƒ±ƒüƒ±nda olaylarƒ± yakala */
        }

        /* √ñzel flexbox d√ºzenlemeleri */
        body.game-active .top-info {
            display: flex;
            flex-direction: column;
            align-items: flex-end;
            gap: 8px;
            position: absolute;
            top: 10px;
            right: 10px;
            z-index: 100;
        }

        body.game-active .speed-controls,
        body.game-active .mobile-controls,
        body.game-active .speed-display-new {
            display: flex;
        }

        /* --- MOBƒ∞L KONTROL STƒ∞LLERƒ∞ --- */

        /* Hƒ±z Kontrolleri (Sol Alt) */
        #speedControls {
            position: absolute;
            bottom: 20px;
            left: 20px;
            display: flex;
            flex-direction: column;
            gap: 15px;
            z-index: 101;
        }

        /* Y√∂n Kontrolleri (Saƒü Alt) */
        #mobileControls {
            position: absolute;
            bottom: 20px;
            right: 20px;
            display: none; /* Ba≈ülangƒ±√ßta gizli */
            flex-direction: row;
            gap: 15px;
            z-index: 101;
        }

        /* Roket Butonu (Hƒ±zƒ±n Saƒüƒ±na) */
        #rocketBtn {
            position: absolute;
            bottom: 20px;
            left: 110px; /* left: 20px + width: 70px + gap: 20px */
            z-index: 101;
        }

        /* Ortak Buton Stili (Hƒ±z, Y√∂n, Roket) */
        .speed-btn, .control-btn, .rocket-btn {
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            user-select: none;
            font-weight: bold;
            color: rgba(255, 255, 255, 0.9);
            text-shadow: 0 1px 3px rgba(0,0,0,0.4);
            border: 2px solid rgba(255, 255, 255, 0.3);
            background: linear-gradient(145deg, rgba(255, 255, 255, 0.2), rgba(255, 255, 255, 0.05));
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            box-shadow: 0 8px 16px rgba(0,0,0,0.25);
            transition: all 0.15s ease-out;
        }

        .speed-btn:hover, .control-btn:hover, .rocket-btn:hover {
            background: linear-gradient(145deg, rgba(255, 255, 255, 0.3), rgba(255, 255, 255, 0.15));
            box-shadow: 0 10px 20px rgba(0,0,0,0.3);
            transform: translateY(-2px);
        }

        .speed-btn:active, .control-btn:active, .rocket-btn:active {
            transform: translateY(0px) scale(0.95);
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
            background: linear-gradient(145deg, rgba(255, 255, 255, 0.1), rgba(255, 255, 255, 0.0));
        }

        /* Butonlara √ñzel Boyutlar */
        .speed-btn {
            width: 70px;
            height: 70px;
            border-radius: 18px;
            font-size: 24px;
        }
        .control-btn {
            width: 90px;
            height: 90px;
            border-radius: 50%;
            font-size: 40px;
        }
        .rocket-btn {
            width: 80px;
            height: 80px;
            border-radius: 50%;
            font-size: 32px;
            background-color: rgba(255, 100, 0, 0.25);
        }
        
        /* Oyun Aktifken Kontrolleri G√∂ster */
        body.game-active .speed-controls,
        body.game-active #mobileControls,
        body.game-active .rocket-btn {
            display: flex !important;
            pointer-events: auto !important;
        }
        
        /* Mevcut UI stilleri (sadece oyun aktifken g√∂r√ºn√ºr) */
        .ui {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            font-size: 16px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
            z-index: 100;
            background: rgba(0,0,0,0.3);
            padding: 10px;
            border-radius: 8px;
            backdrop-filter: blur(5px);
            text-align: right;
        }

        .info-box {
            background: rgba(0,0,0,0.4);
            color: white;
            padding: 8px 15px;
            border-radius: 8px;
            font-size: 20px;
            font-weight: bold;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
            backdrop-filter: blur(5px);
            min-width: 120px;
            text-align: right;
        }

        /* NEW: Health Bar Styles */
        .health-bar-container {
            position: absolute;
            top: 50%; /* Center vertically */
            right: 50px; /* Position on the far right, adjust as needed */
            transform: translateY(-50%); /* Adjust for perfect vertical centering */
            width: 20px; /* Daha ince yapƒ±ldƒ± */
            height: 150px; /* Height of the bar */
            background: rgba(255,255,255,0.2);
            border-radius: 5px;
            overflow: hidden;
            border: 2px solid rgba(255,255,255,0.3);
            z-index: 101;
            display: flex;
            align-items: flex-start; /* Dolum yukarƒ±dan ba≈ülasƒ±n diye deƒüi≈ütirildi */
        }

        .health-label {
            position: absolute;
            top: -25px; /* Above the bar */
            right: 0;
            width: 100%;
            text-align: center;
            color: white;
            font-size: 16px;
            font-weight: bold;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.8);
            z-index: 101;
        }

        .health-fill {
            height: 100%; /* Ba≈ülangƒ±√ßta tam dolu olsun */
            background: hsl(120, 100%, 40%); /* Ba≈ülangƒ±√ß rengi ye≈üil */
            transition: height 0.3s ease-out, background-color 0.3s ease-out; /* Hem y√ºkseklik hem renk ge√ßi≈üi ekle */
            width: 100%; /* Geni≈üliƒüi de tam olsun */
            max-width: 90%;
            pointer-events: all;
        }

        .game-over {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: linear-gradient(135deg, rgba(0,0,0,0.9), rgba(20,20,20,0.9));
            color: white;
            padding: 30px;
            border-radius: 15px;
            text-align: center;
            z-index: 200;
            border: 2px solid rgba(255,255,255,0.2);
            backdrop-filter: blur(10px);
            box-shadow: 0 20px 40px rgba(0,0,0,0.5);
            max-width: 90%;
            pointer-events: all;
        }

        .combo {
            position: absolute;
            top: 3%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #FFFF00;
            font-size: 38px;
            font-weight: bolder;
            text-shadow:
                0 0 8px rgba(255,255,0,0.7),
                0 0 15px rgba(255,165,0,0.7),
                0 0 20px rgba(255,0,0,0.7),
                3px 3px 5px rgba(0,0,0,0.9);
            z-index: 150;
            animation: comboAnim 1.5s cubic-bezier(0.25, 0.46, 0.45, 0.94) forwards;
            letter-spacing: 1px;
            -webkit-text-stroke: 1px black;
        }

        @keyframes comboAnim {
            0% { opacity: 0; transform: translate(-50%, -50%) scale(0.5); letter-spacing: -3px; }
            30% { opacity: 1; transform: translate(-50%, -50%) scale(1.1); letter-spacing: 3px; }
            70% { opacity: 1; transform: translate(-50%, -50%) scale(1.0); letter-spacing: 1px; }
            100% { opacity: 0; transform: translate(-50%, -80%) scale(0.8); }
        }

        .score-feedback {
            position: absolute;
            top: 8%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #00FF00;
            font-size: 28px;
            font-weight: bold;
            text-shadow: 0 0 4px rgba(0,255,0,0.8), 0 0 8px rgba(0,255,0,0.5);
            z-index: 160;
            opacity: 0;
            animation: scoreFeedbackAnim 1.0s ease-out forwards;
            pointer-events: none;
        }

        @keyframes scoreFeedbackAnim {
            0% { opacity: 0; transform: translate(-50%, -30%) scale(0.7); }
            20% { opacity: 1; transform: translate(-50%, -50%) scale(1.0); }
            80% { opacity: 1; transform: translate(-50%, -70%) scale(0.9); }
            100% { opacity: 0; transform: translate(-50%, -80%) scale(0.8); }
        }

        .speed-controls {
            position: absolute;
            bottom: 30px; /* Yava≈üla tu≈üuyla aynƒ± hizada kalmasƒ± i√ßin ayarlandƒ± */
            left: 10px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            z-index: 100;
        }

        .speed-btn {
            width: 80px;
            height: 50px;
            background: linear-gradient(45deg, rgba(255,255,255,0.3), rgba(200,200,200,0.3));
            border: 2px solid rgba(255,255,255,0.4);
            border-radius: 8px;
            color: white;
            font-size: 18px;
            font-weight: bold;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            user-select: none;
            backdrop-filter: blur(5px);
            transition: all 0.2s ease;
            box-shadow: 0 4px 10px rgba(0,0,0,0.4);
        }

        .speed-btn.accelerate { background: linear-gradient(45deg, rgba(0,200,0,0.5), rgba(0,150,0,0.5)); }
        .speed-btn.brake { background: linear-gradient(45deg, rgba(200,0,0,0.5), rgba(150,0,0,0.5)); }

        .speed-btn:active {
            transform: scale(0.95);
            box-shadow: 0 2px 5px rgba(0,0,0,0.5);
            background: linear-gradient(45deg, rgba(255,255,255,0.5), rgba(200,200,200,0.5));
        }

        .speed-btn.accelerate:active { background: linear-gradient(45deg, rgba(0,150,0,0.7), rgba(0,100,0,0.7)); }
        .speed-btn.brake:active { background: linear-gradient(45deg, rgba(150,0,0,0.7), rgba(100,0,0,0.7)); }


        .mobile-controls {
            position: absolute;
            bottom: 50px;
            right: 10px;
            display: flex;
            gap: 10px;
            z-index: 100;
        }

        .control-btn {
            width: 60px;
            height: 60px;
            background: linear-gradient(45deg, rgba(255,255,255,0.3), rgba(200,200,200,0.3));
            border: 2px solid rgba(255,255,255,0.4);
            border-radius: 50%;
            color: white;
            font-size: 24px;
            font-weight: bold;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            user-select: none;
            backdrop-filter: blur(5px);
            transition: all 0.2s ease;
            box-shadow: 0 4px 10px rgba(0,0,0,0.4);
        }

        .control-btn:active {
            background: linear-gradient(45deg, rgba(255,255,255,0.5), rgba(200,200,200,0.5));
            transform: scale(0.95);
            box-shadow: 0 2px 5px rgba(0,0,0,0.5);
        }

        .time-of-day-info {
            color: white;
            font-size: 16px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
            margin-top: 5px;
            display: block;
        }

        @keyframes fadeOut {
            0% { opacity: 1; transform: translate(-50%, -50%) scale(1); }
            100% { opacity: 0; transform: translate(-50%, -100%) scale(0.8); }
        }

        .speed-bar-container, .speed-bar-fill {
            display: none;
        }

        /* NEW: Kokpit Konsolu Stilleri */
        .cockpit-console {
            position: absolute;
            bottom: -50px; /* Ba≈ülangƒ±√ßta ekranƒ±n biraz altƒ±nda */
            left: 50%;
            transform: translateX(-50%);
            width: 300px; /* Geni≈ülik ayarlandƒ± */
            max-width: 90%;
            height: 250px; /* Konsolun y√ºksekliƒüi ayarlandƒ± */
            background: linear-gradient(to bottom, #3a3a3a, #1a1a1a); /* Koyu gri gradient */
            border-radius: 20px 20px 0 0; /* √úst k√∂≈üeler yuvarlak */
            box-shadow: 0 -10px 20px rgba(0,0,0,0.7);
            padding: 15px;
            box-sizing: border-box;
            display: flex;
            flex-direction: column;
            align-items: center;
            opacity: 0; /* Ba≈ülangƒ±√ßta g√∂r√ºnmez */
            transition: bottom 0.8s ease-out, opacity 0.8s ease-out; /* Animasyon i√ßin */
            z-index: 90; /* Diƒüer UI elemanlarƒ±nƒ±n altƒ±nda */
            pointer-events: none; /* Konsol ba≈ülangƒ±√ßta etkile≈üim kabul etmez */
        }

        /* Oyun ba≈üƒ±nda konsolun g√∂r√ºn√ºr olmasƒ± i√ßin */
        body.game-active .cockpit-console {
            bottom: 10px; /* Oyun ba≈üladƒ±ƒüƒ±nda ekranƒ±n altƒ±na gelsin */
            opacity: 1; /* G√∂r√ºn√ºr olsun */
            pointer-events: all; /* Etkile≈üim kabul etsin */
        }

        /* Konsolun √ºst ve alt kenarlƒ±klarƒ± */
        .console-border-top {
            width: 100%;
            height: 10px;
            background: #555;
            border-radius: 10px 10px 0 0;
            margin-bottom: 5px;
        }
        .console-border-bottom {
            width: 100%;
            height: 10px;
            background: #555;
            border-radius: 0 0 10px 10px;
            margin-top: 5px;
        }

        .console-screen {
            width: 100%;
            background-color: #0d0d0d; /* Ekranƒ±n koyu arka planƒ± */
            border: 2px solid #222;
            border-radius: 8px;
            padding: 10px;
            box-sizing: border-box;
            text-align: center;
            color: #00FF00; /* Ye≈üil metin */
            font-family: 'Consolas', monospace;
            font-size: 16px;
            text-shadow: 0 0 5px rgba(0,255,0,0.5); /* Ye≈üil parlaklƒ±k */
            display: flex; /* ƒ∞√ßeriklerini flexbox ile y√∂netmek i√ßin */
            flex-direction: column; /* Kontroller ba≈ülƒ±ƒüƒ± √ºste, i√ßerik alta */
            align-items: center; /* Ortalamak i√ßin */
        }

        .console-screen p {
            margin-top: 0;
            margin-bottom: 10px;
            font-weight: bold;
        }

        .cockpit-content {
            display: flex;
            justify-content: space-around; /* Elemanlar arasƒ±nda e≈üit bo≈üluk bƒ±rak */
            align-items: center; /* Dikeyde ortala */
            width: 100%;
            flex-grow: 1; /* Kalan alanƒ± kapla */
            padding-bottom: 10px; /* Alt bo≈üluk */
        }

        .key-display-group {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .key-group-left {
            align-items: flex-end; /* Sol gruptaki tu≈ülarƒ± saƒüa hizala */
            padding-right: 15px; /* Kadranla arasƒ±na bo≈üluk */
        }

        .key-group-right {
            align-items: flex-start; /* Saƒü gruptaki tu≈ülarƒ± sola hizala */
            padding-left: 15px; /* Kadranla arasƒ±na bo≈üluk */
        }

        .key-row {
            display: flex;
            gap: 5px;
            justify-content: center; /* Tu≈ülarƒ± ortala */
        }
        .key-row-left {
             /* Tu≈ülarƒ± kendi grubunda saƒüa hizala */
            justify-content: flex-end;
        }
        .key-row-right {
            /* Tu≈ülarƒ± kendi grubunda sola hizala */
            justify-content: flex-start;
        }
        .key-row-single {
            margin-top: 10px;
        }


        .key-button {
            width: 40px;
            height: 40px;
            background: rgba(50,50,50,0.8); /* Koyu gri tu≈ü arka planƒ± */
            border: 2px solid #666;
            border-radius: 5px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 18px;
            font-weight: bold;
            color: #C0C0C0; /* Gri tu≈ü metni */
            text-shadow: 1px 1px 2px rgba(0,0,0,0.6);
            box-shadow: inset 0 0 5px rgba(0,0,0,0.5);
            transition: background-color 0.1s ease, box-shadow 0.1s ease, color 0.1s ease;
        }

        .key-button-large {
            width: 80px; /* Daha geni≈ü tu≈ülar i√ßin */
        }

        /* Tu≈üa basƒ±ldƒ±ƒüƒ±nda vurgu */
        .key-button.active {
            background-color: #00FF00; /* Ye≈üil vurgu */
            color: black; /* Siyah metin */
            box-shadow: inset 0 0 8px rgba(0,255,0,0.8), 0 0 10px rgba(0,255,0,0.5); /* Ye≈üil parlaklƒ±k */
        }

        /* NEW: Hƒ±z Kadranƒ± Stilleri */
        .speed-gauge {
            position: relative;
            width: 120px; /* Kadran geni≈üliƒüi */
            height: 120px; /* Kadran y√ºksekliƒüi */
            border-radius: 50%;
            background: radial-gradient(circle at center, #111 0%, #333 70%, #555 100%); /* Hafif i√ßb√ºkey efekt */
            box-shadow: inset 0 0 10px rgba(0,0,0,0.8), 0 0 15px rgba(0,0,0,0.5);
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 28px;
            font-weight: bolder;
            text-shadow: 0 0 8px rgba(255,255,255,0.7);
            border: 3px solid #666; /* Dƒ±≈ü √ßer√ßeve */
        }

        .gauge-ring {
            position: absolute;
            width: 100%;
            height: 100%;
            border-radius: 50%;
            border: 8px solid transparent; /* Kalƒ±n halka */
            border-top-color: #4CAF50; /* Ba≈ülangƒ±√ß rengi ye≈üil */
            border-right-color: #4CAF50;
            border-bottom-color: #4CAF50;
            border-left-color: #4CAF50;
            transform: rotate(-45deg); /* Halkanƒ±n ba≈ülangƒ±√ß a√ßƒ±sƒ±nƒ± ayarla */
            box-sizing: border-box;
            transition: border-color 0.3s ease; /* Renk ge√ßi≈üi i√ßin */
        }

        .gauge-center {
            position: relative; /* ƒ∞√ßerik i√ßin */
            z-index: 2; /* Halkanƒ±n √ºzerinde olsun */
            text-align: center;
        }

        #currentSpeedGauge {
            display: block; /* Sayƒ± ve etiket alt alta gelsin */
            font-size: 32px; /* Sayƒ± boyutu */
            line-height: 1;
            /* Renk JavaScript ile y√∂netilecek */
        }

        .gauge-label {
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>

    <div class="ui-overlay">
        <!-- YENƒ∞ 3D YAZI Y√úKLEME EKRANI -->
        <div id="kuatamaLoadingScreen"></div>

        <!-- Yeni ilk giri≈ü ekranƒ± (pre-intro) -->
        <div class="screen" id="preIntroScreen">
            <h1 class="company-logo">KuAtAmA Games</h1>
            <button id="gasButton">GAZLA!!!</button>
            <div class="credits">
                <p>Create By Atakan Cerrahoƒülu</p>
                <p>M√ºzik: Kƒ±rƒ±lmƒ±≈ü Kolum / Atakan Cerrahoƒülu</p>
            </div>
        </div>

        <!-- Y√ºkleme Ekranƒ± (≈üimdi ikinci sƒ±rada) -->
        <div class="screen" id="loadingScreen">
            <h1 class="company-logo">KuAtAmA Games</h1>
            <p style="font-size: 24px; margin-top: 20px; color: #E0E0E0;">Y√ºkleniyor...</p>
            <p id="loadingTip" style="font-size: 18px; margin-top: 20px; color: #ADD8E6; text-shadow: 1px 1px 3px rgba(0,0,0,0.5); opacity: 0; transition: opacity 0.5s ease-in-out; min-height: 40px;"></p>
            <div style="width: 200px; height: 4px; background: rgba(255,255,255,0.2); border-radius: 2px; overflow: hidden; margin-top: 30px;">
                <div id="progressBar" style="width: 0%; height: 100%; background: #4CAF50; transition: width 0.1s linear;"></div>
            </div>
        </div>

        <!-- ƒ∞sim Giri≈ü Ekranƒ± (≈üimdi √º√ß√ºnc√º sƒ±rada) -->
        <div class="screen" id="firstEntryScreen">
            <h1 class="company-logo">KuAtAmA Games</h1>
            <h2 class="game-title">Traffic Racer 3D</h2>
            <div class="input-group">
                <label for="playerNameInput">ƒ∞sim giriniz:</label>
                <input type="text" id="playerNameInput" placeholder="Adƒ±nƒ±z" maxlength="10">
            </div>
            <button id="playButton">Oyna</button>
        </div>

        <!-- Ba≈ülat Ekranƒ± (≈üimdi d√∂rd√ºnc√º sƒ±rada) -->
        <div class="screen" id="secondStartScreen">
            <p class="welcome-message">ƒ∞yi oyunlar!</p>
            <button id="startButton">BA≈ûLA</button>
        </div>

        <div class="ui">
            <div>üìç Mesafe: <span id="distance">0</span>m</div>
            <div>‚≠ê Seviye: <span id="level">1</span></div>
            <div>üöÄ Roketler: <span id="rocketsDisplay">0</span></div>
            <div class="time-of-day-info" id="timeOfDayInfo">
                ‚òÄÔ∏è G√ºnd√ºz: <span id="timeOfDayDisplay">00:00</span>
            </div>
        </div>

        <div class="top-info">
            <div class="info-box">üí∞ Skor: <span id="scoreDisplay">0</span></div>
            <div class="info-box">üî• Kombo: <span id="comboDisplay">0</span></div>
        </div>

        <div class="health-bar-container">
            <div class="health-label">Can</div>
            <div class="health-fill" id="healthFill"></div>
        </div>

        <div class="combo" id="comboText">S√úPER!</div>

        <div id="scoreFeedback" class="score-feedback"></div>

        <div class="cockpit-console" id="cockpitConsole">
            <div class="console-border-top"></div>
            <div class="console-screen">
                <p>KONTROLLER</p>
                <div class="cockpit-content">
                    <div class="key-display-group key-group-left">
                        <div class="key-row key-row-left">
                            <div class="key-button" id="keyW">W</div>
                            <div class="key-button" id="keyUp">‚Üë</div>
                        </div>
                        <div class="key-row key-row-left">
                            <div class="key-button" id="keyA">A</div>
                            <div class="key-button" id="keyS">S</div>
                            <div class="key-button" id="keyD">D</div>
                        </div>
                        <div class="key-row key-row-left">
                            <div class="key-button" id="keyLeft">‚Üê</div>
                            <div class="key-button" id="keyDown">‚Üì</div>
                            <div class="key-button" id="keyRight">‚Üí</div>
                        </div>
                    </div>

                    <div class="speed-gauge">
                        <div class="gauge-ring"></div>
                        <div class="gauge-center">
                            <span id="currentSpeedGauge">0</span>
                            <div class="gauge-label">KM/S</div>
                        </div>
                    </div>

                    <div class="key-display-group key-group-right">
                        <div class="key-row key-row-single key-row-right">
                            <div class="key-button key-button-large" id="keyR">R</div>
                        </div>
                    </div>
                </div>
            </div>
            <div class="console-border-bottom"></div>
        </div>


        <div class="rocket-btn" id="rocketBtn">
            üöÄ
        </div>

        <div class="speed-controls" id="speedControls">
            <div class="speed-btn accelerate" id="accelerateBtn">‚ñ≤</div>
            <div class="speed-btn brake" id="brakeBtn">‚ñº</div>
        </div>

        <div id="mobileControls">
            <div class="control-btn" id="leftBtn">‚óÑ</div>
            <div class="control-btn" id="rightBtn">‚ñ∫</div>
        </div>

        <div class="speed-display-new" id="newSpeedometer">
            <span id="newSpeedValue">0</span>
            <span class="speed-label">KM/S</span>
        </div>

        <div class="game-over" id="gameOver">
            <h2>üí• KAZA!</h2>
            <p>Toplam Skor: <span id="finalScore">0</span></p>
            <p>Mesafe: <span id="finalDistance">0</span>m</p>
            <p>En Y√ºksek Kombo: <span id="maxCombo">0</span></p>
            <div id="highScores">
                <h3>üèÜ Rekorlar üèÜ</h3>
                <ol id="highScoreList"></ol>
            </div>
        </div>

        <div id="sirenStarsContainer">
            <span class="siren-star">‚òÖ</span>
            <span class="siren-star">‚òÖ</span>
            <span class="siren-star">‚òÖ</span>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/FontLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/geometries/TextGeometry.js"></script>
    <script>
        // Oyun deƒüi≈ükenleri
        let scene, camera, renderer, car, road = [], trafficCars = [], barriers = [];
        let roadsideElements = [];
        let gameRunning = false;
        let score = 0, distance = 0, level = 1;
        let carSpeed = 0, maxSpeed = 250;
        let roadSpeed = 0.5;
        let baseTrafficSpeed = 0.3;
        let keys = {};
        let gameStarted = false;
        let combo = 0;
        let highCombo = 0;
        let lastComboTime = 0;
        let mobileControls = { left: false, right: false, accelerate: false, brake: false };
        let animationFrameId;
        let carTilt = 0;
        const maxCarTilt = Math.PI / 24; 

        let audioContext;
        let engineGainNode; 
        let engineSource; 
        let engineBuffer; 

        let brakeBuffer; 
        let policeSirenBuffer; 
        let introBuffer; 
        let introSource; 
        let introGainNode; 
        let powerUpRocketSoundBuffer; // Formerly powerUpCollectBuffer
        let explosionSoundBuffer;
        let crashSoundBuffer;
        let powerUpHealthSoundBuffer;
        let powerUpShieldSoundBuffer;
        let menuSelectSoundBuffer;
        let menuConfirmSoundBuffer;

        let brakeLightMesh = null;
        let spoilerTaillights = [];
        let pooledTrafficCars = [];
        const MAX_POOLED_TRAFFIC_CARS = 20;

        let health = 100;
        const maxHealth = 100;
        const sideCollisionDamageMultiplier = 0.1; 
        const directCollisionZThreshold = 2.0;

        let playerHeadlight;
        const carBox = new THREE.Box3();
        const trafficBox = new THREE.Box3();
        const powerUpBox = new THREE.Box3(); 

        const roadWidth = 20;
        const lanes = [-7, 0, 7];
        const laneWidth = 7;
        const roadsideWidth = 100; // Geni≈ületilmi≈ü yol kenarƒ±

        let rocketParticles = [];

        let rockets = 0; 
        let activeRocket = null;
        const rocketBaseSpeed = 1.5;
        const rocketCooldown = 1000;
        let lastRocketFireTime = 0;
        let trafficCarsDestroyedByRocket = 0;
        let rocketsFiredCount = 0; 

        // G√º√ßlendirmeler i√ßin genel deƒüi≈ükenler
        let powerUps = [];
        const powerUpSpawnInterval = 10000; // Artƒ±k genel bir aralƒ±k
        let lastPowerUpSpawnTime = 0;
        let shieldActive = false;
        let shieldTimeout;
        let shieldMesh = null;

        let skyDome;
        let mountains = [];
        let sun, moon, starField, sunLight; // Yeni g√∂k cisimleri

        let activePoliceCar = null;

        // Eski polis sistemiyle ilgili t√ºm deƒüi≈ükenler kaldƒ±rƒ±ldƒ±.

        // Yeni Siren Uyarƒ± Sistemi Deƒüi≈ükenleri
        let sirenWarningCount = 0;
        // Eski zamanlayƒ±cƒ± deƒüi≈ükenleri kaldƒ±rƒ±ldƒ±.
        let shortSirenSound; // Kƒ±sa siren sesi i√ßin kontrol objesi

        const MAX_POOLED_POLICE_CARS = 2;
        let policeCarsPool = [];

        let playerName = "Oyuncu";

        let timeOfDay = 6;
        const dayDurationInGameMeters = 5000;
        let previousDistanceForTime = 0;

        let radarPoles = [];
        let lastRadarHitTime = {};
        let nextRadarSpawnDistance = 0;

        const SPEED_EFFECT_THRESHOLD = 200;
        let cameraShakeIntensity = 0;
        const maxCameraShakeIntensity = 0.08;
        const speedEffectScaleFactor = 0.0005;

        // Yeni kamera sarsƒ±ntƒ±sƒ± deƒüi≈ükenleri
        let collisionShakeMagnitude = 0;
        let collisionShakeDuration = 0;

        let newSpeedValueElement;

        // JSONBlob URL'si
        const HIGH_SCORES_URL = 'https://jsonblob.com/api/jsonBlob/1380700706369101824';

        // LoadingManager ve ƒ∞lerleme √áubuƒüu Deƒüi≈ükenleri
        let loadingManager;
        let progressBar = document.getElementById('progressBar');
        let loadingScreen = document.getElementById('loadingScreen');
        let loadingTip = document.getElementById('loadingTip'); 

        // Kokpit elemanlarƒ± i√ßin referanslar
        let cockpitConsole = document.getElementById('cockpitConsole');
        let currentSpeedGauge = document.getElementById('currentSpeedGauge');
        let gaugeRing = document.querySelector('.gauge-ring');

        const loadingTips = [ 
            "Hƒ±z ve ≈üiddet i√ßerir.",
            "Hƒ±z kadar, yava≈ülamak da √∂nemlidir.",
            "Roketle ve polisden ka√ß!",
            "Trafik ara√ßlarƒ±na yakƒ±n ge√ßerek bonus puanlar kazan!",
            "Radar cezalarƒ±na dikkat et, hƒ±z limitini a≈üma!",
            "G√ºnd√ºz-gece d√∂ng√ºs√º oyun deneyimini etkiler.",
            "Saƒülƒ±k barƒ±na g√∂z kulak ol, √ßarpƒ±≈ümalardan ka√ß!",
            "Polis arabalarƒ± pe≈üini bƒ±rakmaz, onlarƒ± atlat!"
        ];
        let currentTipIndex = 0;
        let lastTipChangeProgress = -1; 

        // Tu≈ü elementleri i√ßin referanslar
        const keyMap = {
            'w': document.getElementById('keyW'),
            'a': document.getElementById('keyA'),
            's': document.getElementById('keyS'),
            'd': document.getElementById('keyD'),
            'arrowup': document.getElementById('keyUp'),
            'arrowleft': document.getElementById('keyLeft'),
            'arrowdown': document.getElementById('keyDown'),
            'arrowright': document.getElementById('keyRight'),
            'r': document.getElementById('keyR')
        };

        // Bu deƒüi≈ükeni global scope'a ta≈üƒ±dƒ±k.
        const minDistanceBetweenCars = 30;

        // Yeni √áarpƒ±≈üma Koruma Sistemi
        let lastCollisionTime = 0;
        const collisionCooldown = 1500; // 1.5 saniye dokunulmazlƒ±k

        // Yƒ±ldƒ±z UI elementleri
        let sirenStarElements = [];

        const playerCarWidth = 1.9;
        const playerCarLength = 4.5;

        // Y√ºkleme ekranƒ± i√ßin deƒüi≈ükenler
        let kuatamaScene, kuatamaCamera, kuatamaText;
        let kuatamaAnimationComplete = false;

        let lateralVelocity = 0;
        const steerIntensity = 0.04;
        const maxLateralVelocity = 0.3;
        const steerDamping = 0.97;

        function animateKuatamaScreen() {
            if (kuatamaAnimationComplete) return;

            requestAnimationFrame(animateKuatamaScreen);

            if (kuatamaText) {
                kuatamaText.rotation.y += 0.02;

                if (kuatamaText.rotation.y >= Math.PI * 2) {
                    kuatamaAnimationComplete = true;
                    document.getElementById('kuatamaLoadingScreen').style.display = 'none';
                    init(); // Ana oyunu ba≈ülat
                    return;
                }
            }

            renderer.render(kuatamaScene, kuatamaCamera);
        }

        function initKuatamaScreen() {
            // Ana renderer'ƒ± burada olu≈ütur
            renderer = new THREE.WebGLRenderer({
                canvas: document.getElementById('gameCanvas'),
                antialias: true
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setClearColor(0x000000); // Y√ºkleme ekranƒ± i√ßin arkaplanƒ± siyah yap

            // Kuatama y√ºkleme ekranƒ±nƒ± ayarla
            document.getElementById('kuatamaLoadingScreen').style.display = 'flex';
            
            kuatamaScene = new THREE.Scene();
            kuatamaCamera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            kuatamaCamera.position.z = 4; // Yazƒ±yƒ± daha iyi g√∂rebilmek i√ßin kamera uzakla≈ütƒ±rƒ±ldƒ±

            const ambientLight = new THREE.AmbientLight(0xffffff, 0.8);
            kuatamaScene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
            directionalLight.position.set(5, 10, 7.5);
            kuatamaScene.add(directionalLight);

            const fontLoader = new THREE.FontLoader();
            fontLoader.load(
                'https://cdn.jsdelivr.net/npm/three@0.128.0/examples/fonts/helvetiker_regular.typeface.json',
                function (font) {
                    const textGeometry = new THREE.TextGeometry('KUATAMA', {
                        font: font,
                        size: 0.8, // Boyut b√ºy√ºt√ºld√º
                        height: 0.2, // Kalƒ±nlƒ±k artƒ±rƒ±ldƒ±
                        curveSegments: 12,
                        bevelEnabled: true,
                        bevelThickness: 0.03,
                        bevelSize: 0.02,
                        bevelSegments: 5
                    });

                    textGeometry.computeBoundingBox();
                    const textWidth = textGeometry.boundingBox.max.x - textGeometry.boundingBox.min.x;
                    textGeometry.translate(-textWidth / 2, -0.4, 0); // Yeni boyuta g√∂re ortalandƒ±

                    const textMaterial = new THREE.MeshPhongMaterial({ color: 0xFF8C00, specular: 0x555555, shininess: 30 });
                    kuatamaText = new THREE.Mesh(textGeometry, textMaterial);
                    kuatamaScene.add(kuatamaText);

                    animateKuatamaScreen();
                },
                undefined,
                function (error) {
                    console.error('Font y√ºklenirken bir hata olu≈ütu:', error);
                    // Hata durumunda direkt oyuna ge√ß
                    document.getElementById('kuatamaLoadingScreen').style.display = 'none';
                    init();
                }
            );
        }

        function init() {
            // LoadingManager olu≈ütur
            loadingManager = new THREE.LoadingManager();

            loadingManager.onProgress = function (url, itemsLoaded, itemsTotal) {
                console.log('Y√ºkleniyor: ' + url + '.  Y√ºklenen √∂ƒüe: ' + itemsLoaded + '/' + itemsTotal);
                const progress = (itemsLoaded / itemsTotal) * 100;
                if (progressBar) { 
                    progressBar.style.width = progress + '%';
                }

                // ƒ∞lerleme √ßubuƒüuna g√∂re ipu√ßlarƒ±nƒ± g√ºncelle
                if (loadingTip) {
                    const totalTips = loadingTips.length;
                    const tipInterval = 100 / totalTips; 

                    const newTipIndex = Math.floor(progress / tipInterval);

                    if (newTipIndex !== currentTipIndex && newTipIndex < totalTips) {
                        currentTipIndex = newTipIndex;
                        loadingTip.style.opacity = 0; 
                        setTimeout(() => {
                            loadingTip.textContent = loadingTips[currentTipIndex];
                            loadingTip.style.opacity = 1; 
                        }, 500); 
                    } else if (progress >= 99 && currentTipIndex < totalTips -1 && lastTipChangeProgress < 99) {
                        currentTipIndex = totalTips - 1;
                        loadingTip.style.opacity = 0;
                        setTimeout(() => {
                            loadingTip.textContent = loadingTips[currentTipIndex];
                            loadingTip.style.opacity = 1;
                        }, 500);
                    }
                    lastTipChangeProgress = progress; 
                }
            };

            loadingManager.onLoad = function () {
                console.log('T√ºm varlƒ±klar y√ºklendi!');
                // Sesler y√ºklendikten sonra ilk ekranƒ± g√∂ster
                // initAudioAndLoadGame(); // Bu fonksiyon ≈üimdi 'GAZLA!!!' butonu ile √ßaƒürƒ±lacak
            };

            loadingManager.onError = function (url) {
                console.error('Y√ºklenirken hata olu≈ütu: ' + url);
                // initAudioAndLoadGame(); // Bu fonksiyon ≈üimdi 'GAZLA!!!' butonu ile √ßaƒürƒ±lacak
            };

            scene = new THREE.Scene();
            scene.fog = new THREE.Fog(0x87CEEB, 100, 500);

            camera = new THREE.PerspectiveCamera(80, window.innerWidth / window.innerHeight, 0.1, 1000); 
            camera.position.set(0, 9, 14); 
            camera.lookAt(0, 2, -5); 


            renderer = new THREE.WebGLRenderer({
                canvas: document.getElementById('gameCanvas'),
                antialias: true
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.setClearColor(0x87CEEB);

            const ambientLight = new THREE.AmbientLight(0x404080, 0.8);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 1.2);
            directionalLight.position.set(20, 30, 10);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 1024;
            directionalLight.shadow.mapSize.height = 1024;
            directionalLight.shadow.camera.near = 0.5;
            directionalLight.shadow.camera.far = 100;
            directionalLight.shadow.camera.left = -50;
            directionalLight.shadow.camera.right = 50;
            directionalLight.shadow.camera.top = 50;
            directionalLight.shadow.camera.bottom = -50;
            scene.add(directionalLight);

            createPlayerCar();
            createPlayerHeadlight();
            createRoad();
            createRoadside();
            createBarriers();
            createInitialTrafficCars(5);
            createInitialRoadsideElements(10);
            createSkyDome();
            createMountains();
            createCelestialBodies();

            for (let i = 0; i < MAX_POOLED_POLICE_CARS; i++) {
                const { car: policeCar, length } = createTrafficCar(0x0000FF, 'sport', true);
                policeCar.visible = false;
                policeCar.userData.isPooled = true;
                policeCar.userData.length = length;
                policeCar.userData.type = 'sport';
                policeCar.userData.isPolice = true;
                policeCar.userData.currentLane = 0;
                policeCar.userData.targetLane = 0;
                policeCar.userData.isChangingLane = false;
                policeCar.userData.wander = 0;
                policeCar.userData.wanderTarget = 0;
                policeCar.userData.lastX = 0;
                policeCar.userData.trafficCollisions = 0;
                scene.add(policeCar);
                policeCarsPool.push(policeCar);
            }

            for (let i = 0; i < MAX_POOLED_TRAFFIC_CARS; i++) {
                const colors = [0x00FF00, 0x0000FF, 0xFFFF00, 0xFF00FF, 0x00FFFF, 0xFF8C00, 0x8A2BE2, 0x00CED1, 0xFF69B4, 0x4B0082, 0xADFF2F, 0xFFD700];
                const types = ['sedan', 'truck', 'minivan', 'bus'];
                const color = colors[Math.floor(Math.random() * colors.length)];
                const type = types[Math.floor(Math.random() * types.length)];
                const { car: trafficCar, length } = createTrafficCar(color, type);
                trafficCar.visible = false;
                trafficCar.userData.isPooled = true;
                trafficCar.userData.length = length;
                trafficCar.userData.type = type;
                trafficCar.userData.isPolice = false;
                trafficCar.userData.currentLane = 0;
                trafficCar.userData.targetLane = 0;
                trafficCar.userData.isChangingLane = false;
                trafficCar.userData.wander = 0;
                trafficCar.userData.wanderTarget = 0;
                trafficCar.userData.lastX = 0;
                trafficCar.userData.trafficCollisions = 0;
                scene.add(trafficCar);
                pooledTrafficCars.push(trafficCar);
            }


            window.addEventListener('resize', onWindowResize);
            document.addEventListener('keydown', onKeyDown);
            document.addEventListener('keyup', onKeyUp);

            setupMobileControls();
            newSpeedValueElement = document.getElementById('newSpeedValue');

            update();
            showPreIntroScreen(); /* Yeni eklenen ilk ekranƒ± g√∂ster */
        }

        /* Yeni ekran g√∂sterme fonksiyonlarƒ± */
        function showPreIntroScreen() {
            document.getElementById('preIntroScreen').style.display = 'flex';
            document.getElementById('loadingScreen').style.display = 'none';
            document.getElementById('firstEntryScreen').style.display = 'none';
            document.getElementById('secondStartScreen').style.display = 'none';
            document.getElementById('gameOver').style.display = 'none';
            document.body.classList.remove('game-active');

            if (cockpitConsole) {
                cockpitConsole.style.bottom = '-50px'; 
                cockpitConsole.style.opacity = '0'; 
                cockpitConsole.style.pointerEvents = 'none'; 
            }
        }

        function showLoadingScreen() {
            document.getElementById('preIntroScreen').style.display = 'none';
            document.getElementById('loadingScreen').style.display = 'flex';
            document.getElementById('firstEntryScreen').style.display = 'none';
            document.getElementById('secondStartScreen').style.display = 'none';
            document.getElementById('gameOver').style.display = 'none';
            document.body.classList.remove('game-active');

            if (cockpitConsole) {
                cockpitConsole.style.bottom = '-50px'; 
                cockpitConsole.style.opacity = '0'; 
                cockpitConsole.style.pointerEvents = 'none'; 
            }
        }

        function showFirstEntryScreen() { /* Eski showFirstScreen, ≈üimdi isim giri≈üi ekranƒ± */
            document.getElementById('preIntroScreen').style.display = 'none';
            document.getElementById('loadingScreen').style.display = 'none';
            document.getElementById('firstEntryScreen').style.display = 'flex';
            document.getElementById('secondStartScreen').style.display = 'none';
            document.getElementById('gameOver').style.display = 'none';
            document.body.classList.remove('game-active');

            if (cockpitConsole) {
                cockpitConsole.style.bottom = '-50px'; 
                cockpitConsole.style.opacity = '0'; 
                cockpitConsole.style.pointerEvents = 'none'; 
            }
        }

        function showSecondStartScreen() { /* Eski showSecondScreen, ≈üimdi ba≈ülat d√ºƒümesi ekranƒ± */
            document.getElementById('preIntroScreen').style.display = 'none';
            document.getElementById('loadingScreen').style.display = 'none';
            document.getElementById('firstEntryScreen').style.display = 'none';
            document.getElementById('secondStartScreen').style.display = 'flex';
            document.getElementById('gameOver').style.display = 'none';
            document.body.classList.remove('game-active');

            if (introGainNode) {
                introGainNode.gain.setValueAtTime(0.25, audioContext.currentTime); 
            }
        }

        function hideAllScreensForGame() {
            document.getElementById('preIntroScreen').style.display = 'none';
            document.getElementById('loadingScreen').style.display = 'none';
            document.getElementById('firstEntryScreen').style.display = 'none';
            document.getElementById('secondStartScreen').style.display = 'none';
            document.getElementById('gameOver').style.display = 'none';
            document.body.classList.add('game-active'); 

            if (cockpitConsole) {
                cockpitConsole.style.bottom = '10px'; 
                cockpitConsole.style.opacity = '1'; 
                cockpitConsole.style.pointerEvents = 'all'; 
            }
        }

        /* Yeni GAZLA butonu olayƒ± */
        document.getElementById('gasButton').addEventListener('click', () => {
            showLoadingScreen(); /* Y√ºkleme ekranƒ±na ge√ßi≈ü */
            initAudioAndLoadGame(); /* Sesleri ve oyunu y√ºkleme i≈ülemini ba≈ülat */
        });

        document.getElementById('playButton').addEventListener('click', () => {
            const inputName = document.getElementById('playerNameInput').value.trim();
            if (inputName) {
                playerName = inputName;
            } else {
                playerName = "Misafir";
            }
            if (audioContext && audioContext.state === 'suspended') {
                audioContext.resume().then(() => {
                    console.log('AudioContext devam ettirildi (ilk etkile≈üim).');
                    /* Intro sesi zaten initAudioAndLoadGame i√ßinde ba≈ülatƒ±lmƒ±≈ü olmalƒ± */
                }).catch(error => {
                    console.error("AudioContext devam ettirilemedi:", error);
                });
            }
            /* intro sesi zaten calisiyor olmali */
            showSecondStartScreen();
        });

        document.getElementById('startButton').addEventListener('click', startActuallyGame);
        document.getElementById('playerNameInput').addEventListener('keydown', (e) => {
            if (e.key === 'Enter') {
                document.getElementById('playButton').click(); 
            }
        });


        function isMobileDevice() {
            return (typeof window.orientation !== "undefined") || (navigator.userAgent.indexOf('Mobi') !== -1);
        }

        function setupMobileControls() {
            const leftBtn = document.getElementById('leftBtn');
            const rightBtn = document.getElementById('rightBtn');
            const accelerateBtn = document.getElementById('accelerateBtn'); 

            if (!isMobileDevice()) {
                const mobileControlsDiv = document.getElementById('mobileControls');
                const speedControlsDiv = document.getElementById('speedControls');
                const rocketBtnDiv = document.getElementById('rocketBtn'); 
                if (mobileControlsDiv) mobileControlsDiv.style.display = 'none';
                if (speedControlsDiv) speedControlsDiv.style.display = 'none';
                if (rocketBtnDiv) rocketBtnDiv.style.display = 'none'; 
                return; // Mobilde deƒüilse, event listenerlarƒ± atama
            }

            if (leftBtn) {
                leftBtn.addEventListener('touchstart', (e) => { e.preventDefault(); mobileControls.left = true; if(keyMap['arrowleft']) keyMap['arrowleft'].classList.add('active'); }, { passive: false });
                leftBtn.addEventListener('touchend', (e) => { e.preventDefault(); mobileControls.left = false; if(keyMap['arrowleft']) keyMap['arrowleft'].classList.remove('active'); });
            }

            if(rightBtn) {
                rightBtn.addEventListener('touchstart', (e) => { e.preventDefault(); mobileControls.right = true; if(keyMap['arrowright']) keyMap['arrowright'].classList.add('active'); }, { passive: false });
                rightBtn.addEventListener('touchend', (e) => { e.preventDefault(); mobileControls.right = false; if(keyMap['arrowright']) keyMap['arrowright'].classList.remove('active'); });
            }

            if(accelerateBtn) {
                accelerateBtn.addEventListener('touchstart', (e) => { e.preventDefault(); mobileControls.accelerate = true; if(keyMap['arrowup']) keyMap['arrowup'].classList.add('active'); if(keyMap['w']) keyMap['w'].classList.add('active'); }, { passive: false });
                accelerateBtn.addEventListener('touchend', (e) => { e.preventDefault(); mobileControls.accelerate = false; if(keyMap['arrowup']) keyMap['arrowup'].classList.remove('active'); if(keyMap['w']) keyMap['w'].classList.remove('active'); });
            }

            if(brakeBtn) {
                brakeBtn.addEventListener('touchstart', (e) => { e.preventDefault(); mobileControls.brake = true; if(keyMap['arrowdown']) keyMap['arrowdown'].classList.add('active'); if(keyMap['s']) keyMap['s'].classList.add('active'); }, { passive: false });
                brakeBtn.addEventListener('touchend', (e) => { e.preventDefault(); mobileControls.brake = false; if(keyMap['arrowdown']) keyMap['arrowdown'].classList.remove('active'); if(keyMap['s']) keyMap['s'].classList.remove('active'); });
            }

            if(rocketBtn) {
                rocketBtn.addEventListener('touchstart', (e) => { e.preventDefault(); fireRocket(); if(keyMap['r']) keyMap['r'].classList.add('active'); }, { passive: false });
                rocketBtn.addEventListener('touchend', (e) => { e.preventDefault(); if(keyMap['r']) keyMap['r'].classList.remove('active'); });
            }
        }

        function createPlayerCar() {
            const carGroup = new THREE.Group();

            const bodyMaterial = new THREE.MeshStandardMaterial({
                color: 0xFF0000, 
                roughness: 0.5, 
                metalness: 0.1, 
            });
            const windowMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x000000, 
                transparent: true,
                opacity: 0.85, 
                roughness: 0.05, 
                metalness: 0.95, 
                envMapIntensity: 1.5, 
            });
            const wheelMaterial = new THREE.MeshStandardMaterial({
                color: 0x1A1A1A,
                roughness: 0.8,
                metalness: 0.5,
            });
            const playerHeadlightMaterial = new THREE.MeshStandardMaterial({
                color: 0xFFFF88,
                emissive: 0xAAAA00,
                emissiveIntensity: 0.8,
                roughness: 0.1,
                metalness: 0.0,
            });
            const playerTaillightMaterial = new THREE.MeshStandardMaterial({
                color: 0x8B0000, 
                emissive: 0xFF0000, 
                emissiveIntensity: 5.0, 
                roughness: 0.1,
                metalness: 0.0,
            });
            const frontBumperMaterial = new THREE.MeshStandardMaterial({
                color: 0x333333, 
                roughness: 0.6,
                metalness: 0.7,
            });
            const airIntakeMaterial = new THREE.MeshStandardMaterial({
                color: 0x000000, 
                roughness: 0.4,
                metalness: 0.9
            });
            const diffuserMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x111111, 
                roughness: 0.6,
                metalness: 0.8, 
            });
            const finMaterial = new THREE.MeshStandardMaterial({
                color: 0x000000,
                roughness: 0.5,
                metalness: 0.7
            });


            const bodyGeometry = new THREE.BoxGeometry(2.6, 0.5, 5.0); 
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            body.position.y = 0.25; 
            body.castShadow = true;
            carGroup.add(body);


            const carBodyTopY = 0.5; 
            const roofThickness = 0.1; 
            const roofWidth = 2.2;     

            const metalRoofDepth = 2.5; 
            const metalRoofGeometry = new THREE.BoxGeometry(roofWidth, roofThickness, metalRoofDepth);
            const metalRoof = new THREE.Mesh(metalRoofGeometry, bodyMaterial);
            metalRoof.position.set(
                0,
                carBodyTopY + (roofThickness / 2), 
                -metalRoofDepth / 2 
            );
            metalRoof.castShadow = true;
            carGroup.add(metalRoof);

            const windshieldRearY = carBodyTopY + roofThickness; 
            const windshieldRearZ = 0;                          
            const windshieldFrontY = carBodyTopY - 0.1; 
            const windshieldFrontZ = 1.8;              

            const deltaZ_ws = windshieldFrontZ - windshieldRearZ; 
            const deltaY_ws = windshieldRearY - windshieldFrontY; 

            const windshieldLengthOnSlant = Math.sqrt(deltaZ_ws * deltaZ_ws + deltaY_ws * deltaY_ws);
            const windshieldRotationX = Math.atan2(deltaY_ws, deltaZ_ws); 

            const glassThickness = 0.05; 
            const frontWindshieldGeometry = new THREE.BoxGeometry(roofWidth, glassThickness, windshieldLengthOnSlant);
            const frontWindshield = new THREE.Mesh(frontWindshieldGeometry, windowMaterial);

            frontWindshield.position.set(
                0,
                (windshieldRearY + windshieldFrontY) / 2, 
                (windshieldRearZ + windshieldFrontZ) / 2  
            );
            frontWindshield.rotation.x = windshieldRotationX;
            frontWindshield.castShadow = true; 
            carGroup.add(frontWindshield);

            const carBodyWidth = 2.6;
            const sidePanelThickness = 0.1; 
            const sideWindowThickness = 0.05; 

            const rearSidePanelDepth = 2.5;
            const rearSidePanelHeight = carBodyTopY + roofThickness;
            const rearSidePanelGeometry = new THREE.BoxGeometry(sidePanelThickness, rearSidePanelHeight, rearSidePanelDepth);

            const leftRearSidePanel = new THREE.Mesh(rearSidePanelGeometry, diffuserMaterial);
            leftRearSidePanel.position.set(
                -carBodyWidth / 2 - sidePanelThickness / 2, 
                rearSidePanelHeight / 2,                    
                -rearSidePanelDepth / 2                      
            );
            leftRearSidePanel.castShadow = true;
            carGroup.add(leftRearSidePanel);

            const rightRearSidePanel = new THREE.Mesh(rearSidePanelGeometry, diffuserMaterial);
            rightRearSidePanel.position.set(
                carBodyWidth / 2 + sidePanelThickness / 2,
                rearSidePanelHeight / 2,
                -rearSidePanelDepth / 2
            );
            rightRearSidePanel.castShadow = true;
            carGroup.add(rightRearSidePanel);

            const sideWindowBottomY = 0.2; 
            const frontSideLowerPanelDepth = windshieldFrontZ; 
            const frontSideLowerPanelHeight = sideWindowBottomY; 
            const frontSideLowerPanelGeometry = new THREE.BoxGeometry(sidePanelThickness, frontSideLowerPanelHeight, frontSideLowerPanelDepth);

            const leftFrontLowerPanel = new THREE.Mesh(frontSideLowerPanelGeometry, bodyMaterial);
            leftFrontLowerPanel.position.set(
                -carBodyWidth / 2 - sidePanelThickness / 2,
                frontSideLowerPanelHeight / 2, 
                frontSideLowerPanelDepth / 2   
            );
            leftFrontLowerPanel.castShadow = true;
            carGroup.add(leftFrontLowerPanel);

            const rightFrontLowerPanel = new THREE.Mesh(frontSideLowerPanelGeometry, bodyMaterial);
            rightFrontLowerPanel.position.set(
                carBodyWidth / 2 + sidePanelThickness / 2,
                frontSideLowerPanelHeight / 2,
                frontSideLowerPanelDepth / 2
            );
            rightFrontLowerPanel.castShadow = true;
            carGroup.add(rightFrontLowerPanel);

            const sideWindowShapeXY = new THREE.Shape();
            sideWindowShapeXY.moveTo(windshieldRearZ, sideWindowBottomY);    
            sideWindowShapeXY.lineTo(windshieldRearZ, windshieldRearY);      
            sideWindowShapeXY.lineTo(windshieldFrontZ, windshieldFrontY);    
            sideWindowShapeXY.lineTo(windshieldFrontZ, sideWindowBottomY);   
            sideWindowShapeXY.closePath();

            const sideWindowExtrudeSettings = { depth: sideWindowThickness, bevelEnabled: false };
            const sideWindowGeomXY = new THREE.ExtrudeGeometry(sideWindowShapeXY, sideWindowExtrudeSettings);

            const lsw = new THREE.Mesh(sideWindowGeomXY, windowMaterial);
            lsw.rotation.y = Math.PI / 2; 
            lsw.position.set(
                -carBodyWidth / 2, 
                0,                 
                sideWindowThickness / 2 
            );
            lsw.castShadow = true;
            carGroup.add(lsw);

            const rsw = new THREE.Mesh(sideWindowGeomXY, windowMaterial);
            rsw.rotation.y = -Math.PI / 2; 
            rsw.position.set(
                carBodyWidth / 2,  
                0,
                -sideWindowThickness / 2 
            );
            rsw.castShadow = true;
            carGroup.add(rsw);

            const wheelGeometry = new THREE.CylinderGeometry(0.5, 0.5, 0.5, 16); 
            const wheelPositions = [
                { x: -1.2, y: 0.25, z: 2.0 }, 
                { x: 1.2, y: 0.25, z: 2.0 },  
                { x: -1.2, y: 0.25, z: -2.0 },
                { x: 1.2, y: 0.25, z: -2.0 } 
            ];

            const wheelGroup = new THREE.Group();
            wheelPositions.forEach(pos => {
                const wheel = new THREE.Mesh(wheelGeometry, wheelMaterial);
                wheel.position.set(pos.x, pos.y, pos.z);
                wheel.rotation.z = Math.PI / 2;
                wheel.castShadow = true;
                wheelGroup.add(wheel);
            });
            carGroup.add(wheelGroup); 


            const headlightStripGeometry = new THREE.BoxGeometry(0.4, 0.1, 0.05);
            [-0.8, 0.8].forEach(x => {
                const headlight = new THREE.Mesh(headlightStripGeometry, playerHeadlightMaterial);
                headlight.position.set(x, 0.4, 2.4); 
                headlight.userData.isLight = true;
                carGroup.add(headlight);
            });

            const rearBumperGeometry = new THREE.BoxGeometry(2.6, 0.25, 0.7);
            const rearBumper = new THREE.Mesh(rearBumperGeometry, frontBumperMaterial);
            rearBumper.position.set(0, 0.125, -2.6); 
            carGroup.add(rearBumper);


            const newSpoilerTaillightMaterial = playerTaillightMaterial; /* REUSED */
            const spoilerTaillightWidth = 0.15; 
            const spoilerTaillightHeight = 0.6; 
            const spoilerTaillightDepth = 0.1; 
            const spoilerTaillightSpacing = 0.1; 
            const spoilerTaillightXOffset = 1.0; 

            for (let i = 0; i < 3; i++) { 
                const taillightGeometry = new THREE.BoxGeometry(spoilerTaillightWidth, spoilerTaillightHeight, spoilerTaillightDepth);
                const taillight = new THREE.Mesh(taillightGeometry, newSpoilerTaillightMaterial); 
                taillight.position.set(
                    -(spoilerTaillightXOffset), 
                    1.15 + (0.2 - i * spoilerTaillightSpacing), 
                    -2.8 
                );
                taillight.userData.isLight = true;
                spoilerTaillights.push(taillight); 
                carGroup.add(taillight);
            }
            for (let i = 0; i < 3; i++) { 
                const taillightGeometry = new THREE.BoxGeometry(spoilerTaillightWidth, spoilerTaillightHeight, spoilerTaillightDepth);
                const taillight = new THREE.Mesh(taillightGeometry, newSpoilerTaillightMaterial);
                taillight.position.set(
                    (spoilerTaillightXOffset), 
                    1.15 + (0.2 - i * spoilerTaillightSpacing), 
                    -2.8 
                );
                taillight.userData.isLight = true;
                spoilerTaillights.push(taillight); 
                carGroup.add(taillight);
            }

            const f1BrakeLightGeometry = new THREE.BoxGeometry(0.5, 0.2, 0.1); 
            const f1BrakeLightMaterial = new THREE.MeshStandardMaterial({
                color: 0xFF0000, 
                emissive: 0xFF0000,
                emissiveIntensity: 0.0, 
                roughness: 0.1,
                metalness: 0.0,
            });
            brakeLightMesh = new THREE.Mesh(f1BrakeLightGeometry, f1BrakeLightMaterial);
            brakeLightMesh.position.set(0, 0.05, -2.6); 
            brakeLightMesh.userData.isBrakeLight = true;
            carGroup.add(brakeLightMesh);

            const frontBumperGeometry = new THREE.BoxGeometry(2.6, 0.25, 0.7);
            const frontBumper = new THREE.Mesh(frontBumperGeometry, frontBumperMaterial);
            frontBumper.position.set(0, 0.125, 2.6); 
            carGroup.add(frontBumper);

            const airIntakeGeometry = new THREE.BoxGeometry(0.9, 0.15, 0.1);
            const airIntakeLeft = new THREE.Mesh(airIntakeGeometry, airIntakeMaterial);
            airIntakeLeft.position.set(-0.8, 0.125, 2.65); 
            carGroup.add(airIntakeLeft);
            const airIntakeRight = new THREE.Mesh(airIntakeGeometry, airIntakeMaterial);
            airIntakeRight.position.set(0.8, 0.125, 2.65); 
            carGroup.add(airIntakeRight);
            const centerAirIntakeGeometry = new THREE.BoxGeometry(0.7, 0.12, 0.1);
            const centerAirIntake = new THREE.Mesh(centerAirIntakeGeometry, airIntakeMaterial);
            centerAirIntake.position.set(0, 0.125, 2.65); 
            carGroup.add(centerAirIntake);


            const diffuserMainGeometry = new THREE.BoxGeometry(2.0, 0.3, 1.2);
            const diffuserMain = new THREE.Mesh(diffuserMainGeometry, diffuserMaterial);
            diffuserMain.position.set(0, -0.05, -2.6); 
            carGroup.add(diffuserMain);

            const grilleStripMaterial = new THREE.MeshStandardMaterial({ color: 0x000000, roughness: 0.5, metalness: 0.9 });
            const numStrips = 5;
            const stripWidth = 0.1;
            const stripSpacing = (2.0 - (numStrips * stripWidth)) / (numStrips + 1);
            for (let i = 0; i < numStrips; i++) {
                const strip = new THREE.Mesh(new THREE.BoxGeometry(stripWidth, 0.25, 1.0), grilleStripMaterial);
                strip.position.set(
                    -1.0 + (i * (stripWidth + stripSpacing)) + stripWidth / 2 + stripSpacing,
                    -0.05, 
                    -2.6 
                );
                carGroup.add(strip);
            }

            const finGeometry = new THREE.BoxGeometry(0.18, 0.6, 0.7);
            const fin1 = new THREE.Mesh(finGeometry, finMaterial);
            fin1.position.set(-0.7, 0.1, -2.5); 
            fin1.rotation.y = Math.PI / 6;
            carGroup.add(fin1);
            const fin2 = new THREE.Mesh(finGeometry, finMaterial);
            fin2.position.set(0.7, 0.1, -2.5); 
            fin2.rotation.y = -Math.PI / 6;
            carGroup.add(fin2);

            const exhaustGeometry = new THREE.CylinderGeometry(0.2, 0.2, 0.4, 8);
            const exhaustMaterial = new THREE.MeshStandardMaterial({ color: 0x333333, roughness: 0.3, metalness: 0.9 });
            const exhaust1 = new THREE.Mesh(exhaustGeometry, exhaustMaterial);
            exhaust1.position.set(-0.9, -0.05, -2.6); 
            exhaust1.rotation.x = Math.PI / 2;
            carGroup.add(exhaust1);
            const exhaust2 = new THREE.Mesh(exhaustGeometry, exhaustMaterial);
            exhaust2.position.set(0.9, -0.05, -2.6); 
            exhaust2.rotation.x = Math.PI / 2;
            carGroup.add(exhaust2);

            const spoilerSupportGeometry = new THREE.BoxGeometry(0.15, 0.8, 0.15); 
            const spoilerSupportMaterial = new THREE.MeshStandardMaterial({ color: 0x222222, roughness: 0.6, metalness: 0.7 });
            const leftSupport = new THREE.Mesh(spoilerSupportGeometry, spoilerSupportMaterial);
            leftSupport.position.set(-1.1, 0.8, -2.5); 
            carGroup.add(leftSupport);
            const rightSupport = new THREE.Mesh(spoilerSupportGeometry, spoilerSupportMaterial);
            rightSupport.position.set(1.1, 0.8, -2.5); 
            carGroup.add(rightSupport);

            const spoilerWingMaterial = new THREE.MeshStandardMaterial({
                color: 0x000000, 
                roughness: 0.4,
                metalness: 0.8
            });
            const spoilerWingGeometry = new THREE.BoxGeometry(2.6, 0.15, 0.6); 
            const spoilerWing = new THREE.Mesh(spoilerWingGeometry, spoilerWingMaterial);
            spoilerWing.position.set(0, 1.25, -2.7); 
            spoilerWing.rotation.x = -Math.PI / 10;
            carGroup.add(spoilerWing);

            const cutGeometry = new THREE.BoxGeometry(2.0, 0.05, 0.05); 
            const cutMaterial = new THREE.MeshBasicMaterial({ color: 0x111111 }); 
            for (let i = 0; i < 3; i++) {
                const cut = new THREE.Mesh(cutGeometry, cutMaterial);
                cut.position.set(
                    0,
                    1.25 + (0.1 - i * 0.07), 
                    -2.7 
                );
                carGroup.add(cut);
            }

            car = carGroup;
            car.rotation.y = Math.PI; 
            scene.add(car);
            car.position.z = -5; 

            // Kalkan Meshi (ba≈ülangƒ±√ßta g√∂r√ºnmez)
            const shieldGeometry = new THREE.SphereGeometry(4, 32, 16);
            const shieldMaterial = new THREE.MeshBasicMaterial({
                color: 0xADD8E6,
                transparent: true,
                opacity: 0.3,
                blending: THREE.AdditiveBlending
            });
            shieldMesh = new THREE.Mesh(shieldGeometry, shieldMaterial);
            shieldMesh.visible = false;
            car.add(shieldMesh);

            carGroup.userData.originalLength = playerCarLength; // D√ºzeltme: global sabiti kullan
            carGroup.userData.originalWidth = playerCarWidth; // D√ºzeltme: global sabiti kullan

            return { car: carGroup, length: playerCarLength, width: playerCarWidth }; // D√ºzeltme: global sabiti kullan
        }


        function createPlayerHeadlight() {
            playerHeadlight = new THREE.SpotLight(0xFFFFFF, 0, 100, Math.PI / 8, 0.5, 2);
            playerHeadlight.position.set(0, 1.0, 2.5); 
            playerHeadlight.target = new THREE.Object3D();
            playerHeadlight.target.position.set(0, 0.5, 50); 

            car.add(playerHeadlight); 
            car.add(playerHeadlight.target); 

            playerHeadlight.castShadow = true;
            playerHeadlight.shadow.mapSize.width = 512;
            playerHeadlight.shadow.mapSize.height = 512;
            playerHeadlight.shadow.camera.near = 0.1;
            playerHeadlight.shadow.camera.far = 100;
        }

        function createRoad() {
            const roadMaterial = new THREE.MeshStandardMaterial({
                color: 0xBBBBBB,
                roughness: 0.8,
                metalness: 0.1,
            });

            for (let i = 0; i < 30; i++) {
                const roadGeometry = new THREE.PlaneGeometry(roadWidth, 20);
                const roadSegment = new THREE.Mesh(roadGeometry, roadMaterial);
                roadSegment.rotation.x = -Math.PI / 2;
                roadSegment.position.z = i * 20 - 200;
                roadSegment.receiveShadow = true;
                scene.add(roadSegment);
                road.push(roadSegment);

                const dashedLineGeometry = new THREE.PlaneGeometry(0.4, 8);
                const lineMaterial = new THREE.MeshPhongMaterial({ color: 0xAAAAAA, emissive: 0x444444, emissiveIntensity: 1.5 });

                const laneDivider1X = -laneWidth / 2;
                const laneDivider2X = laneWidth / 2;

                [laneDivider1X, laneDivider2X].forEach(xOffset => {
                    for (let j = 0; j < 3; j++) {
                        const dashedLine = new THREE.Mesh(dashedLineGeometry, lineMaterial);
                        dashedLine.rotation.x = -Math.PI / 2;
                        dashedLine.position.set(xOffset, 0.01, (i * 20 - 200) + (j * 8 - 8));
                        dashedLine.userData.isRoadLine = true;
                        scene.add(dashedLine);
                        road.push(dashedLine);
                    }
                });
            }
        }

        function createRoadside() {
            const grassMaterial = new THREE.MeshStandardMaterial({
                color: 0x4CAF50,
                roughness: 0.9,
                metalness: 0.0
            });

            for (let i = 0; i < 30; i++) {
                const zPos = i * 20 - 200;

                const leftRoadsideGeometry = new THREE.PlaneGeometry(roadsideWidth, 20);
                const leftRoadside = new THREE.Mesh(leftRoadsideGeometry, grassMaterial);
                leftRoadside.rotation.x = -Math.PI / 2;
                leftRoadside.position.set(-(roadWidth / 2) - (roadsideWidth / 2), -0.01, zPos);
                leftRoadside.receiveShadow = true;
                scene.add(leftRoadside);
                road.push(leftRoadside);

                const rightRoadsideGeometry = new THREE.PlaneGeometry(roadsideWidth, 20);
                const rightRoadside = new THREE.Mesh(rightRoadsideGeometry, grassMaterial);
                rightRoadside.rotation.x = -Math.PI / 2;
                rightRoadside.position.set((roadWidth / 2) + (roadsideWidth / 2), -0.01, zPos);
                rightRoadside.receiveShadow = true;
                scene.add(rightRoadside);
                road.push(rightRoadside);
            }
        }

        function createBarriers() {
            const barrierHeight = 1;
            const barrierWidth = 0.5;
            const barrierMaterial = new THREE.MeshStandardMaterial({
                color: 0x555555,
                roughness: 0.7,
                metalness: 0.3
            });
            const barrierStripeMaterial = new THREE.MeshPhongMaterial({ color: 0xFF6600, emissive: 0xFF8800, emissiveIntensity: 2.0 });

            const barrierLeftX = -(roadWidth / 2) - (barrierWidth / 2);
            const barrierRightX = (roadWidth / 2) + (barrierWidth / 2);

            for (let i = 0; i < 30; i++) {
                const zPos = i * 20 - 200;

                const leftBarrier = new THREE.Mesh(new THREE.BoxGeometry(barrierWidth, barrierHeight, 20), barrierMaterial);
                leftBarrier.position.set(barrierLeftX, barrierHeight / 2, zPos);
                leftBarrier.castShadow = true;
                leftBarrier.receiveShadow = true;
                scene.add(leftBarrier);
                barriers.push(leftBarrier);

                for (let k = 0; k < 5; k++) {
                    const stripe = new THREE.Mesh(new THREE.BoxGeometry(barrierWidth + 0.01, barrierHeight + 0.01, 2), barrierStripeMaterial);
                    stripe.position.set(barrierLeftX, barrierHeight / 2, zPos - 10 + k * 4);
                    stripe.userData.isBarrierStripe = true;
                    scene.add(stripe);
                    barriers.push(stripe);
                }

                const rightBarrier = new THREE.Mesh(new THREE.BoxGeometry(barrierWidth, barrierHeight, 20), barrierMaterial);
                rightBarrier.position.set(barrierRightX, barrierHeight / 2, zPos);
                rightBarrier.castShadow = true;
                rightBarrier.receiveShadow = true;
                scene.add(rightBarrier);
                barriers.push(rightBarrier);

                for (let k = 0; k < 5; k++) {
                    const stripe = new THREE.Mesh(new THREE.BoxGeometry(barrierWidth + 0.01, barrierHeight + 0.01, 2), barrierStripeMaterial);
                    stripe.position.set(barrierRightX, barrierHeight / 2, zPos - 10 + k * 4);
                    stripe.userData.isBarrierStripe = true;
                    scene.add(stripe);
                    barriers.push(stripe);
                }
            }
        }

        function createTrafficCar(color, type = 'sedan', isPolice = false) {
            const carGroup = new THREE.Group();
            let bodyGeometry, roofGeometry, cabGeometry;
            let wheelPositions;
            let carLength, carWidth;
            let bodyYPosition;

            const bodyMaterial = new THREE.MeshStandardMaterial({
                color: color,
                roughness: 0.6,
                metalness: 0.1
            });
            const windowMaterial = new THREE.MeshStandardMaterial({
                color: 0x99DDFf,
                transparent: true,
                opacity: 0.7,
                roughness: 0.3,
                metalness: 0.0
            });
            const wheelMaterial = new THREE.MeshStandardMaterial({
                color: 0x1A1A1A,
                roughness: 0.8,
                metalness: 0.6
            });
            const trafficHeadlightMaterial = new THREE.MeshStandardMaterial({
                color: 0xFFFF88,
                emissive: 0xCCCC00,
                emissiveIntensity: 1.0,
                roughness: 0.1
            });
            const trafficTaillightMaterial = new THREE.MeshStandardMaterial({
                color: 0xFF0000,
                emissive: 0xAA0000,
                emissiveIntensity: 1.0,
                roughness: 0.1
            });

            switch (type) {
                case 'sedan':
                    bodyGeometry = new THREE.BoxGeometry(1.9, 0.9, 4.0);
                    roofGeometry = new THREE.BoxGeometry(1.7, 0.7, 2.2);
                    wheelPositions = [
                        { x: -1.05, y: 0.35, z: 1.6 },
                        { x: 1.05, y: 0.35, z: 1.6 },
                        { x: -1.05, y: 0.35, z: -1.6 },
                        { x: 1.05, y: 0.35, z: -1.6 }
                    ];
                    carLength = 4.0;
                    carWidth = 1.9;
                    bodyYPosition = 0.45;
                    break;
                case 'truck':
                    bodyGeometry = new THREE.BoxGeometry(2.2, 1.2, 6.5);
                    cabGeometry = new THREE.BoxGeometry(2.0, 1.5, 2.5);
                    wheelPositions = [
                        { x: -1.0, y: 0.6, z: 2.8 },
                        { x: 1.0, y: 0.6, z: 2.8 },
                        { x: -1.0, y: 0.6, z: -2.8 },
                        { x: 1.0, y: 0.6, z: -2.8 }
                    ];
                    carLength = 6.5;
                    carWidth = 2.2;
                    bodyYPosition = 0.6;
                    break;
                case 'sport': 
                    bodyGeometry = new THREE.BoxGeometry(1.8, 0.6, 3.8);
                    roofGeometry = new THREE.BoxGeometry(1.6, 0.4, 1.5);
                    wheelPositions = [
                        { x: -1.1, y: 0.2, z: 1.4 },
                        { x: 1.1, y: 0.2, z: 1.4 },
                        { x: -1.1, y: 0.2, z: -1.4 },
                        { x: 1.1, y: 0.2, z: -1.4 }
                    ];
                    carLength = 3.8;
                    carWidth = 1.8;
                    bodyYPosition = 0.3;

                    if (isPolice) {
                        bodyMaterial.color.set(0x000000);
                        
                        const policeLightGroup = new THREE.Group();
                        const lightBarGeometry = new THREE.BoxGeometry(1.2, 0.2, 0.3); 
                        const lightBarMesh = new THREE.Mesh(lightBarGeometry, new THREE.MeshStandardMaterial({color: 0x333333, roughness: 0.5, metalness: 0.8}));
                        lightBarMesh.position.y = 0.6; 
                        policeLightGroup.add(lightBarMesh);

                        const redLightBulb = new THREE.Mesh(new THREE.SphereGeometry(0.1, 8, 8), new THREE.MeshBasicMaterial({ color: 0xFF0000 }));
                        redLightBulb.position.set(-0.3, 0.6, 0.1); 
                        policeLightGroup.add(redLightBulb);

                        const blueLightBulb = new THREE.Mesh(new THREE.SphereGeometry(0.1, 8, 8), new THREE.MeshBasicMaterial({ color: 0x0000FF }));
                        blueLightBulb.position.set(0.3, 0.6, 0.1); 
                        policeLightGroup.add(blueLightBulb);
                        
                        const polisTextGeometry = new THREE.PlaneGeometry(1.2, 0.4); 
                        const polisTextMaterial = new THREE.MeshBasicMaterial({ color: 0xFFFFFF, side: THREE.DoubleSide }); 
                        const polisTextPlane = new THREE.Mesh(polisTextGeometry, polisTextMaterial);
                        polisTextPlane.position.set(0, 0.8, 2.0); 
                        polisTextPlane.rotation.x = Math.PI / 2; 
                        carGroup.add(polisTextPlane);

                        policeLightGroup.userData.redLightBulb = redLightBulb;
                        policeLightGroup.userData.blueLightBulb = blueLightBulb;
                        policeLightGroup.userData.lightState = 0; 

                        policeLightGroup.position.set(0, bodyYPosition + 0.5, 0); 
                        carGroup.add(policeLightGroup);

                        carGroup.userData.policeLightGroup = policeLightGroup; 
                    }
                    break;
                case 'minivan':
                    bodyGeometry = new THREE.BoxGeometry(2.1, 1.4, 4.5);
                    roofGeometry = new THREE.BoxGeometry(1.9, 1.1, 2.8);
                    wheelPositions = [
                        { x: -1.15, y: 0.6, z: 1.8 },
                        { x: 1.15, y: 0.6, z: 1.8 },
                        { x: -1.15, y: 0.6, z: -1.8 },
                        { x: 1.15, y: 0.6, z: -1.8 }
                    ];
                    carLength = 4.5;
                    carWidth = 2.1;
                    bodyYPosition = 0.7;
                    break;
                case 'bus':
                    bodyGeometry = new THREE.BoxGeometry(2.8, 2.2, 9.0);
                    wheelPositions = [
                        { x: -1.2, y: 1.0, z: 3.5 },
                        { x: 1.2, y: 1.0, z: 3.5 },
                        { x: -1.2, y: 1.0, z: -3.5 },
                        { x: 1.2, y: 1.0, z: -3.5 }
                    ];
                    carLength = 9.0;
                    carWidth = 2.8;
                    bodyYPosition = 1.1;
                    break;
                default: /* sedan as default */
                    bodyGeometry = new THREE.BoxGeometry(1.9, 0.9, 4.0);
                    roofGeometry = new THREE.BoxGeometry(1.7, 0.7, 2.2);
                    wheelPositions = [
                        { x: -1.05, y: 0.35, z: 1.6 },
                        { x: 1.05, y: 0.35, z: 1.6 },
                        { x: -1.05, y: 0.35, z: -1.6 },
                        { x: 1.05, y: 0.35, z: -1.6 }
                    ];
                    carLength = 4.0;
                    carWidth = 1.9;
                    bodyYPosition = 0.45;
                    break;
            }

            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            body.position.y = bodyYPosition;
            body.castShadow = true;
            carGroup.add(body);

            if (type === 'sedan' || type === 'minivan') {
                const roof = new THREE.Mesh(roofGeometry, bodyMaterial);
                roof.position.y = bodyYPosition + (bodyGeometry.parameters.height / 2) + (roofGeometry.parameters.height / 2) - 0.2;
                roof.position.z = bodyGeometry.parameters.depth / 2 - roofGeometry.parameters.depth / 2 - (type === 'minivan' ? 0.3 : 0.5);
                roof.castShadow = true;
                carGroup.add(roof);

                const windowGeom = new THREE.BoxGeometry(roofGeometry.parameters.width * 0.9, roofGeometry.parameters.height * 0.8, roofGeometry.parameters.depth * 0.9);
                const frontWindow = new THREE.Mesh(windowGeom, windowMaterial);
                frontWindow.position.set(0, roof.position.y, roof.position.z + roofGeometry.parameters.depth / 4);
                carGroup.add(frontWindow);

                const rearWindow = new THREE.Mesh(windowGeom, windowMaterial);
                rearWindow.position.set(0, roof.position.y, roof.position.z - roofGeometry.parameters.depth / 4);
                carGroup.add(rearWindow);

            } else if (type === 'sport' && !isPolice) { 
                const sportCabGeometry = new THREE.BoxGeometry(1.6, 0.5, 2.0);
                const sportCab = new THREE.Mesh(sportCabGeometry, bodyMaterial);
                sportCab.position.y = bodyYPosition + 0.5;
                sportCab.position.z = 0;
                sportCab.castShadow = true;
                carGroup.add(sportCab);

                const spoilerGeometry = new THREE.BoxGeometry(1.5, 0.1, 0.3);
                const spoiler = new THREE.Mesh(spoilerGeometry, bodyMaterial);
                spoiler.position.set(0, bodyYPosition + 0.8, -bodyGeometry.parameters.depth / 2 - 0.1);
                spoiler.castShadow = true;
                carGroup.add(spoiler);

            } else if (type === 'truck') {
                const cab = new THREE.Mesh(cabGeometry, bodyMaterial);
                cab.position.y = bodyYPosition + (bodyGeometry.parameters.height / 2) + (cabGeometry.parameters.height / 2) - 0.6;
                cab.position.z = bodyGeometry.parameters.depth / 2 - cabGeometry.parameters.depth / 2 + 1;
                cab.castShadow = true;
                carGroup.add(cab);
            }

            const wheelGeometry = new THREE.CylinderGeometry(0.4, 0.4, 0.35, 16);
            wheelPositions.forEach(pos => {
                const wheel = new THREE.Mesh(wheelGeometry, wheelMaterial);
                wheel.position.set(pos.x, pos.y, pos.z);
                wheel.rotation.z = Math.PI / 2;
                wheel.castShadow = true;
                carGroup.add(wheel);
            });

            const generalHeadlightMaterial = trafficHeadlightMaterial;
            const generalTaillightMaterial = trafficTaillightMaterial;

            if (type === 'sedan' || type === 'sport' || type === 'minivan') {
                const headlightStripGeometry = new THREE.BoxGeometry(0.3, 0.1, 0.05);
                [-0.7, 0.7].forEach(x => {
                    const headlight = new THREE.Mesh(headlightStripGeometry, generalHeadlightMaterial);
                    headlight.position.set(x, bodyYPosition + 0.2, bodyGeometry.parameters.depth / 2 - 0.05);
                    headlight.userData.isLight = true;
                    carGroup.add(headlight);
                });

                const taillightStripGeometry = new THREE.BoxGeometry(0.3, 0.1, 0.05);
                [-0.7, 0.7].forEach(x => {
                    const taillight = new THREE.Mesh(taillightStripGeometry, generalTaillightMaterial);
                    taillight.position.set(x, bodyYPosition + 0.2, -bodyGeometry.parameters.depth / 2 + 0.05);
                    taillight.userData.isLight = true;
                    carGroup.add(taillight);
                });
            } else if (type === 'truck') {
                const headlightGeometry = new THREE.BoxGeometry(0.3, 0.2, 0.1);
                [-0.7, 0.7].forEach(x => {
                    const headlight = new THREE.Mesh(headlightGeometry, generalHeadlightMaterial);
                    headlight.position.set(x, bodyYPosition + 1.0, (bodyGeometry.parameters.depth / 2) + 0.5);
                    headlight.userData.isLight = true;
                    carGroup.add(headlight);
                });
                const taillightGeometry = new THREE.BoxGeometry(0.5, 0.2, 0.1);
                [-0.7, 0.7].forEach(x => {
                    const taillight = new THREE.Mesh(taillightGeometry, generalTaillightMaterial);
                    taillight.position.set(x, bodyYPosition + 0.2, -(bodyGeometry.parameters.depth / 2) - 0.05);
                    taillight.userData.isLight = true;
                    carGroup.add(taillight);
                });
            } else if (type === 'bus') {
                const headlightGeometry = new THREE.BoxGeometry(0.6, 0.3, 0.1);
                [-0.9, 0.9].forEach(x => {
                    const headlight = new THREE.Mesh(headlightGeometry, generalHeadlightMaterial);
                    headlight.position.set(x, bodyYPosition + 1.2, bodyGeometry.parameters.depth / 2 - 0.1);
                    headlight.userData.isLight = true;
                    carGroup.add(headlight);
                });
                 const taillightGeometry = new THREE.BoxGeometry(0.8, 0.4, 0.1);
                [-0.9, 0.9].forEach(x => {
                    const taillight = new THREE.Mesh(taillightGeometry, generalTaillightMaterial);
                    taillight.position.set(x, bodyYPosition + 0.4, -(bodyGeometry.parameters.depth / 2) + 0.05);
                    taillight.userData.isLight = true;
                    carGroup.add(taillight);
                });
            }

            // √ñNEMLƒ∞ D√úZELTME: Boyut verilerini arabanƒ±n kendisine kaydet
            carGroup.userData.originalLength = carLength;
            carGroup.userData.originalWidth = carWidth;
            carGroup.userData.length = carLength;
            carGroup.userData.width = carWidth;

            return { car: carGroup, length: carLength, width: carWidth };
        }

        function createInitialTrafficCars(count) {
            for (let i = 0; i < count; i++) {
                let newCar = getPooledTrafficCar();
                if (newCar) {
                    const lane = lanes[Math.floor(Math.random() * lanes.length)];
                    let zSpawnPosition = -150 - (i * (Math.random() * 40 + 40));

                    let overlap = true;
                    let attempts = 0;
                    while (overlap && attempts < 20) {
                        overlap = false;
                        for (const existingCar of trafficCars) {
                            if (Math.abs(existingCar.position.x - lane) < laneWidth / 2 &&
                                Math.abs(existingCar.position.z - zSpawnPosition) < (existingCar.userData.length / 2 + newCar.userData.length / 2 + minDistanceBetweenCars)) {
                                overlap = true;
                                zSpawnPosition -= (existingCar.userData.length + newCar.userData.length + minDistanceBetweenCars);
                                break;
                            }
                        }
                        attempts++;
                    }
                    if (overlap) { 
                        zSpawnPosition = camera.position.z - 500 - (Math.random() * 200);
                    }

                    newCar.position.set(lane, 0, zSpawnPosition);
                    newCar.rotation.y = Math.PI; 
                    newCar.userData.currentLane = lane;
                    newCar.userData.targetLane = lane;
                    newCar.userData.isChangingLane = false;
                    newCar.userData.wander = (Math.random() - 0.5) * 0.5;
                    newCar.userData.wanderTarget = (Math.random() - 0.5) * 0.5;
                    newCar.visible = true;
                    trafficCars.push(newCar);
                }
            }
        }

        function getPooledTrafficCar() {
            const car = pooledTrafficCars.find(c => !c.visible);
            if (car) {
                car.visible = true;
                // √ñNEMLƒ∞ D√úZELTME: Havuzdan alƒ±nan arabanƒ±n boyutlarƒ±nƒ± geri y√ºkle
                car.userData.length = car.userData.originalLength;
                car.userData.width = car.userData.originalWidth;
                return car;
            }
            return null;
        }

        function releasePooledTrafficCar(car) {
            car.visible = false;
            car.position.set(0, 0, -1000); 
        }


        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function onKeyDown(e) {
            if (e.key) {
                const lowerKey = e.key.toLowerCase();
                keys[lowerKey] = true;

                if (keyMap[lowerKey]) {
                    keyMap[lowerKey].classList.add('active');
                }
            }
            if ((e.key === 'arrowdown' || e.key === 's') && gameRunning) {
                if (brakeLightMesh) {
                    brakeLightMesh.material.emissiveIntensity = 5.0; 
                    brakeLightMesh.material.needsUpdate = true;
                }
                if (carSpeed > 5 && (!window.currentBrakeSound || window.currentBrakeSound.playState !== 'playing')) {
                    window.currentBrakeSound = playSound(brakeBuffer, THREE.MathUtils.mapLinear(carSpeed, 0, maxSpeed, 0.2, 0.8), true);
                } else if (window.currentBrakeSound) {
                    window.currentBrakeSound.gainNode.gain.setValueAtTime(THREE.MathUtils.mapLinear(carSpeed, 0, maxSpeed, 0.2, 0.8), audioContext.currentTime);
                }
            }
            if ((e.key === 'r' || e.key === 'R') && gameRunning) {
                fireRocket();
            }
        }

        function onKeyUp(e) {
            if (e.key) {
                const lowerKey = e.key.toLowerCase();
                keys[lowerKey] = false;

                if (keyMap[lowerKey]) {
                    keyMap[lowerKey].classList.remove('active');
                }
            }
            if (window.currentBrakeSound) {
                window.currentBrakeSound.stop();
                window.currentBrakeSound = null;
            }
            if (brakeLightMesh) {
                brakeLightMesh.material.emissiveIntensity = 0.0;
                brakeLightMesh.material.needsUpdate = true;
            }
        }

        function startActuallyGame() {
            console.log("startActuallyGame √ßaƒürƒ±ldƒ±.");
            hideAllScreensForGame(); 
            
            if (introGainNode) {
                introGainNode.gain.setValueAtTime(0.25, audioContext.currentTime); 
            }

            startEngineSound();
            startGame(); 
        }


        function startGame() {
            console.log("startGame √ßaƒürƒ±ldƒ±.");
            gameRunning = true;
            gameStarted = true;
            score = 0;
            distance = 0;
            level = 1;
            combo = 0;
            highCombo = 0;
            carSpeed = 0;
            roadSpeed = 0.5;
            carTilt = 0;
            rockets = 0; 
            trafficCarsDestroyedByRocket = 0;
            rocketsFiredCount = 0; 
            health = 100;
            updateHealthBar();
            document.getElementById('rocketsDisplay').textContent = rockets;
            nextRadarSpawnDistance = 0;

            car.position.set(0, 0, -5);
            car.rotation.y = Math.PI; 
            car.rotation.z = 0; 

            car.children.forEach(child => {
                if (child.isGroup && child.children.some(grandchild => grandchild.geometry instanceof THREE.CylinderGeometry)) {
                    child.rotation.z = 0; 
                }
            });

            if (brakeLightMesh) {
                brakeLightMesh.material.emissiveIntensity = 0.0;
                brakeLightMesh.material.needsUpdate = true;
            }
            spoilerTaillights.forEach(light => {
                if (light && light.material) {
                    light.material.emissiveIntensity = 5.0; 
                    light.material.needsUpdate = true;
                }
            });


            if (window.currentBrakeSound) {
                window.currentBrakeSound.stop();
                window.currentBrakeSound = null;
            }
            if (activePoliceCar && activePoliceCar.userData.sirenSource) {
                activePoliceCar.userData.sirenSource.stop();
                activePoliceCar.userData.sirenSource.disconnect();
                activePoliceCar.userData.sirenSource = null;
                activePoliceCar.userData.sirenGainNode = null;
            }

            trafficCars.forEach(car => releasePooledTrafficCar(car));
            trafficCars = [];
            policeCarsPool.forEach(pCar => pCar.visible = false); 

            createInitialTrafficCars(15); 
            roadsideElements.forEach(obj => scene.remove(obj));
            roadsideElements = [];
            radarPoles.forEach(obj => scene.remove(obj));
            radarPoles = [];
            createInitialRoadsideElements(10);

            powerUps.forEach(powerUp => scene.remove(powerUp)); 
            powerUps = []; 
            lastPowerUpSpawnTime = Date.now(); 

            if (activeRocket) {
                scene.remove(activeRocket);
                activeRocket = null;
            }
            rocketParticles.forEach(p => scene.remove(p));
            rocketParticles = [];

            /* Konsolu belirli bir s√ºre sonra gizle */
            if (cockpitConsole) {
                setTimeout(() => {
                    cockpitConsole.style.bottom = '-200px'; 
                    cockpitConsole.style.opacity = '0'; 
                    cockpitConsole.style.pointerEvents = 'none'; 
                }, 5000); 
            }

            if (!animationFrameId) {
                animationFrameId = requestAnimationFrame(update);
            }

            // Yeni eklemeler
            sirenWarningCount = 0;
            sirenStarElements = Array.from(document.querySelectorAll('.siren-star'));
            updateSirenStars(); // Yƒ±ldƒ±zlarƒ± ba≈ülangƒ±√ßta bo≈üalt
        }

        function getPooledPoliceCar() {
            let policeCar = policeCarsPool.find(car => !car.visible);
            if (policeCar) {
                policeCar.visible = true;
            } else {
                const { car: newPoliceCar, length, width } = createTrafficCar(0x000000, 'sport', true);
                newPoliceCar.userData.isPooled = true;
                newPoliceCar.userData.length = length;
                newPoliceCar.userData.width = width;
                newPoliceCar.userData.type = 'sport';
                newPoliceCar.userData.isPolice = true;
                newPoliceCar.userData.currentLane = 0;
                newPoliceCar.userData.targetLane = 0;
                newPoliceCar.userData.isChangingLane = false;
                newPoliceCar.userData.wander = 0;
                newPoliceCar.userData.wanderTarget = 0;
                newPoliceCar.userData.lastX = 0;
                newPoliceCar.userData.trafficCollisions = 0;
                scene.add(newPoliceCar);
                policeCarsPool.push(newPoliceCar);
                policeCar = newPoliceCar;
            }
            policeCar.userData.policeStartTime = Date.now();
            policeCar.userData.isChangingLane = false;
            policeCar.userData.wander = 0;
            policeCar.userData.wanderTarget = 0;
            policeCar.userData.lastSpeedSample = carSpeed;
            policeCar.userData.trafficCollisions = 0;
            return policeCar;
        }

        function releasePooledPoliceCar(policeCar) {
            policeCar.visible = false;
            policeCar.position.set(0, 0, -1000);
            if (policeCar.userData.policeLightGroup) {
                 policeCar.userData.policeLightGroup.userData.redLightBulb.material.emissiveIntensity = 0;
                 policeCar.userData.policeLightGroup.userData.blueLightBulb.material.emissiveIntensity = 0;
                 policeCar.userData.policeLightGroup.userData.lightState = 0;
            }
            if (policeCar.userData.sirenSource) {
                policeCar.userData.sirenSource.stop();
                policeCar.userData.sirenSource.disconnect();
                policeCar.userData.sirenSource = null;
                policeCar.userData.sirenGainNode = null;
            }
        }

        function gameOver() {
            gameRunning = false;
            cancelAnimationFrame(animationFrameId);
            animationFrameId = null;

            if (engineSource) {
                engineSource.stop();
                engineSource.disconnect();
                engineSource = null;
                engineGainNode = null;
            }
            if (activePoliceCar && activePoliceCar.userData.sirenSource) {
                activePoliceCar.userData.sirenSource.stop();
                activePoliceCar.userData.sirenSource = null;
            }
            if (window.currentBrakeSound) {
                window.currentBrakeSound.stop();
                window.currentBrakeSound = null;
            }
            if (brakeLightMesh) {
                brakeLightMesh.material.emissiveIntensity = 0.0;
                brakeLightMesh.material.needsUpdate = true;
            }
            spoilerTaillights.forEach(light => {
                if (light && light.material) {
                    light.material.emissiveIntensity = 0.0; 
                    light.material.needsUpdate = true;
                }
            });
            
            // Intro sesini durdurup yeniden ba≈ülat
            if (introSource) {
                try { introSource.stop(); } catch(e) {}
            }
            
            if (introBuffer && audioContext) { 
                introSource = audioContext.createBufferSource();
                introSource.buffer = introBuffer;
                introSource.loop = true;

                if (!introGainNode) {
                    introGainNode = audioContext.createGain();
                    introGainNode.connect(audioContext.destination);
                }

                introGainNode.gain.setValueAtTime(0.9, audioContext.currentTime);
                introSource.connect(introGainNode);
                introSource.start(0);
                introSource.playState = 'playing'; // √ñzel durum
                console.log("Intro sesi oyun bittikten sonra yeniden ba≈ülatƒ±ldƒ±.");
            } else {
                console.error("Intro sesi buffer'ƒ± y√ºklenemedi.");
            }


            document.getElementById('finalScore').textContent = score;
            document.getElementById('finalDistance').textContent = Math.floor(distance);
            document.getElementById('maxCombo').textContent = highCombo;
            document.getElementById('gameOver').style.display = 'block';

            saveHighScore(score, playerName);
            displayHighScores();

            setTimeout(() => {
                document.getElementById('gameOver').style.display = 'none';
                showPreIntroScreen(); /* Oyun bittikten sonra ilk ekranƒ± g√∂ster */
            }, 10000); // Rekorlarƒ±n g√∂r√ºnmesi i√ßin s√ºre artƒ±rƒ±ldƒ±
        }

        function createExplosion(x, y, z) {
            const fireCount = 60;
            const fireVelocities = [];
            const fireGeometry = new THREE.BufferGeometry();
            const firePositions = new Float32Array(fireCount * 3);

            for (let i = 0; i < fireCount; i++) {
                firePositions[i * 3] = x;
                firePositions[i * 3 + 1] = y;
                firePositions[i * 3 + 2] = z;
                fireVelocities.push(new THREE.Vector3((Math.random() - 0.5) * 1.2, (Math.random() - 0.5) * 1.2, (Math.random() - 0.5) * 1.2));
            }
            fireGeometry.setAttribute('position', new THREE.BufferAttribute(firePositions, 3));

            const fireMaterial = new THREE.PointsMaterial({
                color: 0xFF4500,
                size: 2.5,
                transparent: true,
                opacity: 0.9,
                blending: THREE.AdditiveBlending,
                sizeAttenuation: true,
            });
            const fireSystem = new THREE.Points(fireGeometry, fireMaterial);
            scene.add(fireSystem);

            // Siyah ve Kƒ±rmƒ±zƒ± Duman Partik√ºlleri
            const smokeCount = 80;
            const smokeVelocities = [];
            const smokeGeometry = new THREE.BufferGeometry();
            const smokePositions = new Float32Array(smokeCount * 3);
            const smokeColors = new Float32Array(smokeCount * 3);
            const smokeColor = new THREE.Color();

            for (let i = 0; i < smokeCount; i++) {
                smokePositions[i * 3] = x + (Math.random() - 0.5) * 0.5;
                smokePositions[i * 3 + 1] = y + (Math.random() - 0.5) * 0.5;
                smokePositions[i * 3 + 2] = z + (Math.random() - 0.5) * 0.5;
                smokeVelocities.push(new THREE.Vector3((Math.random() - 0.5) * 0.4, Math.random() * 0.6, (Math.random() - 0.5) * 0.4));

                if (Math.random() < 0.4) { // %40 Kƒ±rmƒ±zƒ±/Turuncu duman
                    smokeColor.set(Math.random() < 0.5 ? 0xFF4500 : 0xDC143C);
                } else { // %60 Siyah/Gri duman
                    const shade = Math.random() * 0.3;
                    smokeColor.setRGB(shade, shade, shade);
                }
                smokeColors[i * 3] = smokeColor.r;
                smokeColors[i * 3 + 1] = smokeColor.g;
                smokeColors[i * 3 + 2] = smokeColor.b;
            }
            smokeGeometry.setAttribute('position', new THREE.BufferAttribute(smokePositions, 3));
            smokeGeometry.setAttribute('color', new THREE.BufferAttribute(smokeColors, 3));

            const smokeMaterial = new THREE.PointsMaterial({
                size: 3.5,
                vertexColors: true,
                transparent: true,
                opacity: 0.6,
                blending: THREE.NormalBlending,
                sizeAttenuation: true,
            });
            const smokeSystem = new THREE.Points(smokeGeometry, smokeMaterial);
            scene.add(smokeSystem);


            let frame = 0;
            const maxFrames = 90;

            const animateParticles = () => {
                if (!gameRunning && frame > 0) { // Oyun bittiyse temizle
                    scene.remove(fireSystem);
                    scene.remove(smokeSystem);
                    return;
                }

                const firePos = fireSystem.geometry.attributes.position.array;
                for (let i = 0; i < fireCount; i++) {
                    firePos[i * 3] += fireVelocities[i].x;
                    firePos[i * 3 + 1] += fireVelocities[i].y;
                    firePos[i * 3 + 2] += fireVelocities[i].z;
                    fireVelocities[i].multiplyScalar(0.95);
                }
                fireSystem.geometry.attributes.position.needsUpdate = true;
                fireMaterial.opacity = 0.9 * (1 - (frame / maxFrames));
                fireMaterial.size *= 0.97;

                const smokePos = smokeSystem.geometry.attributes.position.array;
                for (let i = 0; i < smokeCount; i++) {
                    smokePos[i * 3] += smokeVelocities[i].x;
                    smokePos[i * 3 + 1] += smokeVelocities[i].y;
                    smokePos[i * 3 + 2] += smokeVelocities[i].z;
                    smokeVelocities[i].y += 0.008; // Duman y√ºkselir
                    smokeVelocities[i].multiplyScalar(0.97);
                }
                smokeSystem.geometry.attributes.position.needsUpdate = true;
                smokeMaterial.opacity = 0.6 * (1 - (frame / maxFrames));
                smokeMaterial.size *= 1.015; // Duman geni≈üler

                frame++;
                if (frame < maxFrames) {
                    requestAnimationFrame(animateParticles);
                } else {
                    scene.remove(fireSystem);
                    scene.remove(smokeSystem);
                }
            };
            animateParticles();
        }

        function updateCarPosition() {
            let steerInput = 0;
            if (keys['a'] || keys['arrowleft'] || mobileControls.left) {
                steerInput = -1; // Sola d√∂n
            } else if (keys['d'] || keys['arrowright'] || mobileControls.right) {
                steerInput = 1;  // Saƒüa d√∂n
            }

            // Yanal hƒ±zƒ± direksiyon girdisine g√∂re g√ºncelle
            if (steerInput !== 0) {
                // Direksiyona basƒ±lƒ±yor, hƒ±zƒ± artƒ±r
                lateralVelocity += steerIntensity * steerInput;
            } else {
                // Girdi yoksa yanal hƒ±zƒ± yava≈ü√ßa sƒ±fƒ±rla (direksiyonu d√ºzelt)
                lateralVelocity *= steerDamping;
                // √áok k√º√ß√ºkse tamamen durdur
                if (Math.abs(lateralVelocity) < 0.001) {
                    lateralVelocity = 0;
                }
            }

            // Yanal hƒ±zƒ± maksimum deƒüerle sƒ±nƒ±rla
            lateralVelocity = Math.max(-maxLateralVelocity, Math.min(maxLateralVelocity, lateralVelocity));

            // Ara√ß pozisyonunu yanal hƒ±za g√∂re g√ºncelle
            car.position.x += lateralVelocity;

            // Ara√ß eƒüimini (tilt - z ekseni) ve y√∂n√ºn√º (yaw - y ekseni) yanal hƒ±za g√∂re ayarla
            carTilt = lateralVelocity * -0.5; // Yanlara yatma
            car.rotation.z = carTilt;
            car.rotation.y = Math.PI + (lateralVelocity * -0.2); // D√∂n√º≈ü y√∂n√ºne hafif√ße bakma

            // Hƒ±zlanma ve yava≈ülama mantƒ±ƒüƒ±
            if (keys['w'] || keys['arrowup'] || mobileControls.accelerate) {
                carSpeed = Math.min(carSpeed + 1.0, maxSpeed);
            } else if (keys['s'] || keys['arrowdown'] || mobileControls.brake) {
                carSpeed = Math.max(carSpeed - 2.0, 0); // Daha keskin fren
                // Fren lambasƒ± ve ses mantƒ±ƒüƒ±
                if (brakeLightMesh) {
                    brakeLightMesh.material.emissiveIntensity = 5.0; 
                    brakeLightMesh.material.needsUpdate = true;
                }
                if (carSpeed > 5 && (!window.currentBrakeSound || window.currentBrakeSound.playState !== 'playing')) {
                    window.currentBrakeSound = playSound(brakeBuffer, THREE.MathUtils.mapLinear(carSpeed, 0, maxSpeed, 0.2, 0.8), true);
                } else if (window.currentBrakeSound) {
                    window.currentBrakeSound.gainNode.gain.setValueAtTime(THREE.MathUtils.mapLinear(carSpeed, 0, maxSpeed, 0.2, 0.8), audioContext.currentTime);
                }
            } else {
                // Normal s√ºrt√ºnme
                carSpeed = Math.max(carSpeed - 0.1, 0); 
                // Fren lambasƒ±nƒ± ve sesini kapat
                if (brakeLightMesh) {
                    brakeLightMesh.material.emissiveIntensity = 0.0; 
                    brakeLightMesh.material.needsUpdate = true;
                }
                if (window.currentBrakeSound) {
                    window.currentBrakeSound.stop();
                    window.currentBrakeSound = null;
                }
            }

            // Aracƒ±n yol sƒ±nƒ±rlarƒ± i√ßinde kalmasƒ±nƒ± saƒüla
            const roadBoundary = roadWidth / 2 - 1.5;
            car.position.x = Math.max(-roadBoundary, Math.min(roadBoundary, car.position.x));
        }

        function updateTraffic() {
            const laneChangeProbability = 0.005;
            const laneChangeSpeed = 0.05;

            for (let i = trafficCars.length - 1; i >= 0; i--) {
                const trafficCar = trafficCars[i];
                // Polis ara√ßlarƒ± artƒ±k bu fonksiyonda y√∂netilmiyor.
                if (!trafficCar || !trafficCar.visible || trafficCar.userData.isPolice) continue;

                let carCurrentSpeed = roadSpeed + (carSpeed / 100);

                // Eski polis mantƒ±ƒüƒ± (isAggressiveRammer vb.) tamamen kaldƒ±rƒ±ldƒ±.

                // NORMAL TRAFƒ∞K MANTIƒûI
                if (!trafficCar.userData.isChangingLane && Math.random() < laneChangeProbability) {
                    const currentLaneIndex = lanes.findIndex(lane => Math.abs(trafficCar.position.x - lane) < laneWidth / 2);
                    const possibleDirections = [];
                    if (currentLaneIndex > 0) possibleDirections.push(-1);
                    if (currentLaneIndex < lanes.length - 1) possibleDirections.push(1);

                    if (possibleDirections.length > 0) {
                        const direction = possibleDirections[Math.floor(Math.random() * possibleDirections.length)];
                        trafficCar.userData.targetLane = lanes[currentLaneIndex + direction];
                        trafficCar.userData.isChangingLane = true;
                    }
                }
                if (trafficCar.userData.isChangingLane) {
                    trafficCar.position.x += (trafficCar.userData.targetLane - trafficCar.position.x) * laneChangeSpeed;
                    if (Math.abs(trafficCar.position.x - trafficCar.userData.targetLane) < 0.2) {
                        trafficCar.position.x = trafficCar.userData.targetLane;
                        trafficCar.userData.isChangingLane = false;
                    }
                }

                trafficCar.position.z += carCurrentSpeed;
                trafficCar.userData.speed = carCurrentSpeed; // Hƒ±z verisini kaydet

                if (trafficCar.position.z > camera.position.z + 50) {
                    releasePooledTrafficCar(trafficCar);
                    trafficCars.splice(i, 1);
                    // activePoliceCar kontrol√º buradan kaldƒ±rƒ±ldƒ±, √ß√ºnk√º polis artƒ±k burada y√∂netilmiyor
                }
            }

            // Yeni trafik aracƒ± ekleme
            if (trafficCars.filter(tc => !tc.userData.isPolice).length < (5 + level * 2)) {
                let newCar = getPooledTrafficCar();
                if (newCar) {
                    const lane = lanes[Math.floor(Math.random() * lanes.length)];
                    let zSpawnPosition = camera.position.z - 250 - (Math.random() * 50);
                    newCar.position.set(lane, 0, zSpawnPosition);
                    Object.assign(newCar.userData, { currentLane: lane, targetLane: lane, isChangingLane: false });
                    trafficCars.push(newCar);
                }
            }
        }

        function updateRoad() {
            road.forEach(segment => {
                segment.position.z += roadSpeed + (carSpeed / 100);

                if (segment.position.z > camera.position.z + 20) {
                    segment.position.z -= 600;
                }
            });

            barriers.forEach(barrier => {
                barrier.position.z += roadSpeed + (carSpeed / 100);

                if (barrier.position.z > camera.position.z + 20) {
                    barrier.position.z -= 600;
                }
            });
        }

        function createTree(x, z) {
            const treeGroup = new THREE.Group();

            const trunkGeometry = new THREE.CylinderGeometry(0.5, 0.7, 5, 8);
            const trunkMaterial = new THREE.MeshStandardMaterial({
                color: 0x8B4513,
                roughness: 0.9,
                metalness: 0.0
            });
            const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
            trunk.position.y = 2.5;
            trunk.castShadow = true;
            treeGroup.add(trunk);

            const leavesMaterial = new THREE.MeshStandardMaterial({
                color: 0x228B22,
                roughness: 0.7,
                metalness: 0.0
            });

            const topLeaves = new THREE.Mesh(new THREE.ConeGeometry(2, 4, 8), leavesMaterial);
            topLeaves.position.y = 6;
            topLeaves.castShadow = true;
            treeGroup.add(topLeaves);

            const middleLeaves = new THREE.Mesh(new THREE.ConeGeometry(2.5, 3, 8), leavesMaterial);
            middleLeaves.position.y = 4;
            middleLeaves.castShadow = true;
            treeGroup.add(middleLeaves);

            treeGroup.position.set(x, 0, z);
            return treeGroup;
        }

        function createSign(x, z) {
            const signGroup = new THREE.Group();

            const poleGeometry = new THREE.CylinderGeometry(0.2, 0.2, 4, 6);
            const poleMaterial = new THREE.MeshStandardMaterial({
                color: 0xAAAAAA,
                roughness: 0.6,
                metalness: 0.4
            });
            const pole = new THREE.Mesh(poleGeometry, poleMaterial);
            pole.position.y = 2;
            pole.castShadow = true;
            signGroup.add(pole);

            const boardGeometry = new THREE.BoxGeometry(3, 1.5, 0.1);
            const boardMaterial = new THREE.MeshStandardMaterial({
                color: 0xFFFFFF,
                roughness: 0.7,
                metalness: 0.0
            });
            const board = new THREE.Mesh(boardGeometry, boardMaterial);
            board.position.set(0, 3.5, 0);
            board.castShadow = true;
            signGroup.add(board);

            signGroup.position.set(x, 0, z);
            return signGroup;
        }

        function createDeer(x, z) {
            const deerGroup = new THREE.Group();

            const bodyMaterial = new THREE.MeshStandardMaterial({ color: 0x8B4513, roughness: 0.8, metalness: 0.0 });
            const antlerMaterial = new THREE.MeshStandardMaterial({ color: 0xD2B48C, roughness: 0.8, metalness: 0.0 });

            const bodyGeometry = new THREE.BoxGeometry(0.8, 1.0, 1.5);
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            body.position.y = 0.5;
            body.castShadow = true;
            deerGroup.add(body);

            const headGeometry = new THREE.BoxGeometry(0.5, 0.5, 0.5);
            const head = new THREE.Mesh(headGeometry, bodyMaterial);
            head.position.set(0, 1.2, 0.6);
            head.castShadow = true;
            deerGroup.add(head);

            const legGeometry = new THREE.BoxGeometry(0.2, 0.8, 0.2);
            const legPositions = [
                { x: -0.3, z: 0.5 },
                { x: 0.3, z: 0.5 },
                { x: -0.3, z: -0.5 },
                { x: 0.3, z: -0.5 }
            ];
            legPositions.forEach(pos => {
                const leg = new THREE.Mesh(legGeometry, bodyMaterial);
                leg.position.set(pos.x, 0.4, pos.z);
                leg.castShadow = true;
                deerGroup.add(leg);
            });

            const antler1Geometry = new THREE.CylinderGeometry(0.1, 0.1, 0.8, 4);
            const antler1 = new THREE.Mesh(antler1Geometry, antlerMaterial);
            antler1.position.set(-0.15, 1.6, 0.7);
            antler1.rotation.z = Math.PI / 8;
            antler1.castShadow = true;
            deerGroup.add(antler1);

            const antler2Geometry = new THREE.CylinderGeometry(0.1, 0.1, 0.8, 4);
            const antler2 = new THREE.Mesh(antler2Geometry, antlerMaterial);
            antler2.position.set(0.15, 1.6, 0.7);
            antler2.rotation.z = -Math.PI / 8;
            antler2.castShadow = true;
            deerGroup.add(antler2);

            deerGroup.position.set(x, 0, z);
            return deerGroup;
        }

        function createRadarPoleOnce(zPos) {
            const radarSide = (Math.random() < 0.5 ? -1 : 1);
            const xPos = radarSide * (roadWidth / 2 + roadsideWidth / 2 + (Math.random() * 5));

            const radarGroup = new THREE.Group();

            const poleGeometry = new THREE.CylinderGeometry(0.2, 0.2, 5, 8);
            const poleMaterial = new THREE.MeshStandardMaterial({
                color: 0x888888,
                roughness: 0.6,
                metalness: 0.4
            });
            const pole = new THREE.Mesh(poleGeometry, poleMaterial);
            pole.position.y = 2.5;
            pole.castShadow = true;
            radarGroup.add(pole);

            const boxGeometry = new THREE.BoxGeometry(1.2, 0.8, 0.8);
            const boxMaterial = new THREE.MeshStandardMaterial({
                color: 0x000000,
                roughness: 0.5,
                metalness: 0.8
            });
            const box = new THREE.Mesh(boxGeometry, boxMaterial);
            box.position.set(0, 4.5, 0);
            box.castShadow = true;
            radarGroup.add(box);

            const lightMaterial = new THREE.MeshStandardMaterial({
                color: 0xFF0000,
                emissive: 0xFF0000,
                emissiveIntensity: 2.0,
                roughness: 0.1
            });
            const light1 = new THREE.Mesh(new THREE.SphereGeometry(0.15, 8, 8), lightMaterial);
            light1.position.set(-0.3, 4.8, 0.4);
            radarGroup.add(light1);
            const light2 = new THREE.Mesh(new THREE.SphereGeometry(0.15, 8, 8), lightMaterial);
            light2.position.set(0.3, 4.8, 0.4);
            radarGroup.add(light2);

            radarGroup.position.set(xPos, 0, zPos);
            radarGroup.userData.isRadar = true;
            radarGroup.userData.hitCooldown = 5000;
            radarGroup.userData.lastHit = 0;
            radarGroup.userData.spawnDistance = distance;

            scene.add(radarGroup);
            radarPoles.push(radarGroup);

            nextRadarSpawnDistance = distance + 5000;
        }

        function spawnPoliceCar() {
            const newPoliceCar = getPooledPoliceCar();
            if (newPoliceCar) {
                const playerLaneIndex = lanes.findIndex(lane => Math.abs(car.position.x - lane) < laneWidth / 2);
                let spawnLane;
                if (playerLaneIndex !== -1) {
                    spawnLane = lanes[playerLaneIndex];
                } else {
                    spawnLane = lanes[Math.floor(Math.random() * lanes.length)];
                }

                newPoliceCar.position.set(spawnLane, 0, car.position.z - 60); 
                newPoliceCar.rotation.y = Math.PI;
                newPoliceCar.userData.currentLane = spawnLane;
                newPoliceCar.userData.targetLane = spawnLane;
                newPoliceCar.userData.lastX = newPoliceCar.position.x;
                newPoliceCar.userData.trafficCollisions = 0;
                newPoliceCar.userData.initialHitOccurred = false;
                
                trafficCars.push(newPoliceCar);
                activePoliceCar = newPoliceCar;
                lastPoliceCarDespawnTime = Date.now();
                currentPoliceChaseDamage = 0;

                showScoreFeedback('POLƒ∞S PE≈ûƒ∞Nƒ∞ZDE!', '#FF4500');

                if (policeSirenBuffer && audioContext) {
                    if (activePoliceCar.userData.sirenSource && activePoliceCar.userData.sirenSource.playState === 'playing') {
                        activePoliceCar.userData.sirenSource.stop();
                    }
                    newPoliceCar.userData.sirenSource = playSound(policeSirenBuffer, 8.0, true);
                    if (newPoliceCar.userData.sirenSource) {
                        console.log("Polis sireni √ßalmaya ba≈üladƒ±.");
                    }
                }

                policeDamageStartTime = Date.now();
                currentPoliceChaseDamage = 0; /* Ba≈ülangƒ±√ß hasarƒ±nƒ± 0 yap */
                lastPoliceIncrementalDamageTime = Date.now();
            }
        }

        function createInitialRoadsideElements(count) {
            for (let i = 0; i < count; i++) {
                const zPos = camera.position.z - 200 - (i * (Math.random() * 50 + 30));

                const side = Math.random() < 0.5 ? -1 : 1;
                // Yol kenarƒ±ndan ba≈ülayƒ±p daƒülara doƒüru rastgele bir konuma yerle≈ütir
                const xPos = side * (roadWidth / 2 + 10 + Math.random() * (roadsideWidth - 20));
                let roadsideElement;

                if (Math.random() < 0.8) { // %80 aƒüa√ß
                    roadsideElement = createTree(xPos, zPos);
                } else { // %20 tabela veya geyik
                    if (side === 1) { // Saƒü taraf
                        roadsideElement = createSign(xPos, zPos);
                    } else { // Sol taraf
                        roadsideElement = createDeer(xPos, zPos);
                    }
                }

                roadsideElements.push(roadsideElement);
                scene.add(roadsideElement);
            }

            if (radarPoles.length === 0) {
                createRadarPoleOnce(camera.position.z - 200);
            }
        }

        function updateRoadsideElements() {
            const roadsideSpawnDistance = camera.position.z - 250;
            const roadsideRemovalDistance = camera.position.z + 50;

            let currentSpeedEffectScale = 1.0;
            if (carSpeed > SPEED_EFFECT_THRESHOLD) {
                currentSpeedEffectScale = 1.0 + (carSpeed - SPEED_EFFECT_THRESHOLD) * speedEffectScaleFactor;
            } else {
                currentSpeedEffectScale = 1.0;
            }

            for (let i = roadsideElements.length - 1; i >= 0; i--) {
                const element = roadsideElements[i];
                element.position.z += roadSpeed + (carSpeed / 100);

                element.scale.z = currentSpeedEffectScale;

                if (element.position.z > roadsideRemovalDistance) {
                    let newZPos = roadsideSpawnDistance - (Math.random() * 100);

                    let overlap = true;
                    let attempts = 0;
                    while (overlap && attempts < 10) {
                        overlap = false;
                        for (const otherElement of roadsideElements.concat(radarPoles)) {
                            if (otherElement !== element &&
                                Math.abs(otherElement.position.x - element.position.x) < 5 && 
                                Math.abs(otherElement.position.z - newZPos) < 20) { 
                                overlap = true;
                                newZPos -= 30; 
                                break;
                            }
                        }
                        attempts++;
                    }
                    
                    scene.remove(element); 
                    const side = Math.random() < 0.5 ? -1 : 1;
                    const newXPos = side * (roadWidth / 2 + 10 + Math.random() * (roadsideWidth - 20));
                    
                    if (Math.random() < 0.8) {
                        roadsideElements[i] = createTree(newXPos, newZPos);
                    } else {
                        if (side === 1) {
                            roadsideElements[i] = createSign(newXPos, newZPos);
                        } else {
                            roadsideElements[i] = createDeer(newXPos, newZPos);
                        }
                    }
                    scene.add(roadsideElements[i]); 
                    roadsideElements[i].scale.set(1,1,1); 
                }
            }

            for (let i = radarPoles.length - 1; i >= 0; i--) {
                const radar = radarPoles[i];
                radar.position.z += roadSpeed + (carSpeed / 100);
                radar.scale.z = currentSpeedEffectScale;

                if (radar.position.z > roadsideRemovalDistance) {
                    scene.remove(radar);
                    radarPoles.splice(i, 1);
                    nextRadarSpawnDistance = distance + 5000; 
                }
            }
            
            if (distance >= nextRadarSpawnDistance && radarPoles.length === 0) {
                 createRadarPoleOnce(camera.position.z - 250);
            }
        }


        function updatePowerUps() {
            const powerUpSpawnDistance = camera.position.z - 150; 
            const powerUpRemovalDistance = camera.position.z + 20; 
            const minSpawnInterval = 7000; 
            const maxSpawnInterval = 15000; 

            for (let i = powerUps.length - 1; i >= 0; i--) {
                const powerUp = powerUps[i];
                if (!powerUp) continue; 

                powerUp.position.z += roadSpeed + (carSpeed / 100);

                powerUp.rotation.y += powerUp.userData.rotationSpeed;

                powerUp.position.y = powerUp.userData.initialY + Math.sin(Date.now() * powerUp.userData.bobbingSpeed * 0.005) * 0.2;

                if (powerUp.position.z > powerUpRemovalDistance) {
                    scene.remove(powerUp);
                    powerUps.splice(i, 1);
                }
            }

            const currentTime = Date.now();
            if (currentTime - lastPowerUpSpawnTime > (minSpawnInterval + Math.random() * (maxSpawnInterval - minSpawnInterval))) {
                const lane = lanes[Math.floor(Math.random() * lanes.length)];
                const zPos = camera.position.z - 200; 

                let overlap = false;
                const minDistanceBetweenPowerUps = 20; 
                for (const existingPowerUp of powerUps) {
                    if (Math.abs(existingPowerUp.position.x - lane) < laneWidth / 2 &&
                        Math.abs(existingPowerUp.position.z - zPos) < minDistanceBetweenPowerUps) {
                        overlap = true;
                        break;
                    }
                }
                for (const existingTrafficCar of trafficCars) { 
                    if (Math.abs(existingTrafficCar.position.x - lane) < laneWidth / 2 &&
                        Math.abs(existingTrafficCar.position.z - zPos) < (existingTrafficCar.userData.length / 2 + 5)) {
                        overlap = true;
                        break;
                    }
                }

                if (!overlap) {
                    const newPowerUp = createPowerUp(lane, zPos);
                    scene.add(newPowerUp);
                    powerUps.push(newPowerUp);
                    lastPowerUpSpawnTime = currentTime;
                }
            }
        }

        function fireRocket() {
            if (rockets <= 0) {
                console.log("Roket ate≈ülenemedi: Yeterli roket yok. Mevcut roket: " + rockets);
                return;
            }
            if (Date.now() - lastRocketFireTime < rocketCooldown) {
                console.log("Roket ate≈ülenemedi: Bekleme s√ºresi dolmadƒ±. Kalan s√ºre: " + (rocketCooldown - (Date.now() - lastRocketFireTime)) + "ms");
                return;
            }

            lastRocketFireTime = Date.now();
            rockets--; 
            document.getElementById('rocketsDisplay').textContent = rockets; 

            rocketsFiredCount++; 
            console.log(`Roket atƒ±ldƒ±: ${rocketsFiredCount}. Kalan roket: ${rockets}`);

            // Yeni F√ºze Modeli
            const rocketMesh = new THREE.Group();

            // G√∂vde
            const bodyMat = new THREE.MeshStandardMaterial({ color: 0x888888, metalness: 0.8, roughness: 0.4 });
            const bodyGeom = new THREE.CylinderGeometry(0.2, 0.2, 1.8, 12);
            const bodyMesh = new THREE.Mesh(bodyGeom, bodyMat);
            rocketMesh.add(bodyMesh);

            // Sivri Kƒ±rmƒ±zƒ± U√ß
            const noseMat = new THREE.MeshStandardMaterial({ color: 0xFF0000, metalness: 0.5, roughness: 0.5 });
            const noseGeom = new THREE.ConeGeometry(0.2, 0.7, 12);
            const noseMesh = new THREE.Mesh(noseGeom, noseMat);
            noseMesh.position.y = 1.25; // G√∂vdenin ucuna
            rocketMesh.add(noseMesh);

            // Alev Partik√ºlleri
            const flameMaterial = new THREE.PointsMaterial({
                size: 0.8, // Daha b√ºy√ºk alev
                map: createFlameTexture(), // Doku ile daha ger√ßek√ßi alev
                vertexColors: false, // Doku rengini kullan
                color: 0xFF8C00, // Turuncu alev
                transparent: true,
                opacity: 0.9,
                blending: THREE.AdditiveBlending,
                sizeAttenuation: true
            });
            const flameGeometry = new THREE.BufferGeometry();
            const flamePositions = new Float32Array(50 * 3);
            flameGeometry.setAttribute('position', new THREE.BufferAttribute(flamePositions, 3));

            const flameParticles = new THREE.Points(flameGeometry, flameMaterial);
            flameParticles.position.y = -1.0; // F√ºzenin arkasƒ±na
            rocketMesh.add(flameParticles);
            rocketMesh.userData.flame = flameParticles; // G√ºncelleme i√ßin referans


            // F√ºzenin ba≈ülangƒ±√ß pozisyonu ve y√∂n√º
            rocketMesh.rotation.x = Math.PI / 2; // Yola yatay hale getir
            rocketMesh.position.copy(car.position);
            rocketMesh.position.y = 0.4; // Yere daha yakƒ±n
            rocketMesh.position.z -= 3.0;

            scene.add(rocketMesh);
            activeRocket = rocketMesh;

            if (powerUpRocketSoundBuffer) {
                playSound(powerUpRocketSoundBuffer, 0.8);
            }
        }

        function updateRocket() {
            if (!activeRocket) return;

            activeRocket.position.z -= rocketBaseSpeed * 2;
            activeRocket.rotation.y += 0.2;

            // Alev animasyonu
            const flame = activeRocket.userData.flame;
            if (flame) {
                const positions = flame.geometry.attributes.position.array;
                for (let i = 0; i < positions.length / 3; i++) {
                    positions[i * 3 + 0] += (Math.random() - 0.5) * 0.1; // X yayƒ±lƒ±mƒ±
                    positions[i * 3 + 1] += (Math.random() - 0.5) * 0.1; // Y yayƒ±lƒ±mƒ± (f√ºzenin yerel Z'si)
                    positions[i * 3 + 2] -= Math.random() * 0.2; // Geriye doƒüru uzama (f√ºzenin yerel Y'si)

                    // Partik√ºl √∂mr√º dolunca sƒ±fƒ±rla
                    if (positions[i * 3 + 2] < -2.5) {
                        positions[i * 3 + 0] = (Math.random() - 0.5) * 0.05;
                        positions[i * 3 + 1] = (Math.random() - 0.5) * 0.05;
                        positions[i * 3 + 2] = 0;
                    }
                }
                flame.geometry.attributes.position.needsUpdate = true;
                flame.material.opacity = Math.max(0, flame.material.opacity - 0.01);
            }


            const rocketBox = new THREE.Box3().setFromObject(activeRocket);

            for (let i = trafficCars.length - 1; i >= 0; i--) {
                const trafficCar = trafficCars[i];
                if (!trafficCar || !trafficCar.visible || trafficCar.userData.isPolice) continue; 

                trafficBox.setFromObject(trafficCar);

                if (rocketBox.intersectsBox(trafficBox)) {
                    createExplosion(trafficCar.position.x, trafficCar.position.y + 1, trafficCar.position.z); 
                    
                    if (trafficCar.userData.isPooled) {
                        releasePooledTrafficCar(trafficCar);
                        const index = trafficCars.indexOf(trafficCar);
                        if (index > -1) trafficCars.splice(index, 1);
                    } else { 
                        scene.remove(trafficCar);
                        const index = trafficCars.indexOf(trafficCar);
                        if (index > -1) trafficCars.splice(index, 1);
                    }

                    trafficCarsDestroyedByRocket++;
                    addScore(500); 
                    showScoreFeedback('ROKET ƒ∞SABETƒ∞! +500', '#FF8C00'); 
                    
                    // YENƒ∞ POLƒ∞S √áAƒûIRMA MANTIƒûI
                    if (!activePoliceCar) { // Sadece aktif bir polis yoksa sayacƒ± artƒ±r
                        if (Math.random() < 0.5) { // %50 ihtimalle
                           sirenWarningCount = Math.min(sirenWarningCount + 1, 3);
                           updateSirenStars();
                           if (sirenWarningCount >= 3) {
                               setTimeout(startPoliceAttackSequence, 500); 
                           }
                        }
                    }
                    
                    scene.remove(activeRocket);
                    activeRocket = null;
                    return; 
                }
            }

            if (activeRocket.position.z < camera.position.z - 300) { 
                scene.remove(activeRocket);
                activeRocket = null;
            }
        }

        function takeDamage(amount) {
            health -= amount;
            health = Math.max(0, health);
            updateHealthBar();
            if (health <= 0) {
                gameOver();
            }
        }

        function updateHealthBar() {
            const healthFillElement = document.getElementById('healthFill');
            const fillHeight = (health / maxHealth) * 100;
            const hue = (health / maxHealth) * 120;
            healthFillElement.style.height = `${fillHeight}%`;
            healthFillElement.style.background = `hsl(${hue}, 100%, 40%)`;
        }

        function checkCollisions() {
            if (!car || !gameRunning) return;
            const currentTime = Date.now();
            if (currentTime - lastCollisionTime < collisionCooldown) return;

            const p = {
                front: car.position.z - (playerCarLength / 2),
                rear: car.position.z + (playerCarLength / 2),
                left: car.position.x - (playerCarWidth / 2),
                right: car.position.x + (playerCarWidth / 2)
            };

            // 1. Bariyerlerle √áarpƒ±≈üma Kontrol√º
            const leftBarrierX = -roadWidth / 2;
            const rightBarrierX = roadWidth / 2;
            if (p.right > rightBarrierX || p.left < leftBarrierX) {
                lastCollisionTime = currentTime;
                triggerCollisionShake(0.5, 30);
                takeDamage(3);
                carSpeed *= 0.8;
                car.position.x = Math.max(leftBarrierX + (playerCarWidth / 2), Math.min(rightBarrierX - (playerCarWidth / 2), car.position.x));
                return; // Bariyerle √ßarpƒ±≈üma olduysa ba≈üka kontrol yapma
            }

            // 2. Trafik Ara√ßlarƒ±yla √áarpƒ±≈üma Kontrol√º
            for (let i = trafficCars.length - 1; i >= 0; i--) {
                const trafficCar = trafficCars[i];
                if (!trafficCar || !trafficCar.visible) continue;

                const t = {
                    front: trafficCar.position.z - (trafficCar.userData.length / 2),
                    rear: trafficCar.position.z + (trafficCar.userData.length / 2),
                    left: trafficCar.position.x - (trafficCar.userData.width / 2),
                    right: trafficCar.position.x + (trafficCar.userData.width / 2)
                };

                if (p.right > t.left && p.left < t.right && p.rear > t.front && p.front < t.rear) {
                    lastCollisionTime = currentTime;
                    
                    if (trafficCar.userData.isPolice && trafficCar.userData.isAggressiveRammer) {
                        createExplosion(trafficCar.position.x, trafficCar.position.y + 1, trafficCar.position.z);
                        if (activePoliceCar && activePoliceCar.userData.sirenSound) activePoliceCar.userData.sirenSound.stop();
                        releasePooledPoliceCar(trafficCar);
                        activePoliceCar = null;
                        trafficCars.splice(i, 1);
                        takeDamage(3);
                        triggerCollisionShake(0.8, 40);
                        continue; 
                    }

                    const relativeSpeed = carSpeed - (trafficCar.userData.speed || 0);
                    const isRearEnd = (p.front < t.rear) && relativeSpeed > 10;
                    takeDamage(3);
                    triggerCollisionShake(isRearEnd ? 0.7 : 0.4, 30);
                    carSpeed *= 0.5;

                    const overlapX = Math.min(p.right, t.right) - Math.max(p.left, t.left);
                    const overlapZ = Math.min(p.rear, t.rear) - Math.max(p.front, t.front);
                    if (overlapX < overlapZ) car.position.x += (p.left < t.left ? -overlapX : overlapX) * 0.5;
                    else car.position.z += (p.front < t.front ? -overlapZ : overlapZ) * 0.5;
                }
            }
            
            // 3. G√º√ßlendirmeleri Toplama (D√ñNG√úN√úN DI≈ûINDA)
            carBox.setFromObject(car); // Box3'√º burada bir kez ayarla
            for (let i = powerUps.length - 1; i >= 0; i--) {
                const powerUp = powerUps[i];
                if (!powerUp) continue;
                powerUpBox.setFromObject(powerUp);
                if (carBox.intersectsBox(powerUpBox)) {
                    const type = powerUp.userData.type;
                    if (type === 'rocket') {
                        rockets += 2;
                        document.getElementById('rocketsDisplay').textContent = rockets;
                        showScoreFeedback('ROKET ALINDI! +2', '#FFD700');
                        if(powerUpRocketSoundBuffer) playSound(powerUpRocketSoundBuffer, 0.7);
                    } else if (type === 'health') {
                        health = Math.min(maxHealth, health + 25);
                        updateHealthBar();
                        showScoreFeedback('CAN ALINDI! +25', '#00FF7F');
                        if(powerUpHealthSoundBuffer) playSound(powerUpHealthSoundBuffer, 0.7);
                    } else if (type === 'shield') {
                        activateShield();
                        showScoreFeedback('KALKAN ALINDI!', '#00BFFF');
                        if(powerUpShieldSoundBuffer) playSound(powerUpShieldSoundBuffer, 0.7);
                    }
                    scene.remove(powerUp);
                    powerUps.splice(i, 1);
                }
            }
        }


        function updateDayNightCycle() {
            const distancePassed = distance - previousDistanceForTime;
            timeOfDay = (timeOfDay + (distancePassed / dayDurationInGameMeters) * 24) % 24;
            previousDistanceForTime = distance;

            let skyColor, fogColor, ambientColor, directionalColor;
            let directionalIntensity, ambientIntensity;
            let fogNear, fogFar;
            let timeOfDayText = '';
            let timeOfDayEmoji = '';
            let scoreMultiplier = 1.0;
            let roadLineEmissiveIntensity = 1.0;
            let barrierStripeEmissiveIntensity = 1.0;
            let playerHeadlightIntensityValue = 0;
            let trafficLightEmissiveIntensity = 0;
            let sunOpacity = 0, moonOpacity = 0, starsOpacity = 0;
            let sunLightIntensity = 0;

            const currentHour = Math.floor(timeOfDay);
            const currentMinute = Math.floor((timeOfDay - currentHour) * 60);

            // Geli≈ümi≈ü Renk Paletleri ve Atmosferik Ayarlar
            const night =   { sky: new THREE.Color(0x0a192f), fog: new THREE.Color(0x050a14), ambient: new THREE.Color(0x202040), directional: new THREE.Color(0x404050) };
            const dawn =    { sky: new THREE.Color(0x536a8e), fog: new THREE.Color(0x8a7f80), ambient: new THREE.Color(0x706060), directional: new THREE.Color(0xff8866) };
            const day =     { sky: new THREE.Color(0x87ceeb), fog: new THREE.Color(0xcccccc), ambient: new THREE.Color(0xaaaaFF), directional: new THREE.Color(0xffffff) };
            const dusk =    { sky: new THREE.Color(0xed8363), fog: new THREE.Color(0xe0835e), ambient: new THREE.Color(0x806060), directional: new THREE.Color(0xffaa77) };

            if (timeOfDay >= 21 || timeOfDay < 4) { // Gece
                skyColor = night.sky; fogColor = night.fog; ambientColor = night.ambient; directionalColor = night.directional;
                directionalIntensity = 0.2; ambientIntensity = 0.2; fogNear = 40; fogFar = 200;
                timeOfDayText = 'Gece'; timeOfDayEmoji = 'üåô'; scoreMultiplier = 1.5;
                playerHeadlightIntensityValue = 1.0; trafficLightEmissiveIntensity = 1.8;
                roadLineEmissiveIntensity = 2.0; barrierStripeEmissiveIntensity = 3.0;
                starsOpacity = 1; moonOpacity = 1; sunOpacity = 0; sunLightIntensity = 0;
            } else if (timeOfDay >= 4 && timeOfDay < 7) { // G√ºn Doƒüumu (≈ûafak)
                const progress = (timeOfDay - 4) / 3;
                skyColor = new THREE.Color().lerpColors(night.sky, dawn.sky, progress);
                fogColor = new THREE.Color().lerpColors(night.fog, dawn.fog, progress);
                ambientColor = new THREE.Color().lerpColors(night.ambient, dawn.ambient, progress);
                directionalColor = new THREE.Color().lerpColors(night.directional, dawn.directional, progress);
                directionalIntensity = THREE.MathUtils.lerp(0.2, 0.8, progress); ambientIntensity = THREE.MathUtils.lerp(0.2, 0.6, progress);
                fogNear = THREE.MathUtils.lerp(40, 70, progress); fogFar = THREE.MathUtils.lerp(200, 300, progress);
                timeOfDayText = '≈ûafak'; timeOfDayEmoji = 'üåÖ'; scoreMultiplier = 1.2;
                playerHeadlightIntensityValue = 1.0 - progress; trafficLightEmissiveIntensity = THREE.MathUtils.lerp(1.8, 0.3, progress);
                roadLineEmissiveIntensity = THREE.MathUtils.lerp(2.0, 0.5, progress); barrierStripeEmissiveIntensity = THREE.MathUtils.lerp(3.0, 1.0, progress);
                starsOpacity = 1 - progress; moonOpacity = 1 - progress; sunOpacity = progress; sunLightIntensity = progress * 0.8;
            } else if (timeOfDay >= 7 && timeOfDay < 18) { // G√ºnd√ºz
                skyColor = day.sky; fogColor = day.fog; ambientColor = day.ambient; directionalColor = day.directional;
                directionalIntensity = 1.2; ambientIntensity = 0.8; fogNear = 100; fogFar = 500;
                timeOfDayText = 'G√ºnd√ºz'; timeOfDayEmoji = '‚òÄÔ∏è'; scoreMultiplier = 1.0;
                playerHeadlightIntensityValue = 0; trafficLightEmissiveIntensity = 0.3;
                roadLineEmissiveIntensity = 0.5; barrierStripeEmissiveIntensity = 1.0;
                starsOpacity = 0; moonOpacity = 0; sunOpacity = 1; sunLightIntensity = 1.2;
            } else { // G√ºn Batƒ±mƒ± (Ak≈üam) (18 - 21)
                const progress = (timeOfDay - 18) / 3;
                skyColor = new THREE.Color().lerpColors(day.sky, dusk.sky, progress).lerp(night.sky, progress * progress);
                fogColor = new THREE.Color().lerpColors(day.fog, dusk.fog, progress).lerp(night.fog, progress * progress);
                ambientColor = new THREE.Color().lerpColors(day.ambient, dusk.ambient, progress);
                directionalColor = new THREE.Color().lerpColors(day.directional, dusk.directional, progress);
                directionalIntensity = THREE.MathUtils.lerp(1.2, 0.2, progress); ambientIntensity = THREE.MathUtils.lerp(0.8, 0.2, progress);
                fogNear = THREE.MathUtils.lerp(100, 40, progress); fogFar = THREE.MathUtils.lerp(500, 200, progress);
                timeOfDayText = 'Ak≈üam'; timeOfDayEmoji = 'üåá'; scoreMultiplier = 1.2;
                playerHeadlightIntensityValue = progress; trafficLightEmissiveIntensity = THREE.MathUtils.lerp(0.3, 1.8, progress);
                roadLineEmissiveIntensity = THREE.MathUtils.lerp(0.5, 2.0, progress); barrierStripeEmissiveIntensity = THREE.MathUtils.lerp(1.0, 3.0, progress);
                starsOpacity = progress; moonOpacity = progress; sunOpacity = 1 - progress; sunLightIntensity = (1-progress) * 1.2;
            }

            // Daƒülarƒ±n rengini sise g√∂re ayarla
            mountains.forEach(mountain => {
                if (mountain && mountain.children[0] && mountain.children[0].material) {
                    const baseMountainColor = new THREE.Color(0x6B8E23); // Orijinal renk
                    mountain.children[0].material.color.copy(baseMountainColor).lerp(fogColor, 0.4);
                    // Aƒüa√ßlarƒ±n rengini de ayarla
                    for(let i=1; i<mountain.children.length; i++) {
                        const baseTreeColor = new THREE.Color(0x006400);
                        mountain.children[i].material.color.copy(baseTreeColor).lerp(fogColor, 0.5);
                    }
                }
            });

            if (sun && moon && starField) {
                sun.material.opacity = sunOpacity;
                if (sunLight) sunLight.intensity = sunLightIntensity;
                moon.material.opacity = moonOpacity;
                starField.material.opacity = starsOpacity;
            }

            scene.children.forEach(obj => {
                if (obj instanceof THREE.AmbientLight) {
                    obj.color.copy(ambientColor);
                    obj.intensity = ambientIntensity;
                }
                if (obj instanceof THREE.DirectionalLight) {
                    obj.color.copy(directionalColor);
                    obj.intensity = directionalIntensity;
                    const angle = (timeOfDay / 24) * Math.PI * 2 - Math.PI/2; 
                    obj.position.set(Math.cos(angle) * 30, Math.sin(angle) * 20 + 15, 10); 
                }
            });

            if (skyDome && skyDome.material) {
                skyDome.material.color.set(skyColor);
            }

            renderer.setClearColor(fogColor);
            scene.fog.color.set(fogColor);
            scene.fog.near = fogNear;
            scene.fog.far = fogFar;

            car.traverse((object) => {
                if (object.material && object.userData.isLight) {
                    if (object.material instanceof THREE.MeshStandardMaterial || object.material instanceof THREE.MeshPhongMaterial) {
                        if (object.material.color.getHexString() === 'ffff88') { 
                            object.material.emissive.set(0xAAAA00);
                            object.material.emissiveIntensity = playerHeadlightIntensityValue;
                        }
                        else if (object.material.color.getHexString() === '8b0000') { 
                            object.material.emissive.set(0xFF0000); 
                            object.material.emissiveIntensity = 5.0; 
                        }
                        object.material.needsUpdate = true;
                    }
                }
            });

             trafficCars.forEach(tc => { 
                tc.traverse((object) => {
                    if (object.material && object.userData.isLight) {
                        if (object.material instanceof THREE.MeshStandardMaterial || object.material instanceof THREE.MeshPhongMaterial) {
                            if (object.material.color.getHexString() === 'ffff88') { 
                                object.material.emissive.set(0xCCCC00);
                                object.material.emissiveIntensity = trafficLightEmissiveIntensity;
                            }
                            else if (object.material.color.getHexString() === 'ff0000') { 
                                object.material.emissive.set(0xAA0000);
                                object.material.emissiveIntensity = trafficLightEmissiveIntensity;
                            }
                            object.material.needsUpdate = true;
                        }
                    }
                });
            });


            road.forEach(obj => {
                if (obj.userData.isRoadLine && obj.material instanceof THREE.MeshPhongMaterial) {
                    obj.material.emissiveIntensity = roadLineEmissiveIntensity;
                    obj.material.needsUpdate = true;
                }
            });

            barriers.forEach(obj => {
                if (obj.userData.isBarrierStripe && obj.material instanceof THREE.MeshPhongMaterial) {
                    obj.material.emissiveIntensity = barrierStripeEmissiveIntensity;
                    obj.material.needsUpdate = true;
                }
            });

            if (playerHeadlight) { 
                    playerHeadlight.intensity = playerHeadlightIntensityValue;
            }

            document.getElementById('timeOfDayDisplay').textContent = `${String(currentHour).padStart(2, '0')}:${String(currentMinute).padStart(2, '0')}`;
            document.getElementById('timeOfDayInfo').innerHTML = `${timeOfDayEmoji} ${timeOfDayText}: <span id="timeOfDayDisplay">${String(currentHour).padStart(2, '0')}:${String(currentMinute).padStart(2, '0')}</span>`;

            return scoreMultiplier;
        }


        function updateScoreAndLevel() {
            distance += carSpeed / 100;

            const currentScoreMultiplier = updateDayNightCycle();

            addScore(Math.floor(carSpeed / 50), currentScoreMultiplier);

            const newLevel = Math.floor(distance / 1000) + 1;
            if (newLevel > level) {
                level = newLevel;
                document.getElementById('level').textContent = level;
                baseTrafficSpeed += 0.02;
                maxSpeed += 10;
                showScoreFeedback(`SEVƒ∞YE ${level}!`, '#FFA500');
            }

            document.getElementById('distance').textContent = Math.floor(distance);
            document.getElementById('scoreDisplay').textContent = score;
            document.getElementById('comboDisplay').textContent = combo;

            // Yeni hƒ±z g√∂stergesi
            if (newSpeedValueElement) {
                const speedValue = Math.floor(carSpeed);
                newSpeedValueElement.textContent = speedValue;

                let color = '#4CAF50'; // Ye≈üil (d√º≈ü√ºk hƒ±z)
                if (speedValue > 180) {
                    color = '#FF4500'; // Kƒ±rmƒ±zƒ± (y√ºksek hƒ±z)
                } else if (speedValue > 100) {
                    color = '#FFD700'; // Sarƒ± (orta hƒ±z)
                }
                newSpeedValueElement.style.color = color;
            }

            /* Kokpit hƒ±z g√∂stergesi g√ºncellemesi ve renk kodlamasƒ± */
            if (currentSpeedGauge) { 
                const speedValue = Math.floor(carSpeed);
                currentSpeedGauge.textContent = speedValue; 
                let color = '#00FF00'; 

                if (speedValue >= 0 && speedValue <= 90) {
                    color = '#00FF00'; 
                } else if (speedValue > 90 && speedValue <= 150) {
                    color = '#FFA500'; 
                } else { 
                    color = '#FF0000'; 
                }
                currentSpeedGauge.style.color = color; 
                
                if (gaugeRing) { 
                     gaugeRing.style.borderColor = color;
                }
            }

            if (combo > 0 && Date.now() - lastComboTime > 3000) combo = 0;
            if (combo > highCombo) highCombo = combo;

            trafficCars.forEach(trafficCar => {
                if (!trafficCar.userData.isPolice && trafficCar.visible) {
                    const distanceToTrafficCarZ = Math.abs(car.position.z - trafficCar.position.z);
                    const distanceToTrafficCarX = Math.abs(car.position.x - trafficCar.position.x);
                    const carHalfWidth = 1.3; 
                    const trafficCarHalfWidth = (trafficCar.userData.type === 'truck' || trafficCar.userData.type === 'bus' ? 1.4 : 1.0); 

                    if (distanceToTrafficCarZ < (5.0/2 + trafficCar.userData.length/2) && 
                        distanceToTrafficCarX < (carHalfWidth + trafficCarHalfWidth + 0.3) && 
                        distanceToTrafficCarX > (carHalfWidth + trafficCarHalfWidth - 0.5) && 
                        Math.sign(carSpeed) === Math.sign(baseTrafficSpeed) && carSpeed > 30) { 
                        
                        if (!trafficCar.userData.nearMissAwarded) { 
                            showCombo('YAKIN GE√áƒ∞≈û!', 100);
                            trafficCar.userData.nearMissAwarded = true; 
                            setTimeout(() => { 
                                if(trafficCar.userData) trafficCar.userData.nearMissAwarded = false;
                            }, 2000); 
                        }
                    }
                }
            });

        }

        function addScore(points, multiplier = 1.0) {
            const comboMultiplier = 1 + (combo * 0.1);
            const totalPoints = Math.floor(points * comboMultiplier * multiplier);
            score += totalPoints;

            if (totalPoints > 50) {
                showScoreFeedback(`+${totalPoints}`, '#00FF00');
            }

            if (points > 20 && totalPoints > 0) { 
                combo++;
                lastComboTime = Date.now();
                if (combo % 5 === 0 && combo > 0) { 
                    showCombo(`${combo}X KOMBO!`, 100 + (combo * 10));
                }
            }
        }

        function showCombo(text, bonus) {
            const comboText = document.getElementById('comboText');
            comboText.textContent = `üí• ${text} üí•`;
            comboText.style.display = 'block';
            comboText.style.animation = 'none';
            void comboText.offsetWidth;
            comboText.style.animation = 'comboAnim 1.5s cubic-bezier(0.25, 0.46, 0.45, 0.94) forwards';

            if (bonus) addScore(bonus, 1.0);
        }

        function showScoreFeedback(text, color) {
            const feedback = document.getElementById('scoreFeedback');
            let emoji = '';
            if (text.includes('+')) emoji = '‚úÖ'; 
            else if (text.includes('SEVƒ∞YE')) emoji = 'üåü'; 
            else if (text.includes('POLƒ∞S')) emoji = 'üö®';
            else if (text.includes('RADAR')) emoji = 'üì°';
            else if (text.includes('ROKET')) emoji = 'üöÄ';

            feedback.textContent = `${emoji} ${text}`;
            feedback.style.color = color;
            feedback.style.textShadow = `0 0 5px ${color}80, 0 0 10px ${color}50`;
            feedback.style.animation = 'none';
            void feedback.offsetWidth;
            feedback.style.animation = 'scoreFeedbackAnim 1.0s ease-out forwards';
        }

        function checkRadar() {
            const radarDetectionRange = 10;
            const speedingThreshold = 120;

            radarPoles.forEach(radar => {
                if (!radar) return; 
                const distanceToRadar = car.position.z - radar.position.z;
                const radarX = radar.position.x;
                const carX = car.position.x;
                const currentSpeedKmH = Math.floor(carSpeed);

                if (distanceToRadar > -radarDetectionRange && distanceToRadar < radarDetectionRange &&
                    Math.abs(carX - radarX) < (roadsideWidth / 2 + 1) && 
                    currentSpeedKmH > speedingThreshold &&
                    (Date.now() - (radar.userData.lastHit || 0) > radar.userData.hitCooldown)) { 

                    const deductionAmount = Math.floor(score * 0.33); 
                    score = Math.max(0, score - deductionAmount);
                    document.getElementById('scoreDisplay').textContent = score;
                    showScoreFeedback(`RADAR CEZASI! -${deductionAmount}`, '#FF6347'); 
                    showSpeedingMessage(); 
                    
                    radar.userData.lastHit = Date.now();
                }
            });
        }


        function showSpeedingMessage() {
            const messageDiv = document.createElement('div');
            messageDiv.textContent = 'üö® RADARA YAKALANDIN! üö®';
            messageDiv.style.cssText = `
                position: absolute;
                top: 25%;
                left: 50%;
                transform: translate(-50%, -50%);
                background: rgba(255, 0, 0, 0.8);
                color: white;
                padding: 20px 30px;
                border-radius: 10px;
                font-size: 32px;
                font-weight: bold;
                text-shadow: 2px 2px 5px rgba(0,0,0,0.7);
                z-index: 250;
                animation: fadeOut 2s forwards;
            `;
            document.body.appendChild(messageDiv);
            setTimeout(() => { messageDiv.remove(); }, 2000);
        }

        function createSkyDome() {
            const skyGeometry = new THREE.SphereGeometry(700, 32, 15); 
            const skyMaterial = new THREE.MeshBasicMaterial({
                color: 0x87CEEB, 
                side: THREE.BackSide,
                fog: false 
            });
            skyDome = new THREE.Mesh(skyGeometry, skyMaterial);
            scene.add(skyDome);
        }

        function createMountains() {
            const mountainMaterial = new THREE.MeshStandardMaterial({
                color: 0x6B8E23, 
                roughness: 0.9,
                metalness: 0.0
            });
            const peakMaterial = new THREE.MeshStandardMaterial({
                color: 0xA9A9A9, 
                roughness: 0.7,
                metalness: 0.1
            });

            const numMountains = 10; 
            const mountainBaseZ = -700; 
            const mountainSpacing = 200; 

            for (let i = 0; i < numMountains; i++) {
                const mountainGroup = new THREE.Group();
                const baseHeight = Math.random() * 50 + 70; 
                const baseWidth = Math.random() * 80 + 120; 

                const mountainGeometry = new THREE.ConeGeometry(baseWidth / 2, baseHeight, Math.floor(Math.random()*3)+5); 
                const mountainBody = new THREE.Mesh(mountainGeometry, mountainMaterial);
                mountainBody.position.y = baseHeight / 2 - 10; 
                mountainBody.castShadow = true;
                mountainGroup.add(mountainBody);

                const numPeaks = Math.floor(Math.random() * 2) + 1; 
                for (let j = 0; j < numPeaks; j++) {
                    if (Math.random() < 0.7) { 
                        const peakHeight = Math.random() * 20 + 20;
                        const peakWidth = Math.random() * 20 + 15;
                        const peakGeometry = new THREE.ConeGeometry(peakWidth / 2, peakHeight, 5);
                        const peak = new THREE.Mesh(peakGeometry, peakMaterial);
                        peak.position.set(
                            (Math.random() - 0.5) * (baseWidth * 0.3),
                            baseHeight + (peakHeight / 2) - 15, 
                            (Math.random() - 0.5) * (baseWidth * 0.15)
                        );
                        mountainBody.add(peak);
                    }
                }

                const xPos = (i % 2 === 0 ? -1 : 1) * (roadWidth / 2 + roadsideWidth + 80 + Math.random() * 100); 
                const zPos = camera.position.z + mountainBaseZ - (i * mountainSpacing) - (Math.random() * mountainSpacing / 2);

                mountainGroup.position.set(xPos, 0, zPos);
                addTreesToMountain(mountainGroup, baseWidth, baseHeight);
                scene.add(mountainGroup);
                mountains.push(mountainGroup);
            }
        }

        function addTreesToMountain(mountainGroup, mountainWidth, mountainHeight) {
            const numTrees = 15;
            const treeMaterial = new THREE.MeshLambertMaterial({ color: 0x006400 }); // Basit agac rengi
            for(let i=0; i<numTrees; i++) {
                const treeHeight = Math.random() * 8 + 5;
                const treeRadius = treeHeight / 4;
                const treeGeometry = new THREE.ConeGeometry(treeRadius, treeHeight, 5);
                const tree = new THREE.Mesh(treeGeometry, treeMaterial);

                const angle = Math.random() * Math.PI * 2;
                const radius = (Math.random() * 0.4 + 0.1) * mountainWidth; // dagin %10 ila %50 yaricapina
                const x = Math.cos(angle) * radius;
                const z = Math.sin(angle) * radius;
                
                // Yuksekligi dagin egrimine gore ayarla (basit bir yaklasim)
                const y = (1 - (radius / (mountainWidth*0.5))) * (mountainHeight * 0.4);

                tree.position.set(x, y, z);
                tree.rotation.y = Math.random() * Math.PI;
                mountainGroup.add(tree);
            }
        }

        function updateMountains() {
            const mountainRemovalDistance = camera.position.z + 100; 
            const mountainSpawnBehindDistance = mountains.length * 200; 

            mountains.forEach(mountain => {
                if (!mountain) return; 
                mountain.position.z += roadSpeed + (carSpeed / 100); 

                if (mountain.position.z > mountainRemovalDistance) {
                    mountain.position.z -= mountainSpawnBehindDistance + Math.random() * 50;
                    mountain.position.x = (Math.random() < 0.5 ? -1 : 1) * (roadWidth / 2 + roadsideWidth + 80 + Math.random() * 100);
                }
            });
        }

        function createCelestialBodies() {
            // Gunes
            const sunGeometry = new THREE.SphereGeometry(25, 32, 32); // Boyut buyutuldu
            const sunMaterial = new THREE.MeshBasicMaterial({ 
                color: 0xFFD700, 
                transparent: true, 
                opacity: 0, 
                fog: false // Sisten etkilenmesin
            });
            sun = new THREE.Mesh(sunGeometry, sunMaterial);
            sun.position.set(0, 100, -500); // Kameraya gore konum

            // Gunes Isigi
            sunLight = new THREE.PointLight(0xFFD700, 0, 1000, 2);
            sun.add(sunLight);

            camera.add(sun); // Gunesi kameraya ekle

            // Ay
            const moonTextureLoader = new THREE.TextureLoader();
            const moonTexture = moonTextureLoader.load('https://threejs.org/examples/textures/planets/moon_1024.jpg');
            const moonGeometry = new THREE.SphereGeometry(15, 32, 32); 
            const moonMaterial = new THREE.MeshBasicMaterial({ 
                map: moonTexture, 
                transparent: true, 
                opacity: 0,
                fog: false
            });
            moon = new THREE.Mesh(moonGeometry, moonMaterial);
            moon.position.set(0, 80, -400); 
            camera.add(moon);

            // Yƒ±ldƒ±zlar
            const starGeometry = new THREE.BufferGeometry();
            const starPositions = [];
            for (let i = 0; i < 5000; i++) {
                const x = (Math.random() - 0.5) * 2000;
                const y = Math.random() * 500 + 50;
                const z = (Math.random() - 0.5) * 2000;
                starPositions.push(x, y, z);
            }
            starGeometry.setAttribute('position', new THREE.Float32BufferAttribute(starPositions, 3));
            const starMaterial = new THREE.PointsMaterial({
                color: 0xFFFFFF,
                size: 1.5,
                transparent: true,
                opacity: 0,
                fog: false
            });
            starField = new THREE.Points(starGeometry, starMaterial);
            scene.add(starField);
        }

        function updateCelestialBodies() {
            const time = Date.now() * 0.00005;
            if (sun) {
                sun.position.x = Math.cos(time) * 600;
                sun.position.y = Math.sin(time) * 250 + 50;
            }
            if (moon) {
                moon.position.x = Math.cos(time + Math.PI) * 500;
                moon.position.y = Math.sin(time + Math.PI) * 200 + 40;
            }
        }


        function update() {
            if (gameRunning) {
                updateCarPosition();
                updateTraffic();
                updatePoliceAttack(); // YENI POLIS ATAK FONKSƒ∞YONU
                updateRoad();
                updateRoadsideElements();
                checkCollisions();
                updateScoreAndLevel();
                checkRadar();
                updatePowerUps();
                updateRocket();
                // Eski updatePoliceWarnings() cagrisi kaldirildi.

                if (engineGainNode && audioContext && engineBuffer) {
                    const minSpeed = 0; const maxSpeedForSound = maxSpeed;
                    const minPitch = 0.5; const maxPitch = 2.5;
                    const minVol = 0.2; const maxVol = 1.0;

                    const pitch = minPitch + (carSpeed / maxSpeedForSound) * (maxPitch - minPitch);
                    const volume = minVol + (carSpeed / maxSpeedForSound) * (maxVol - minVol);

                    engineGainNode.gain.setTargetAtTime(volume, audioContext.currentTime, 0.01);
                    engineSource.playbackRate.setTargetAtTime(pitch, audioContext.currentTime, 0.01);
                }

                if (spoilerTaillights.length > 0) {
                    spoilerTaillights.forEach(light => {
                        if (light && light.material) {
                            light.material.emissiveIntensity = 5.0; 
                        }
                    });
                }
                
                // Kamera sarsƒ±ntƒ±sƒ±nƒ± uygula
                if (collisionShakeDuration > 0) {
                    const shakeX = (Math.random() - 0.5) * collisionShakeMagnitude;
                    const shakeY = (Math.random() - 0.5) * collisionShakeMagnitude;
                    camera.position.x += shakeX;
                    camera.position.y += shakeY;
                    collisionShakeDuration--;
                } else {
                    collisionShakeMagnitude = 0;
                }

                // Hƒ±z efektinden kaynaklanan kamera sarsƒ±ntƒ±sƒ±
                if (carSpeed > SPEED_EFFECT_THRESHOLD) {
                    cameraShakeIntensity = (carSpeed - SPEED_EFFECT_THRESHOLD) * 0.0002;
                    cameraShakeIntensity = Math.min(cameraShakeIntensity, maxCameraShakeIntensity);

                    const shakeX = (Math.random() - 0.5) * cameraShakeIntensity;
                    const shakeY = (Math.random() - 0.5) * cameraShakeIntensity;
                    camera.position.x += shakeX;
                    camera.position.y += shakeY;
                }
            }
            
            updateMountains();
            updateCelestialBodies();

            renderer.render(scene, camera);
            animationFrameId = requestAnimationFrame(update);
        }

        function triggerCollisionShake(magnitude, duration) {
            collisionShakeMagnitude = magnitude;
            collisionShakeDuration = duration;
        }


        // Ses Y√ºkleme ve √áalma Fonksiyonlarƒ±
        function initAudioAndLoadGame() {
            if (audioContext) {
                console.log("AudioContext zaten ba≈ülatƒ±lmƒ±≈ü.");
                // Eƒüer sesler zaten y√ºkleniyorsa tekrar ba≈ülatma
                if (loadingManager.itemStart) {
                     console.log("Y√ºkleme zaten devam ediyor.");
                     return;
                }
            } else {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
            }

            if (audioContext.state === 'suspended') {
                audioContext.resume().then(() => {
                    console.log('AudioContext kullanƒ±cƒ± etkile≈üimiyle devam ettirildi.');
                    loadSounds();
                });
            } else {
                loadSounds();
            }
        }

        function loadSounds() {
            const audioLoader = new THREE.AudioLoader(loadingManager); // LoadingManager'ƒ± kullan
            const soundSources = [
                { name: 'engine', url: 'https://cdn.glitch.global/c5286940-2720-4823-8c14-522588352b66/lambo-engine-loop.mp3?v=1672346904123', target: 'engineBuffer' },
                { name: 'brake', url: 'https://cdn.glitch.global/c5286940-2720-4823-8c14-522588352b66/tire-skid.mp3?v=1672346907292', target: 'brakeBuffer' },
                { name: 'siren', url: 'https://cdn.glitch.global/c5286940-2720-4823-8c14-522588352b66/police-siren-loop.mp3?v=1672346905586', target: 'policeSirenBuffer' },
                { name: 'intro', url: 'https://cdn.glitch.global/c5286940-2720-4823-8c14-522588352b66/dark-ambient-intro.mp3?v=1672346901819', target: 'introBuffer' },
                { name: 'rocket', url: 'https://cdn.glitch.global/c5286940-2720-4823-8c14-522588352b66/rocket-launch.mp3?v=1672346906497', target: 'powerUpRocketSoundBuffer' },
                { name: 'explosion', url: 'https://cdn.glitch.global/c5286940-2720-4823-8c14-522588352b66/explosion.mp3?v=1672346902781', target: 'explosionSoundBuffer' },
                { name: 'crash', url: 'https://cdn.glitch.global/c5286940-2720-4823-8c14-522588352b66/car-crash.mp3?v=1672346901046', target: 'crashSoundBuffer' },
                { name: 'health', url: 'https://cdn.glitch.global/c5286940-2720-4823-8c14-522588352b66/powerup-health.mp3?v=1672346905973', target: 'powerUpHealthSoundBuffer' },
                { name: 'shield', url: 'https://cdn.glitch.global/c5286940-2720-4823-8c14-522588352b66/powerup-shield.mp3?v=1672346906232', target: 'powerUpShieldSoundBuffer' },
                { name: 'menuSelect', url: 'https://cdn.glitch.global/c5286940-2720-4823-8c14-522588352b66/menu-select.mp3?v=1672346904646', target: 'menuSelectSoundBuffer' },
                { name: 'menuConfirm', url: 'https://cdn.glitch.global/c5286940-2720-4823-8c14-522588352b66/menu-confirm.mp3?v=1672346903847', target: 'menuConfirmSoundBuffer' },
            ];

            soundSources.forEach(sound => {
                audioLoader.load(sound.url, (buffer) => {
                    window[sound.target] = buffer;
                    console.log(`${sound.name} sesi y√ºklendi.`);
                });
            });

            // Y√ºkleme tamamlandƒ±ƒüƒ±nda ilk giri≈ü ekranƒ±nƒ± g√∂ster
            loadingManager.onLoad = () => {
                console.log('T√ºm varlƒ±klar ve sesler y√ºklendi!');
                if (introBuffer) {
                    introSource = audioContext.createBufferSource();
                    introSource.buffer = introBuffer;
                    introSource.loop = true;
                    introGainNode = audioContext.createGain();
                    introGainNode.gain.value = 0.9;
                    introSource.connect(introGainNode).connect(audioContext.destination);
                    introSource.start(0);
                    introSource.playState = 'playing'; // √ñzel durum
                    console.log("Intro sesi ba≈ülatƒ±ldƒ±.");
                } else {
                    console.error("Intro sesi buffer'ƒ± y√ºklenemedi.");
                }

                // Y√ºkleme ekranƒ±nƒ± gizle ve ilk giri≈ü ekranƒ±nƒ± g√∂ster
                showFirstEntryScreen();
            };
        }

        function playSound(buffer, volume = 1.0, loop = false) {
            if (!audioContext || !buffer) return null;
            
            const source = audioContext.createBufferSource();
            const gainNode = audioContext.createGain();

            source.buffer = buffer;
            source.loop = loop;
            gainNode.gain.setValueAtTime(volume, audioContext.currentTime);
            source.connect(gainNode).connect(audioContext.destination);
            source.start(0);
            
            // Kolay eri≈üim i√ßin gainNode'u kaynaƒüa ekle
            source.gainNode = gainNode;
            
            // √ñzel stop fonksiyonu
            source.stop = function() {
                if (this.playState === 'playing' || this.loop) {
                    gainNode.gain.setTargetAtTime(0, audioContext.currentTime, 0.05);
                    setTimeout(() => {
                        try {
                            source.disconnect();
                        } catch (e) { /* no-op */ }
                    }, 100);
                }
            };
            
            source.playState = 'playing';
            return source;
        }

        function startEngineSound() {
            if (engineBuffer && !engineSource) {
                engineSource = audioContext.createBufferSource();
                engineSource.buffer = engineBuffer;
                engineSource.loop = true;

                engineGainNode = audioContext.createGain();
                engineGainNode.gain.value = 0.0;
                engineSource.connect(engineGainNode).connect(audioContext.destination);

                engineSource.start(0);
                engineSource.playState = 'playing'; // √ñzel durum
                console.log("Motor sesi ba≈ülatƒ±ldƒ±.");
            }
        }
        
        // YENƒ∞ POLƒ∞S ATAK MANTIƒûI FONKSƒ∞YONU
        function startPoliceAttackSequence() {
            // Sadece aktif polis yokken yeni bir saldƒ±rƒ± ba≈ülat
            if (!activePoliceCar) {
                console.log("Polis saldƒ±rƒ± sekansƒ± ba≈ülatƒ±lƒ±yor.");
                spawnPoliceCar();
            }
        }

        function updatePoliceAttack() {
            if (!activePoliceCar || !activePoliceCar.visible) {
                activePoliceCar = null; // Aktif polis yoksa null olarak ayarla
                return;
            }

            const policeCar = activePoliceCar;
            const chaseDuration = (Date.now() - policeCar.userData.policeStartTime) / 1000;
            let targetX, targetZ;

            // Oyuncunun hemen arkasƒ±nda kalma
            targetZ = car.position.z + 15;
            targetX = car.position.x; // Doƒürudan oyuncunun ≈üeridini hedefle

            // Polis arabasƒ±nƒ±n hƒ±zƒ±nƒ± oyuncuya g√∂re ayarla
            let policeSpeed = carSpeed * 1.05; // Oyuncudan biraz daha hƒ±zlƒ±
            if (chaseDuration < 5) { // ƒ∞lk 5 saniye
                policeSpeed *= 0.8; // Daha yava≈ü yakla≈üsƒ±n
            } else {
                // Oyuncuyla aradaki mesafeye g√∂re hƒ±zƒ± ayarla
                const distanceToPlayer = Math.abs(policeCar.position.z - car.position.z);
                if (distanceToPlayer > 30) {
                    policeSpeed *= 1.1; // Uzaktaysa daha da hƒ±zlan
                }
            }
            policeCar.position.z += (policeSpeed / 100) + roadSpeed;

            // Yanlara doƒüru hareket (daha agresif)
            policeCar.position.x += (targetX - policeCar.position.x) * 0.08;

            // Polis sireninin sesini mesafeye g√∂re ayarla
            if (policeCar.userData.sirenSource && policeCar.userData.sirenSource.gainNode) {
                const distanceToSiren = car.position.distanceTo(policeCar.position);
                const volume = THREE.MathUtils.mapLinear(distanceToSiren, 0, 100, 8.0, 0.5);
                policeCar.userData.sirenSource.gainNode.gain.setTargetAtTime(Math.max(0, volume), audioContext.currentTime, 0.1);
            }

            // Polis ƒ±≈üƒ±klarƒ±nƒ± yakƒ±p s√∂nd√ºr
            if (policeCar.userData.policeLightGroup) {
                const lightGroup = policeCar.userData.policeLightGroup;
                lightGroup.userData.lightState = (lightGroup.userData.lightState + 1) % 20; // hƒ±zƒ± d√º≈ü√ºrd√ºm
                if (lightGroup.userData.lightState < 10) {
                    lightGroup.userData.redLightBulb.material.emissiveIntensity = 5.0;
                    lightGroup.userData.blueLightBulb.material.emissiveIntensity = 0;
                } else {
                    lightGroup.userData.redLightBulb.material.emissiveIntensity = 0;
                    lightGroup.userData.blueLightBulb.material.emissiveIntensity = 5.0;
                }
            }

            // Polis arabasƒ± √ßok geride kalƒ±rsa veya oyuncu √∂l√ºrse kaldƒ±r
            if (policeCar.position.z > camera.position.z + 60 || !gameRunning) {
                releasePooledPoliceCar(policeCar);
                activePoliceCar = null;
            }
        }
        
        // Sƒ∞REN UYARI YILDIZLARINI G√úNCELLEME
        function updateSirenStars() {
            if (!sirenStarElements || sirenStarElements.length === 0) {
                sirenStarElements = Array.from(document.querySelectorAll('.siren-star'));
            }
            sirenStarElements.forEach((star, index) => {
                if (index < sirenWarningCount) {
                    star.classList.add('filled');
                } else {
                    star.classList.remove('filled');
                }
            });
        }


        // Y√ºksek Skorlarƒ± Kaydetme ve G√∂sterme
        async function saveHighScore(score, name) {
            try {
                // √ñnce mevcut skorlarƒ± al
                let highScores = await getHighScores();

                // Yeni skoru ekle
                highScores.push({ name: name, score: score });

                // Skorlarƒ± b√ºy√ºkten k√º√ß√ºƒüe sƒ±rala
                highScores.sort((a, b) => b.score - a.score);

                // Sadece en iyi 10 skoru tut
                highScores = highScores.slice(0, 10);

                // JSONBlob'a g√ºncellenmi≈ü skorlarƒ± yaz
                const response = await fetch(HIGH_SCORES_URL, {
                    method: 'PUT',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(highScores)
                });

                if (!response.ok) {
                    console.error('Y√ºksek skorlar kaydedilemedi. Sunucu hatasƒ±:', response.statusText);
                } else {
                    console.log('Y√ºksek skor ba≈üarƒ±yla kaydedildi.');
                }

            } catch (error) {
                console.error('Y√ºksek skorlar kaydedilirken bir hata olu≈ütu:', error);
            }
        }

        async function getHighScores() {
            try {
                const response = await fetch(HIGH_SCORES_URL);
                if (!response.ok) {
                    if (response.status === 404) {
                        // Eƒüer dosya bulunamazsa, bo≈ü bir diziyle ba≈ülat
                        console.log('Skor tablosu bulunamadƒ±, yeni bir tane olu≈üturuluyor.');
                        return [];
                    }
                    console.error('Y√ºksek skorlar alƒ±namadƒ±. Sunucu hatasƒ±:', response.statusText);
                    return [];
                }
                const data = await response.json();
                return Array.isArray(data) ? data : []; // Gelen verinin dizi olduƒüundan emin ol
            } catch (error) {
                console.error('Y√ºksek skorlar alƒ±nƒ±rken bir hata olu≈ütu:', error);
                return [];
            }
        }

        async function displayHighScores() {
            const highScoreList = document.getElementById('highScoreList');
            if (!highScoreList) return;

            highScoreList.innerHTML = '<li>Y√ºkleniyor...</li>';

            const highScores = await getHighScores();

            highScoreList.innerHTML = ''; // Listeyi temizle

            if (highScores.length === 0) {
                highScoreList.innerHTML = '<li>Hen√ºz rekor yok.</li>';
                return;
            }

            highScores.forEach((scoreEntry, index) => {
                const li = document.createElement('li');
                li.innerHTML = `<span>${index + 1}.</span> <span>${scoreEntry.name}</span> <span>${scoreEntry.score}</span>`;
                highScoreList.appendChild(li);
            });
        }
        
        // G√º√ßlendirme Fonksiyonlarƒ±
        function createPowerUp(x, z) {
            const powerUpTypes = ['rocket', 'health', 'shield'];
            const type = powerUpTypes[Math.floor(Math.random() * powerUpTypes.length)];
            
            let geometry, material;
            
            switch(type) {
                case 'rocket':
                    geometry = new THREE.CylinderGeometry(0.3, 0.3, 1.2, 12);
                    material = new THREE.MeshPhongMaterial({ color: 0xFFD700, emissive: 0xDAA520, shininess: 80 });
                    break;
                case 'health':
                    geometry = new THREE.BoxGeometry(0.8, 0.8, 0.8);
                    material = new THREE.MeshPhongMaterial({ color: 0x00FF7F, emissive: 0x00FA9A, shininess: 60 });
                    break;
                case 'shield':
                    geometry = new THREE.OctahedronGeometry(0.7, 0);
                    material = new THREE.MeshPhongMaterial({ color: 0x00BFFF, emissive: 0x1E90FF, shininess: 100 });
                    break;
            }

            const powerUp = new THREE.Mesh(geometry, material);
            powerUp.position.set(x, 1.5, z);
            powerUp.castShadow = true;
            
            powerUp.userData = {
                type: type,
                initialY: 1.5,
                rotationSpeed: Math.random() * 0.05 + 0.02,
                bobbingSpeed: Math.random() * 2 + 1
            };

            return powerUp;
        }

        function activateShield() {
            if (shieldActive) {
                clearTimeout(shieldTimeout);
            }
            shieldActive = true;
            shieldMesh.visible = true;
            lastCollisionTime = Date.now() + 10000; // Kalkan aktifken 10 saniye dokunulmazlƒ±k

            shieldTimeout = setTimeout(() => {
                shieldActive = false;
                shieldMesh.visible = false;
                lastCollisionTime = Date.now(); // Kalkan bittiƒüinde dokunulmazlƒ±ƒüƒ± sƒ±fƒ±rla
            }, 10000); // 10 saniye
        }

        function createFlameTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 128;
            canvas.height = 128;
            const context = canvas.getContext('2d');
            const gradient = context.createRadialGradient(
                canvas.width / 2, canvas.height / 2, 0,
                canvas.width / 2, canvas.height / 2, canvas.width / 2
            );
            gradient.addColorStop(0, 'rgba(255, 200, 0, 1)');
            gradient.addColorStop(0.2, 'rgba(255, 100, 0, 1)');
            gradient.addColorStop(1, 'rgba(255, 0, 0, 0)');
            context.fillStyle = gradient;
            context.fillRect(0, 0, canvas.width, canvas.height);
            return new THREE.CanvasTexture(canvas);
        }
        // Oyunu ba≈ülat
        initKuatamaScreen();
    </script>
</body>
</html>