<!DOCTYPE html>
<html lang="tr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Enhanced 3D Traffic Racer</title>
    <script src="//cdn.jsdelivr.net/npm/eruda"></script>
    <script>eruda.init();</script>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: linear-gradient(to bottom, #1e3c72, #2a5298);
            font-family: 'Arial', sans-serif;
            overflow: hidden;
            user-select: none;
        }

        canvas {
            display: block;
            cursor: crosshair;
        }

        .ui {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            font-size: 16px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
            z-index: 100;
            background: rgba(0,0,0,0.3);
            padding: 10px;
            border-radius: 8px;
            backdrop-filter: blur(5px);
        }

        .top-info {
            position: absolute;
            top: 10px;
            right: 10px;
            display: flex;
            flex-direction: column;
            align-items: flex-end;
            gap: 8px;
            z-index: 100;
        }

        .info-box {
            background: rgba(0,0,0,0.4);
            color: white;
            padding: 8px 15px;
            border-radius: 8px;
            font-size: 20px;
            font-weight: bold;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
            backdrop-filter: blur(5px);
            min-width: 120px;
            text-align: right;
        }

        /* NEW: Health Bar Styles */
        .health-bar-container {
            position: absolute;
            top: 50%; /* Center vertically */
            right: 50px; /* Position on the far right, adjust as needed */
            transform: translateY(-50%); /* Adjust for perfect vertical centering */
            width: 30px; /* Width of the bar */
            height: 150px; /* Height of the bar */
            background: rgba(255,255,255,0.2);
            border-radius: 5px;
            overflow: hidden;
            border: 2px solid rgba(255,255,255,0.3);
            z-index: 100;
            display: flex;
            align-items: flex-end; /* Fill from bottom */
        }

        .health-label {
            position: absolute;
            top: -25px; /* Above the bar */
            right: 0;
            width: 100%;
            text-align: center;
            color: white;
            font-size: 16px;
            font-weight: bold;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.8);
            z-index: 101;
        }

        .health-fill {
            height: 100%; /* Başlangıçta tam dolu olsun */
            background: hsl(120, 100%, 40%); /* Başlangıç rengi yeşil */
            transition: height 0.3s ease-out, background-color 0.3s ease-out; /* Hem yükseklik hem renk geçişi ekle */
            width: 100%; /* Genişliği de tam olsun */
        }

        .game-over {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: linear-gradient(135deg, rgba(0,0,0,0.9), rgba(20,20,20,0.9));
            color: white;
            padding: 30px;
            border-radius: 15px;
            text-align: center;
            display: none;
            z-index: 200;
            border: 2px solid rgba(255,255,255,0.2);
            backdrop-filter: blur(10px);
            box-shadow: 0 20px 40px rgba(0,0,0,0.5);
            max-width: 90%;
        }

        button {
            background: linear-gradient(45deg, #4CAF50, #45a049);
            color: white;
            border: none;
            padding: 12px 25px;
            font-size: 16px;
            border-radius: 8px;
            cursor: pointer;
            margin-top: 15px;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(76, 175, 80, 0.3);
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(76, 175, 80, 0.4);
        }

        .instructions {
            position: absolute;
            bottom: 10px;
            left: 10px;
            color: white;
            font-size: 12px;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.8);
            background: rgba(0,0,0,0.3);
            padding: 8px;
            border-radius: 6px;
            backdrop-filter: blur(5px);
        }

        .combo {
            position: absolute;
            top: 3%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #FFFF00;
            font-size: 38px;
            font-weight: bolder;
            text-shadow:
                0 0 8px rgba(255,255,0,0.7),
                0 0 15px rgba(255,165,0,0.7),
                0 0 20px rgba(255,0,0,0.7),
                3px 3px 5px rgba(0,0,0,0.9);
            z-index: 150;
            display: none;
            animation: comboAnim 1.5s cubic-bezier(0.25, 0.46, 0.45, 0.94) forwards;
            letter-spacing: 1px;
            -webkit-text-stroke: 1px black;
        }

        @keyframes comboAnim {
            0% { opacity: 0; transform: translate(-50%, -50%) scale(0.5); letter-spacing: -3px; }
            30% { opacity: 1; transform: translate(-50%, -50%) scale(1.1); letter-spacing: 3px; }
            70% { opacity: 1; transform: translate(-50%, -50%) scale(1.0); letter-spacing: 1px; }
            100% { opacity: 0; transform: translate(-50%, -50%) scale(0.9); }
        }

        .score-feedback {
            position: absolute;
            top: 8%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #00FF00;
            font-size: 28px;
            font-weight: bold;
            text-shadow: 0 0 4px rgba(0,255,0,0.8), 0 0 8px rgba(0,255,0,0.5);
            z-index: 160;
            opacity: 0;
            animation: scoreFeedbackAnim 1.0s ease-out forwards;
            pointer-events: none;
        }

        @keyframes scoreFeedbackAnim {
            0% { opacity: 0; transform: translate(-50%, -30%) scale(0.7); }
            20% { opacity: 1; transform: translate(-50%, -50%) scale(1.0); }
            80% { opacity: 1; transform: translate(-50%, -70%) scale(0.9); }
            100% { opacity: 0; transform: translate(-50%, -80%) scale(0.8); }
        }

        .start-screen {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: linear-gradient(135deg, rgba(0,0,0,0.8), rgba(20,20,20,0.8));
            color: white;
            padding: 30px;
            border-radius: 15px;
            text-align: center;
            z-index: 200;
            border: 2px solid rgba(255,255,255,0.2);
            backdrop-filter: blur(10px);
            max-width: 90%;
        }

        .start-screen h1 {
            font-size: 36px;
            margin-bottom: 15px;
            background: linear-gradient(45deg, #ff6b6b, #4ecdc4);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .speed-controls {
            position: absolute;
            bottom: 50px; /* Hız göstergesinin üstünde kalması için ayarlandı */
            left: 10px; /* Konumu güncellendi */
            display: flex;
            flex-direction: column;
            gap: 10px;
            z-index: 100;
            display: none;
        }

        .speed-btn {
            width: 80px;
            height: 50px;
            background: rgba(255,255,255,0.2);
            border: 2px solid rgba(255,255,255,0.3);
            border-radius: 8px;
            color: white;
            font-size: 18px;
            font-weight: bold;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            user-select: none;
            backdrop-filter: blur(5px);
            transition: all 0.2s ease;
        }

        .speed-btn:active {
            background: rgba(255,255,255,0.4);
            transform: scale(0.95);
        }

        .speed-btn.accelerate { background: rgba(0,200,0,0.3); }
        .speed-btn.brake { background: rgba(200,0,0,0.3); }
        .speed-btn.accelerate:active { background: rgba(0,200,0,0.5); }
        .speed-btn.brake:active { background: rgba(200,0,0,0.5); }

        .mobile-controls {
            position: absolute;
            bottom: 50px; /* Hız göstergesinin üstünde kalması için ayarlandı */
            right: 10px; /* Konumu güncellendi */
            display: flex;
            gap: 10px;
            z-index: 100;
            display: none;
        }

        .control-btn {
            width: 60px;
            height: 60px;
            background: rgba(255,255,255,0.2);
            border: 2px solid rgba(255,255,255,0.3);
            border-radius: 50%;
            color: white;
            font-size: 24px;
            font-weight: bold;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            user-select: none;
            backdrop-filter: blur(5px);
            transition: all 0.2s ease;
        }

        .control-btn:active {
            background: rgba(255,255,255,0.4);
            transform: scale(0.95);
        }

        .rocket-btn {
            width: 60px;
            height: 60px;
            background: rgba(255, 165, 0, 0.5); /* Orange for rocket */
            border: 2px solid rgba(255, 165, 0, 0.7);
            border-radius: 50%;
            color: white;
            font-size: 24px;
            font-weight: bold;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            user-select: none;
            backdrop-filter: blur(5px);
            transition: all 0.2s ease;
            position: absolute; /* Position relative to speed-controls */
            bottom: 120px; /* Diğer kontrollerle uyumlu olması için ayarlandı */
            left: 10px; /* Align with speed controls */
            display: none; /* Controlled by JS */
        }

        .rocket-btn:active {
            background: rgba(255, 165, 0, 0.7);
            transform: scale(0.95);
        }

        /* NEW CSS for Name Input and Leaderboard Screens */
        .name-input-screen, .leaderboard-screen {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: linear-gradient(135deg, rgba(0,0,0,0.9), rgba(20,20,20,0.9));
            color: white;
            padding: 30px;
            border-radius: 15px;
            text-align: center;
            z-index: 200;
            border: 2px solid rgba(255,255,255,0.2);
            backdrop-filter: blur(10px);
            box-shadow: 0 20px 40px rgba(0,0,0,0.5);
            max-width: 90%;
            display: none; /* Varsayılan olarak gizli */
        }

        .name-input-screen input[type="text"] {
            padding: 10px;
            margin: 15px 0;
            border-radius: 5px;
            border: 1px solid #ccc;
            width: 80%;
            max-width: 250px;
            background-color: rgba(255,255,255,0.1);
            color: white;
            font-size: 16px;
            text-align: center;
        }

        .name-input-screen input[type="text"]::placeholder {
            color: #aaa;
        }

        .leaderboard-screen ol {
            list-style: none;
            padding: 0;
            margin: 20px 0;
            font-size: 18px;
        }

        .leaderboard-screen li {
            padding: 8px 0;
            border-bottom: 1px solid rgba(255,255,255,0.1);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .leaderboard-screen li:last-child {
            border-bottom: none;
        }

        .leaderboard-screen li .rank {
            font-weight: bold;
            color: #FFD700; /* Gold */
            margin-right: 10px;
        }

        .leaderboard-screen li .name {
            flex-grow: 1;
            text-align: left;
        }

        .leaderboard-screen li .score {
            font-weight: bold;
            color: #00FF00; /* Green */
            margin-left: 10px;
        }

        .leaderboard-screen button {
            margin: 10px 5px;
            background: linear-gradient(45deg, #007BFF, #0056b3); /* Mavi tonları */
            box-shadow: 0 4px 15px rgba(0, 123, 255, 0.3);
        }

        .leaderboard-screen button:hover {
            box-shadow: 0 6px 20px rgba(0, 123, 255, 0.4);
        }

        .leaderboard-screen button:last-of-type { /* Clear Leaderboard button */
            background: linear-gradient(45deg, #dc3545, #b02a37); /* Kırmızı tonları */
            box-shadow: 0 4px 15px rgba(220, 53, 69, 0.3);
        }

        .leaderboard-screen button:last-of-type:hover {
            box-shadow: 0 6px 20px rgba(220, 53, 69, 0.4);
        }

        /* Adjusted position for time-of-day-info to be in the top-left UI */
        .time-of-day-info {
            color: white;
            font-size: 16px; /* Smaller to fit in UI box */
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
            margin-top: 5px; /* Spacing within the UI box */
            display: block; /* Ensure it takes its own line within the flex container (if applicable) */
        }

        /* NEW: Radar Message Style */
        @keyframes fadeOut {
            0% { opacity: 1; transform: translate(-50%, -50%) scale(1); }
            100% { opacity: 0; transform: translate(-50%, -100%) scale(0.8); }
        }

        /* Speed Display (Güncellendi) */
        .speed-display {
            position: absolute;
            bottom: 5px; /* Ekranın en altına daha yakın */
            left: 50%;
            transform: translateX(-50%);
            color: white;
            font-size: 16px; /* Daha küçük font */
            font-weight: bold;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.8); /* Daha küçük gölge */
            z-index: 100;
            background: none; /* Arka plan kaldırıldı */
            padding: 5px 10px; /* Daha küçük dolgu */
            border-radius: 5px; /* Köşe yuvarlama */
            backdrop-filter: none; /* Blur kaldırıldı */
            min-width: unset; /* Minimum genişlik kaldırıldı */
            text-align: center;
            display: block; /* Sadece metin olacağı için block yeterli */
        }

        /* Hız barı ile ilgili eski CSS'leri kaldırın */
        .speed-bar-container, .speed-bar-fill {
            display: none; /* Artık kullanılmıyor, gizle */
        }


        @media (max-width: 768px) {
            .ui {
                font-size: 14px;
                padding: 8px;
            }

            .instructions {
                display: none; /* Mobil cihazlarda tamamen gizle */
            }

            .start-screen h1 {
                font-size: 28px;
            }
            /* Mobil cihazlarda JS ile display: flex olarak ayarlanacak */
            /* .mobile-controls, .speed-controls { display: flex; } */

            .info-box {
                font-size: 16px;
                padding: 6px 10px;
            }

            .combo {
                font-size: 28px;
                top: 8%;
            }
            .score-feedback {
                font-size: 22px;
                top: 13%;
            }

            .name-input-screen h2, .leaderboard-screen h2 {
                font-size: 24px;
            }
            .name-input-screen input[type="text"] {
                font-size: 14px;
                padding: 8px;
            }
            .leaderboard-screen ol {
                font-size: 16px;
            }
            .leaderboard-screen li {
                padding: 6px 0;
            }
            .time-of-day-info {
                font-size: 14px;
                padding: 0; /* Remove padding as it's part of the .ui now */
                margin-top: 5px; /* Adjust margin for mobile in UI */
                background: none; /* Remove background as it's part of the .ui now */
                backdrop-filter: none; /* Remove blur as it's part of the .ui now */
                position: static; /* Remove absolute positioning */
                transform: none; /* Remove transform */
            }

            .health-bar-container {
                top: 50%; /* Center vertically */
                right: 20px; /* Adjust to be next to speed, on the right side */
                transform: translateY(-50%);
                height: 100px;
                width: 20px;
            }

            .health-label {
                top: -20px;
                font-size: 14px;
            }

            /* Mobil cihazlar için hız göstergesi ve kontrol butonları */
            .speed-display {
                font-size: 14px; /* Mobil için daha da küçük */
                padding: 3px 8px;
            }
            .speed-controls {
                bottom: 40px; /* Mobil için daha da aşağı çekildi */
                left: 10px;
            }
            .mobile-controls {
                bottom: 40px; /* Mobil için daha da aşağı çekildi */
                right: 10px;
            }
            .rocket-btn {
                bottom: 100px; /* Mobil için güncellendi */
                left: 10px;
            }
            
            /* Başlangıç ekranı metin boyutları */
            .company-logo-text {
                font-size: 32px;
            }
            .producer-name, .gemini-partnership {
                font-size: 14px;
            }
        }

        /* Başlangıç Ekranı Yeni Stilleri */
        .company-logo-text {
            font-family: 'Arial Black', sans-serif;
            font-size: 48px;
            font-weight: bold;
            color: #FF8C00; /* Koyu turuncu */
            text-shadow: 3px 3px 6px rgba(0,0,0,0.7), 0 0 15px rgba(255,140,0,0.5);
            margin-bottom: 20px; /* TRAFİK YARIŞI başlığından uzaklaşsın */
            -webkit-text-stroke: 2px #A0522D; /* Daha koyu turuncu-kahverengi kenarlık */
            position: absolute; /* Konumlandırma için */
            top: 5%; /* Yukarıdan boşluk */
            left: 50%;
            transform: translateX(-50%);
            width: 100%;
            text-align: center;
        }

        .producer-name, .gemini-partnership {
            color: #696969; /* Koyu gri */
            font-size: 16px;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.6);
            position: absolute; /* Konumlandırma için */
            left: 50%;
            transform: translateX(-50%);
            width: 100%;
            text-align: center;
        }

        .producer-name {
            bottom: 50px; /* En alttan yukarıda */
        }

        .gemini-partnership {
            bottom: 25px; /* Üretici isminin altında */
        }
    </style>
</head>
<body>
    <div class="start-screen" id="startScreen">
        <div class="company-logo-text">KuTaMa Games</div>
        <h1>TRAFİK YARIŞI</h1>
        <button onclick="initAudioAndStartGame()">BAŞLA</button>
        <button onclick="showNameInput()">İSİM DEĞİŞTİR</button>
        <button onclick="showLeaderboard()">REKORLAR</button>
        <div class="producer-name">By Atakan Cerrahoğlu</div>
        <div class="gemini-partnership">Bu oyun Gemini ortaklığında geliştirilmiştir.</div>
    </div>

    <div class="name-input-screen" id="nameInputScreen">
        <h2>Adınızı Girin</h2>
        <input type="text" id="playerNameInput" placeholder="Adınız" maxlength="10">
        <button onclick="submitPlayerName()">Tamam</button>
    </div>

    <div class="leaderboard-screen" id="leaderboardScreen">
        <h2>🏆 Rekorlar Listesi 🏆</h2>
        <ol id="leaderboardList"></ol>
        <button onclick="restartGame()">Yeniden Başla</button>
        <button onclick="clearLeaderboard()">Rekorları Temizle</button>
    </div>

    <div class="ui">
        <div>📍 Mesafe: <span id="distance">0</span>m</div>
        <div>⭐ Seviye: <span id="level">1</span></div>
        <div>🚀 Roketler: <span id="rocketsDisplay">0</span></div>
        <div class="time-of-day-info" id="timeOfDayInfo">
            ☀️ Gündüz: <span id="timeOfDayDisplay">00:00</span>
        </div>
    </div>

    <div class="top-info">
        <div class="info-box">💰 Skor: <span id="scoreDisplay">0</span></div>
        <div class="info-box">🔥 Kombo: <span id="comboDisplay">0</span></div>
    </div>

    <div class="health-bar-container">
        <div class="health-label">Can</div>
        <div class="health-fill" id="healthFill"></div>
    </div>

    <div class="combo" id="comboText">SÜPER!</div>

    <div id="scoreFeedback" class="score-feedback"></div>

    <div class="instructions">
        WASD / Ok Tuşları - Hareket<br>
        <strong>W/Yukarı Ok - Hızlan | S/Aşağı Ok - Yavaşla | A/Sol Ok - Sola | D/Sağ Ok - Sağa</strong><br>
        <strong>SPACE / Roket Butonu - Roket Ateşle</strong><br>
        <strong>🎯 Araçlara yakın geçerek bonus puan kazanın!</strong>
    </div>

    <div class="speed-controls" id="speedControls">
        <div class="speed-btn accelerate" id="accelerateBtn">Hızlan</div>
        <div class="speed-btn brake" id="brakeBtn">Yavaşla</div>
    </div>

    <div class="rocket-btn" id="rocketBtn">💥</div>
    <div class="mobile-controls" id="mobileControls">
        <div class="control-btn" id="leftBtn">←</div>
        <div class="control-btn" id="rightBtn">→</div>
    </div>

    <div class="speed-display" id="speedDisplay">
        Hız: <span id="currentSpeed">0</span> km/s
    </div>


    <div class="game-over" id="gameOver">
        <h2>💥 KAZA!</h2>
        <p>Toplam Skor: <span id="finalScore">0</span></p>
        <p>Mesafe: <span id="finalDistance">0</span>m</p>
        <p>En Yüksek Kombo: <span id="maxCombo">0</span></p>
    </div>

    <canvas id="gameCanvas"></canvas>

    <audio id="engineSound" loop preload="auto">
        <source src="https://drive.google.com/uc?export=download&id=1Y2FvWn5ZvNiwHi-dxQFDPvhHrkbX5bIL" type="audio/mpeg">
        <source src="https://drive.google.com/uc?export=download&id=1HSoyW7KPDwVlgeukevfkgQUMXvLiyBeK" type="audio/ogg">
        Tarayıcınız ses etiketini desteklemiyor.
    </audio>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Oyun değişkenleri
        let scene, camera, renderer, car, road = [], trafficCars = [], barriers = [];
        let roadsideElements = [];
        let gameRunning = false;
        let score = 0, distance = 0, level = 1;
        let carSpeed = 0, maxSpeed = 250;
        let roadSpeed = 0.5;
        let baseTrafficSpeed = 0.3;
        let keys = {};
        let gameStarted = false;
        let combo = 0;
        let highCombo = 0;
        let lastComboTime = 0;
        let mobileControls = { left: false, right: false, accelerate: false, brake: false };
        let animationFrameId;
        let carTilt = 0;
        const maxCarTilt = Math.PI / 12;

        // YENİ: Motor Sesi Değişkeni
        let engineSound;

        // Oyuncu Can değişkenleri
        let health = 100;
        const maxHealth = 100;
        const sideCollisionDamageMultiplier = 0.08;
        const directCollisionZThreshold = 2.0;

        // Oyuncu araba farı (SpotLight)
        let playerHeadlight;

        // Çarpışma algılama kutuları
        const carBox = new THREE.Box3();
        const trafficBox = new THREE.Box3();
        const powerUpBox = new THREE.Box3();

        // Yol için şeritleri tanımlama
        const roadWidth = 20;
        const lanes = [-7, 0, 7];
        const laneWidth = 7;
        const roadsideWidth = 15;

        // Parçacık Sistemi değişkenleri (roket egzozu için)
        let rocketParticles = [];

        // Roket değişkenleri
        let rockets = 0;
        let activeRocket = null;
        const rocketBaseSpeed = 1.5;
        const rocketCooldown = 1000;
        let lastRocketFireTime = 0;
        let trafficCarsDestroyedByRocket = 0; // YENİ: Roketle vurulan trafik aracı sayısı

        // Roket Güçlendirme değişkenleri
        let rocketPowerUps = [];
        const rocketPowerUpSpawnInterval = 10000;
        let lastRocketPowerUpSpawnTime = 0;

        // Gökyüzü ve Dağlar değişkenleri
        let skyDome;
        let mountains = [];

        // Polis Arabası Değişkenleri
        let activePoliceCar = null;
        const policeChaseDistance = 5; 

        // Polis Soğuma Süresi
        const policeSpawnCooldownTime = 30000; 
        let lastPoliceCarDespawnTime = 0;
        let policeDifficultyMultiplier = 1.0;

        // YENİ: Polis hasar takip değişkenleri
        let policeDamageStartTime = 0; // Polisten hasar almaya başlandığı zaman
        const policeTotalDamageLimit = 10; // Bir polis kovalamacasında alınabilecek maksimum can hasarı
        const policeDamageInterval = 1000; // Kademeli hasar her 1 saniyede bir
        let lastPoliceIncrementalDamageTime = 0; // Son kademeli hasarın verildiği zaman
        let currentPoliceChaseDamage = 0; // Mevcut polis kovalamacasında alınan toplam hasar


        // Polis Arabaları için Nesne Havuzu
        const MAX_POOLED_POLICE_CARS = 2;
        let policeCarsPool = [];
        // car.userData.lastPoliceDamageTime: Oyuncunun polisten son hasar aldığı zamanı takip etmek için kullanılacak.

        // Rekor Listesi Değişkenleri
        let playerName = "Oyuncu";
        const MAX_LEADERBOARD_ENTRIES = 5;

        // Gündüz-Gece Döngüsü değişkenleri
        let timeOfDay = 6;
        const dayDurationInGameMeters = 5000;
        let previousDistanceForTime = 0;

        // Radar değişkenleri
        let radarPoles = [];
        let lastRadarHitTime = {};
        let nextRadarSpawnDistance = 0; // Bir sonraki radarın çıkması gereken mesafe

        // Hız hissi için eklenecek değişkenler
        const SPEED_EFFECT_THRESHOLD = 200;
        let cameraShakeIntensity = 0;
        const maxCameraShakeIntensity = 0.08;
        const speedEffectScaleFactor = 0.0005;

        // Oyunu başlat
        function init() {
            scene = new THREE.Scene();
            scene.fog = new THREE.Fog(0x87CEEB, 100, 500);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 7, 10);
            camera.lookAt(0, 1, -5);

            renderer = new THREE.WebGLRenderer({
                canvas: document.getElementById('gameCanvas'),
                antialias: true
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.setClearColor(0x87CEEB);

            const ambientLight = new THREE.AmbientLight(0x404080, 0.8);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 1.2);
            directionalLight.position.set(20, 30, 10);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 1024;
            directionalLight.shadow.mapSize.height = 1024;
            directionalLight.shadow.camera.near = 0.5;
            directionalLight.shadow.camera.far = 100;
            directionalLight.shadow.camera.left = -50;
            directionalLight.shadow.camera.right = 50;
            directionalLight.shadow.camera.top = 50;
            directionalLight.shadow.camera.bottom = -50;
            scene.add(directionalLight);

            createPlayerCar();
            createPlayerHeadlight();
            createRoad();
            createRoadside();
            createBarriers();
            createInitialTrafficCars(5);
            createInitialRoadsideElements(10); // Buraya ilk radarı çağıracak şekilde düzenlendi
            createSkyDome();
            createMountains();

            // Polis Arabaları için Nesne Havuzu
            for (let i = 0; i < MAX_POOLED_POLICE_CARS; i++) {
                const { car: policeCar, length } = createTrafficCar(0x0000FF, 'sport', true); // isPolice için true geçildi
                policeCar.visible = false;
                policeCar.userData.isPooled = true;
                policeCar.userData.length = length;
                policeCar.userData.type = 'sport';
                policeCar.userData.isPolice = true; // Polis arabası olarak işaretle
                policeCar.userData.currentLane = 0;
                policeCar.userData.targetLane = 0;
                policeCar.userData.isChangingLane = false;
                policeCar.userData.wander = 0;
                policeCar.userData.wanderTarget = 0;
                policeCar.userData.lastX = 0;
                policeCar.userData.trafficCollisions = 0; // YENİ: Polis çarpışma sayacı
                scene.add(policeCar);
                policeCarsPool.push(policeCar);
            }

            window.addEventListener('resize', onWindowResize);
            document.addEventListener('keydown', onKeyDown);
            document.addEventListener('keyup', onKeyUp);

            setupMobileControls();

            render();
        }

        function isMobileDevice() {
            return (typeof window.orientation !== "undefined") || (navigator.userAgent.indexOf('Mobi') !== -1);
        }

        function setupMobileControls() {
            const leftBtn = document.getElementById('leftBtn');
            const rightBtn = document.getElementById('rightBtn');
            const accelerateBtn = document.getElementById('accelerateBtn');
            const brakeBtn = document.getElementById('brakeBtn');
            const rocketBtn = document.getElementById('rocketBtn');

            const mobileControlsDiv = document.getElementById('mobileControls');
            const speedControlsDiv = document.getElementById('speedControls');

            if (isMobileDevice()) {
                mobileControlsDiv.style.display = 'flex';
                speedControlsDiv.style.display = 'flex';
                rocketBtn.style.display = 'flex';

                leftBtn.addEventListener('touchstart', (e) => { e.preventDefault(); mobileControls.left = true; }, { passive: false });
                leftBtn.addEventListener('touchend', (e) => { e.preventDefault(); mobileControls.left = false; });

                rightBtn.addEventListener('touchstart', (e) => { e.preventDefault(); mobileControls.right = true; }, { passive: false });
                rightBtn.addEventListener('touchend', (e) => { e.preventDefault(); mobileControls.right = false; });

                accelerateBtn.addEventListener('touchstart', (e) => { e.preventDefault(); mobileControls.accelerate = true; }, { passive: false });
                accelerateBtn.addEventListener('touchend', (e) => { e.preventDefault(); mobileControls.accelerate = false; });

                brakeBtn.addEventListener('touchstart', (e) => { e.preventDefault(); mobileControls.brake = true; }, { passive: false });
                brakeBtn.addEventListener('touchend', (e) => { e.preventDefault(); mobileControls.brake = false; });

                rocketBtn.addEventListener('touchstart', (e) => { e.preventDefault(); fireRocket(); }, { passive: false });
            } else {
                mobileControlsDiv.style.display = 'none';
                speedControlsDiv.style.display = 'none';
                rocketBtn.style.display = 'none';
            }
        }

        function createPlayerCar() {
            const carGroup = new THREE.Group();

            // PBR Materyal (MeshStandardMaterial) kullanımı
            const bodyMaterial = new THREE.MeshStandardMaterial({
                color: 0xFF0000,
                roughness: 0.5, // Pürüzlülük
                metalness: 0.1, // Metaliklik
            });
            const windowMaterial = new THREE.MeshStandardMaterial({
                color: 0x88CCFF,
                transparent: true,
                opacity: 0.7,
                roughness: 0.2,
                metalness: 0.0,
            });
            const wheelMaterial = new THREE.MeshStandardMaterial({
                color: 0x1A1A1A,
                roughness: 0.8,
                metalness: 0.5,
            });
            const playerHeadlightMaterial = new THREE.MeshStandardMaterial({
                color: 0xFFFF88,
                emissive: 0xAAAA00,
                emissiveIntensity: 0.8,
                roughness: 0.1,
                metalness: 0.0,
            });
            const playerTaillightMaterial = new THREE.MeshStandardMaterial({
                color: 0xFF0000,
                emissive: 0x880000,
                emissiveIntensity: 0.8,
                roughness: 0.1,
                metalness: 0.0,
            });

            const bodyGeometry = new THREE.BoxGeometry(2, 0.8, 4.2);
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            body.position.y = 0.4;
            body.castShadow = true;
            carGroup.add(body);

            const roofShape = new THREE.Shape();
            roofShape.moveTo(-0.9, 0.4);
            roofShape.lineTo(0.9, 0.4);
            roofShape.lineTo(0.7, 0.0);
            roofShape.lineTo(-0.7, 0.0);
            roofShape.lineTo(-0.9, 0.4);

            const extrudeSettings = {
                steps: 1,
                depth: 2.2,
                bevelEnabled: true,
                bevelThickness: 0.1,
                bevelSize: 0.1,
                bevelOffset: 0,
                bevelSegments: 5
            };
            const roofGeometry = new THREE.ExtrudeGeometry(roofShape, extrudeSettings);
            const roof = new THREE.Mesh(roofGeometry, bodyMaterial);
            roof.position.set(0, 0.8, -1.1);
            roof.rotation.x = Math.PI / 2;
            roof.castShadow = true;
            carGroup.add(roof);

            const windowGeometry = new THREE.BoxGeometry(1.6, 0.6, 2.0);
            const frontWindow = new THREE.Mesh(windowGeometry, windowMaterial);
            frontWindow.position.set(0, 0.9, 0.1);
            frontWindow.scale.z = 0.5;
            frontWindow.scale.y = 0.8;
            frontWindow.position.z = 0.7;
            frontWindow.rotation.x = -Math.PI / 10;
            carGroup.add(frontWindow);

            const rearWindow = new THREE.Mesh(windowGeometry, windowMaterial);
            rearWindow.position.set(0, 0.9, -0.7);
            rearWindow.scale.z = 0.5;
            rearWindow.scale.y = 0.8;
            rearWindow.rotation.x = Math.PI / 10;
            carGroup.add(rearWindow);

            const sideWindowGeometry = new THREE.BoxGeometry(0.1, 0.5, 1.0);
            const leftWindow = new THREE.Mesh(sideWindowGeometry, windowMaterial);
            leftWindow.position.set(-0.95, 0.9, 0);
            leftWindow.scale.z = 1.8;
            carGroup.add(leftWindow);

            const rightWindow = new THREE.Mesh(sideWindowGeometry, windowMaterial);
            rightWindow.position.set(0.95, 0.9, 0);
            rightWindow.scale.z = 1.8;
            carGroup.add(rightWindow);

            const wheelGeometry = new THREE.CylinderGeometry(0.5, 0.5, 0.35, 16);
            const wheelPositions = [
                { x: -1.05, y: 0.25, z: 1.7 },
                { x: 1.05, y: 0.25, z: 1.7 },
                { x: -1.05, y: 0.25, z: -1.7 },
                { x: 1.05, y: 0.25, z: -1.7 }
            ];

            wheelPositions.forEach(pos => {
                const wheel = new THREE.Mesh(wheelGeometry, wheelMaterial);
                wheel.position.set(pos.x, pos.y, pos.z);
                wheel.rotation.z = Math.PI / 2;
                wheel.castShadow = true;
                carGroup.add(wheel);
            });

            const headlightStripGeometry = new THREE.BoxGeometry(0.3, 0.1, 0.05);
            [-0.7, 0.7].forEach(x => {
                const headlight = new THREE.Mesh(headlightStripGeometry, playerHeadlightMaterial);
                headlight.position.set(x, 0.6, 2.1);
                headlight.userData.isLight = true;
                carGroup.add(headlight);
            });

            const taillightStripGeometry = new THREE.BoxGeometry(0.3, 0.1, 0.05);
            [-0.7, 0.7].forEach(x => {
                const taillight = new THREE.Mesh(taillightStripGeometry, playerTaillightMaterial);
                taillight.position.set(x, 0.6, -2.1);
                taillight.userData.isLight = true;
                carGroup.add(taillight);
            });

            const skirtGeometry = new THREE.BoxGeometry(0.1, 0.2, 3.5);
            const skirtMaterial = new THREE.MeshStandardMaterial({
                color: 0x444444,
                roughness: 0.7,
                metalness: 0.2
            });
            const leftSkirt = new THREE.Mesh(skirtGeometry, skirtMaterial);
            leftSkirt.position.set(-1.0, 0.2, 0);
            carGroup.add(leftSkirt);

            const rightSkirt = new THREE.Mesh(skirtGeometry, skirtMaterial);
            rightSkirt.position.set(1.0, 0.2, 0);
            carGroup.add(rightSkirt);

            car = carGroup;
            scene.add(car);
            car.position.z = -5;
        }

        function createPlayerHeadlight() {
            playerHeadlight = new THREE.SpotLight(0xFFFFFF, 0, 100, Math.PI / 8, 0.5, 2);
            playerHeadlight.position.set(0, 1.5, -2);
            playerHeadlight.target = new THREE.Object3D();
            playerHeadlight.target.position.set(0, 1.5, -50);
            scene.add(playerHeadlight);
            scene.add(playerHeadlight.target);

            car.add(playerHeadlight);
            car.add(playerHeadlight.target);
            playerHeadlight.target.position.set(0, 0, -50);

            playerHeadlight.castShadow = true;
            playerHeadlight.shadow.mapSize.width = 512;
            playerHeadlight.shadow.mapSize.height = 512;
            playerHeadlight.shadow.camera.near = 0.1;
            playerHeadlight.shadow.camera.far = 100;
        }

        function createRoad() {
            const roadMaterial = new THREE.MeshStandardMaterial({
                color: 0xBBBBBB,
                roughness: 0.8,
                metalness: 0.1,
            });

            for (let i = 0; i < 30; i++) {
                const roadGeometry = new THREE.PlaneGeometry(roadWidth, 20);
                const roadSegment = new THREE.Mesh(roadGeometry, roadMaterial);
                roadSegment.rotation.x = -Math.PI / 2;
                roadSegment.position.z = i * 20 - 200;
                roadSegment.receiveShadow = true;
                scene.add(roadSegment);
                road.push(roadSegment);

                const dashedLineGeometry = new THREE.PlaneGeometry(0.4, 8);
                const lineMaterial = new THREE.MeshPhongMaterial({ color: 0xAAAAAA, emissive: 0x444444, emissiveIntensity: 1.5 });

                const laneDivider1X = -laneWidth / 2;
                const laneDivider2X = laneWidth / 2;

                [laneDivider1X, laneDivider2X].forEach(xOffset => {
                    for (let j = 0; j < 3; j++) {
                        const dashedLine = new THREE.Mesh(dashedLineGeometry, lineMaterial);
                        dashedLine.rotation.x = -Math.PI / 2;
                        dashedLine.position.set(xOffset, 0.01, (i * 20 - 200) + (j * 8 - 8));
                        dashedLine.userData.isRoadLine = true;
                        scene.add(dashedLine);
                        road.push(dashedLine);
                    }
                });
            }
        }

        function createRoadside() {
            const grassMaterial = new THREE.MeshStandardMaterial({
                color: 0x4CAF50,
                roughness: 0.9,
                metalness: 0.0
            });

            for (let i = 0; i < 30; i++) {
                const zPos = i * 20 - 200;

                const leftRoadsideGeometry = new THREE.PlaneGeometry(roadsideWidth, 20);
                const leftRoadside = new THREE.Mesh(leftRoadsideGeometry, grassMaterial);
                leftRoadside.rotation.x = -Math.PI / 2;
                leftRoadside.position.set(-(roadWidth / 2) - (roadsideWidth / 2), -0.01, zPos);
                leftRoadside.receiveShadow = true;
                scene.add(leftRoadside);
                road.push(leftRoadside);

                const rightRoadsideGeometry = new THREE.PlaneGeometry(roadsideWidth, 20);
                const rightRoadside = new THREE.Mesh(rightRoadsideGeometry, grassMaterial);
                rightRoadside.rotation.x = -Math.PI / 2;
                rightRoadside.position.set((roadWidth / 2) + (roadsideWidth / 2), -0.01, zPos);
                rightRoadside.receiveShadow = true;
                scene.add(rightRoadside);
                road.push(rightRoadside);
            }
        }

        function createBarriers() {
            const barrierHeight = 1;
            const barrierWidth = 0.5;
            const barrierMaterial = new THREE.MeshStandardMaterial({
                color: 0x555555,
                roughness: 0.7,
                metalness: 0.3
            });
            const barrierStripeMaterial = new THREE.MeshPhongMaterial({ color: 0xFF6600, emissive: 0xFF8800, emissiveIntensity: 2.0 });

            const barrierLeftX = -(roadWidth / 2) - (barrierWidth / 2);
            const barrierRightX = (roadWidth / 2) + (barrierWidth / 2);

            for (let i = 0; i < 30; i++) {
                const zPos = i * 20 - 200;

                const leftBarrier = new THREE.Mesh(new THREE.BoxGeometry(barrierWidth, barrierHeight, 20), barrierMaterial);
                leftBarrier.position.set(barrierLeftX, barrierHeight / 2, zPos);
                leftBarrier.castShadow = true;
                leftBarrier.receiveShadow = true;
                scene.add(leftBarrier);
                barriers.push(leftBarrier);

                for (let k = 0; k < 5; k++) {
                    const stripe = new THREE.Mesh(new THREE.BoxGeometry(barrierWidth + 0.01, barrierHeight + 0.01, 2), barrierStripeMaterial);
                    stripe.position.set(barrierLeftX, barrierHeight / 2, zPos - 10 + k * 4);
                    stripe.userData.isBarrierStripe = true;
                    scene.add(stripe);
                    barriers.push(stripe);
                }

                const rightBarrier = new THREE.Mesh(new THREE.BoxGeometry(barrierWidth, barrierHeight, 20), barrierMaterial);
                rightBarrier.position.set(barrierRightX, barrierHeight / 2, zPos);
                rightBarrier.castShadow = true;
                rightBarrier.receiveShadow = true;
                scene.add(rightBarrier);
                barriers.push(rightBarrier);

                for (let k = 0; k < 5; k++) {
                    const stripe = new THREE.Mesh(new THREE.BoxGeometry(barrierWidth + 0.01, barrierHeight + 0.01, 2), barrierStripeMaterial);
                    stripe.position.set(barrierRightX, barrierHeight / 2, zPos - 10 + k * 4);
                    stripe.userData.isBarrierStripe = true;
                    scene.add(stripe);
                    barriers.push(stripe);
                }
            }
        }

        function createTrafficCar(color, type = 'sedan', isPolice = false) { // isPolice parametresini ekle
            const carGroup = new THREE.Group();
            let bodyGeometry, roofGeometry, cabGeometry;
            let wheelPositions;
            let carLength;
            let bodyYPosition;

            const bodyMaterial = new THREE.MeshStandardMaterial({
                color: color,
                roughness: 0.6,
                metalness: 0.1
            });
            const windowMaterial = new THREE.MeshStandardMaterial({
                color: 0x99DDFf,
                transparent: true,
                opacity: 0.7,
                roughness: 0.3,
                metalness: 0.0
            });
            const wheelMaterial = new THREE.MeshStandardMaterial({
                color: 0x1A1A1A,
                roughness: 0.8,
                metalness: 0.6
            });
            const trafficHeadlightMaterial = new THREE.MeshStandardMaterial({
                color: 0xFFFF88,
                emissive: 0xCCCC00,
                emissiveIntensity: 1.0,
                roughness: 0.1
            });
            const trafficTaillightMaterial = new THREE.MeshStandardMaterial({
                color: 0xFF0000,
                emissive: 0xAA0000,
                emissiveIntensity: 1.0,
                roughness: 0.1
            });

            switch (type) {
                case 'sedan':
                    bodyGeometry = new THREE.BoxGeometry(1.9, 0.9, 4.0);
                    roofGeometry = new THREE.BoxGeometry(1.7, 0.7, 2.2);
                    wheelPositions = [
                        { x: -1.05, y: 0.35, z: 1.6 },
                        { x: 1.05, y: 0.35, z: 1.6 },
                        { x: -1.05, y: 0.35, z: -1.6 },
                        { x: 1.05, y: 0.35, z: -1.6 }
                    ];
                    carLength = 4.0;
                    bodyYPosition = 0.45;
                    break;
                case 'truck':
                    bodyGeometry = new THREE.BoxGeometry(2.2, 1.2, 6.5);
                    cabGeometry = new THREE.BoxGeometry(2.0, 1.5, 2.5);
                    wheelPositions = [
                        { x: -1.0, y: 0.6, z: 2.8 },
                        { x: 1.0, y: 0.6, z: 2.8 },
                        { x: -1.0, y: 0.6, z: -2.8 },
                        { x: 1.0, y: 0.6, z: -2.8 }
                    ];
                    carLength = 6.5;
                    bodyYPosition = 0.6;
                    break;
                case 'sport': // Polis arabaları bu modele dayanacak
                    bodyGeometry = new THREE.BoxGeometry(1.8, 0.6, 3.8);
                    roofGeometry = new THREE.BoxGeometry(1.6, 0.4, 1.5);
                    wheelPositions = [
                        { x: -1.1, y: 0.2, z: 1.4 },
                        { x: 1.1, y: 0.2, z: 1.4 },
                        { x: -1.1, y: 0.2, z: -1.4 },
                        { x: 1.1, y: 0.2, z: -1.4 }
                    ];
                    carLength = 3.8;
                    bodyYPosition = 0.3;

                    // YENİ: Polis arabasına özel modifikasyonlar
                    if (isPolice) {
                        // Polis arabası gövde rengi: SADECE SİYAH
                        bodyMaterial.color.set(0x000000);
                        
                        const policeLightGroup = new THREE.Group();

                        // Polis ışık çubuğu (siyah taban)
                        const lightBarGeometry = new THREE.BoxGeometry(1.2, 0.2, 0.3); // Daha geniş ışık çubuğu
                        const lightBarMesh = new THREE.Mesh(lightBarGeometry, new THREE.MeshStandardMaterial({color: 0x333333, roughness: 0.5, metalness: 0.8}));
                        lightBarMesh.position.y = 0.6; // Araba çatısının üstünde
                        policeLightGroup.add(lightBarMesh);

                        // Kırmızı ışık topu
                        const redLightBulb = new THREE.Mesh(new THREE.SphereGeometry(0.1, 8, 8), new THREE.MeshBasicMaterial({ color: 0xFF0000 }));
                        redLightBulb.position.set(-0.3, 0.6, 0.1); // Çubukta biraz yükseltilmiş
                        policeLightGroup.add(redLightBulb);

                        // Mavi ışık topu
                        const blueLightBulb = new THREE.Mesh(new THREE.SphereGeometry(0.1, 8, 8), new THREE.MeshBasicMaterial({ color: 0x0000FF }));
                        blueLightBulb.position.set(0.3, 0.6, 0.1); // Çubukta biraz yükseltilmiş
                        policeLightGroup.add(blueLightBulb);

                        // Kaput üzerindeki "POLİS" yazısı (basit bir düzlem olarak temsil edildi)
                        const polisTextGeometry = new THREE.PlaneGeometry(1.2, 0.4); // Yazının boyutunu ayarla
                        const polisTextMaterial = new THREE.MeshBasicMaterial({ color: 0xFFFFFF, side: THREE.DoubleSide }); // Beyaz renk, iki taraflı görünür
                        const polisTextPlane = new THREE.Mesh(polisTextGeometry, polisTextMaterial);
                        polisTextPlane.position.set(0, 0.8, 2.0); // Kaputun üzerine, biraz yükseltilmiş
                        polisTextPlane.rotation.x = Math.PI / 2; // Yatay durması için
                        carGroup.add(polisTextPlane);
                        // Not: THREE.TextGeometry kullanmak için daha fazla setup gerekir, bu basit bir görsel temsilidir.

                        // Animasyon için referansları sakla
                        policeLightGroup.userData.redLightBulb = redLightBulb;
                        policeLightGroup.userData.blueLightBulb = blueLightBulb;
                        policeLightGroup.userData.lightState = 0; // Alternatif flaş için durum

                        policeLightGroup.position.set(0, bodyYPosition + 0.5, 0); // Araba üzerinde konumlandır
                        carGroup.add(policeLightGroup);

                        carGroup.userData.policeLightGroup = policeLightGroup; // Işık grubunun referansını sakla
                    }
                    break;
                case 'minivan':
                    bodyGeometry = new THREE.BoxGeometry(2.1, 1.4, 4.5);
                    roofGeometry = new THREE.BoxGeometry(1.9, 1.1, 2.8);
                    wheelPositions = [
                        { x: -1.15, y: 0.6, z: 1.8 },
                        { x: 1.15, y: 0.6, z: 1.8 },
                        { x: -1.15, y: 0.6, z: -1.8 },
                        { x: 1.15, y: 0.6, z: -1.8 }
                    ];
                    carLength = 4.5;
                    bodyYPosition = 0.7;
                    break;
                case 'bus':
                    bodyGeometry = new THREE.BoxGeometry(2.8, 2.2, 9.0);
                    wheelPositions = [
                        { x: -1.2, y: 1.0, z: 3.5 },
                        { x: 1.2, y: 1.0, z: 3.5 },
                        { x: -1.2, y: 1.0, z: -3.5 },
                        { x: 1.2, y: 1.0, z: -3.5 }
                    ];
                    carLength = 9.0;
                    bodyYPosition = 1.1;
                    break;
                default:
                    bodyGeometry = new THREE.BoxGeometry(1.9, 0.9, 4.0);
                    roofGeometry = new THREE.BoxGeometry(1.7, 0.7, 2.2);
                    wheelPositions = [
                        { x: -1.05, y: 0.35, z: 1.6 },
                        { x: 1.05, y: 0.35, z: 1.6 },
                        { x: -1.05, y: 0.35, z: -1.6 },
                        { x: 1.05, y: 0.35, z: -1.6 }
                    ];
                    carLength = 4.0;
                    bodyYPosition = 0.45;
                    break;
            }

            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            body.position.y = bodyYPosition;
            body.castShadow = true;
            carGroup.add(body);

            if (type === 'sedan' || type === 'minivan') {
                const roof = new THREE.Mesh(roofGeometry, bodyMaterial);
                roof.position.y = bodyYPosition + (bodyGeometry.parameters.height / 2) + (roofGeometry.parameters.height / 2) - 0.2;
                roof.position.z = bodyGeometry.parameters.depth / 2 - roofGeometry.parameters.depth / 2 - (type === 'minivan' ? 0.3 : 0.5);
                roof.castShadow = true;
                carGroup.add(roof);

                const windowGeom = new THREE.BoxGeometry(roofGeometry.parameters.width * 0.9, roofGeometry.parameters.height * 0.8, roofGeometry.parameters.depth * 0.9);
                const frontWindow = new THREE.Mesh(windowGeom, windowMaterial);
                frontWindow.position.set(0, roof.position.y, roof.position.z + roofGeometry.parameters.depth / 4);
                carGroup.add(frontWindow);

                const rearWindow = new THREE.Mesh(windowGeom, windowMaterial);
                rearWindow.position.set(0, roof.position.y, roof.position.z - roofGeometry.parameters.depth / 4);
                carGroup.add(rearWindow);

            } else if (type === 'sport') {
                const sportCabGeometry = new THREE.BoxGeometry(1.6, 0.5, 2.0);
                const sportCab = new THREE.Mesh(sportCabGeometry, bodyMaterial);
                sportCab.position.y = bodyYPosition + 0.5;
                sportCab.position.z = 0;
                sportCab.castShadow = true;
                carGroup.add(sportCab);

                const spoilerGeometry = new THREE.BoxGeometry(1.5, 0.1, 0.3);
                const spoiler = new THREE.Mesh(spoilerGeometry, bodyMaterial);
                spoiler.position.set(0, bodyYPosition + 0.8, -bodyGeometry.parameters.depth / 2 - 0.1);
                spoiler.castShadow = true;
                carGroup.add(spoiler);

            } else if (type === 'truck') {
                const cab = new THREE.Mesh(cabGeometry, bodyMaterial);
                cab.position.y = bodyYPosition + (bodyGeometry.parameters.height / 2) + (cabGeometry.parameters.height / 2) - 0.6;
                cab.position.z = bodyGeometry.parameters.depth / 2 - cabGeometry.parameters.depth / 2 + 1;
                cab.castShadow = true;
                carGroup.add(cab);
            }

            const wheelGeometry = new THREE.CylinderGeometry(0.4, 0.4, 0.35, 16);
            wheelPositions.forEach(pos => {
                const wheel = new THREE.Mesh(wheelGeometry, wheelMaterial);
                wheel.position.set(pos.x, pos.y, pos.z);
                wheel.rotation.z = Math.PI / 2;
                wheel.castShadow = true;
                carGroup.add(wheel);
            });

            const generalHeadlightMaterial = trafficHeadlightMaterial;
            const generalTaillightMaterial = trafficTaillightMaterial;

            if (type === 'sedan' || type === 'sport' || type === 'minivan') {
                const headlightStripGeometry = new THREE.BoxGeometry(0.3, 0.1, 0.05);
                [-0.7, 0.7].forEach(x => {
                    const headlight = new THREE.Mesh(headlightStripGeometry, generalHeadlightMaterial);
                    headlight.position.set(x, bodyYPosition + 0.2, bodyGeometry.parameters.depth / 2 - 0.05);
                    headlight.userData.isLight = true;
                    carGroup.add(headlight);
                });

                const taillightStripGeometry = new THREE.BoxGeometry(0.3, 0.1, 0.05);
                [-0.7, 0.7].forEach(x => {
                    const taillight = new THREE.Mesh(taillightStripGeometry, generalTaillightMaterial);
                    taillight.position.set(x, bodyYPosition + 0.2, -bodyGeometry.parameters.depth / 2 + 0.05);
                    taillight.userData.isLight = true;
                    carGroup.add(taillight);
                });
            } else if (type === 'truck') {
                const headlightGeometry = new THREE.BoxGeometry(0.3, 0.2, 0.1);
                [-0.7, 0.7].forEach(x => {
                    const headlight = new THREE.Mesh(headlightGeometry, generalHeadlightMaterial);
                    headlight.position.set(x, bodyYPosition + 1.0, (bodyGeometry.parameters.depth / 2) + 0.5);
                    headlight.userData.isLight = true;
                    carGroup.add(headlight);
                });
                const taillightGeometry = new THREE.BoxGeometry(0.5, 0.2, 0.1);
                [-0.7, 0.7].forEach(x => {
                    const taillight = new THREE.Mesh(taillightGeometry, generalTaillightMaterial);
                    taillight.position.set(x, bodyYPosition + 0.2, -(bodyGeometry.parameters.depth / 2) - 0.05);
                    taillight.userData.isLight = true;
                    carGroup.add(taillight);
                });
            } else if (type === 'bus') {
                const headlightGeometry = new THREE.BoxGeometry(0.6, 0.3, 0.1);
                [-0.9, 0.9].forEach(x => {
                    const headlight = new THREE.Mesh(headlightGeometry, generalHeadlightMaterial);
                    headlight.position.set(x, bodyYPosition + 1.2, bodyGeometry.parameters.depth / 2 - 0.1);
                    headlight.userData.isLight = true;
                    carGroup.add(headlight);
                });
                 const taillightGeometry = new THREE.BoxGeometry(0.8, 0.4, 0.1);
                [-0.9, 0.9].forEach(x => {
                    const taillight = new THREE.Mesh(taillightGeometry, generalTaillightMaterial);
                    taillight.position.set(x, bodyYPosition + 0.4, -(bodyGeometry.parameters.depth / 2) + 0.05);
                    taillight.userData.isLight = true;
                    carGroup.add(taillight);
                });
            }

            return { car: carGroup, length: carLength };
        }

        function createInitialTrafficCars(count) {
            const colors = [
                0x00FF00, 0x0000FF, 0xFFFF00, 0xFF00FF, 0x00FFFF,
                0xFF8C00, 0x8A2BE2, 0x00CED1, 0xFF69B4, 0x4B0082, 0xADFF2F, 0xFFD700
            ];
            const types = ['sedan', 'truck', 'minivan', 'bus'];
            for (let i = 0; i < count; i++) {
                const color = colors[Math.floor(Math.random() * colors.length)];
                const type = types[Math.floor(Math.random() * types.length)];
                const { car, length } = createTrafficCar(color, type);

                const lane = lanes[Math.floor(Math.random() * lanes.length)];
                const zPos = -150 - (i * (Math.random() * 40 + 40));

                car.position.set(lane, 0, zPos);
                car.rotation.y = Math.PI;
                car.userData.length = length;
                car.userData.type = type;
                car.userData.isPolice = false; // Polis değil
                car.userData.currentLane = lane;
                car.userData.targetLane = lane;
                car.userData.isChangingLane = false;
                car.userData.wander = (Math.random() - 0.5) * 0.5;
                car.userData.wanderTarget = (Math.random() - 0.5) * 0.5;

                scene.add(car);
                trafficCars.push(car);
            }
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function onKeyDown(e) {
            if (e.key) { // e.key'in tanımlı olup olmadığını kontrol et
                keys[e.key.toLowerCase()] = true;
            }

            if (e.key === 'Enter' && document.getElementById('nameInputScreen').style.display === 'block') {
                submitPlayerName();
            } else if (e.key === ' ' && gameRunning) {
                fireRocket();
            }
        }

        function onKeyUp(e) {
            if (e.key) { // e.key'in tanımlı olup olmadığını kontrol et
                keys[e.key.toLowerCase()] = false;
            }
        }

        function startGame() {
            document.getElementById('startScreen').style.display = 'none';
            document.getElementById('nameInputScreen').style.display = 'none';
            document.getElementById('leaderboardScreen').style.display = 'none';

            gameRunning = true;
            gameStarted = true;
            score = 0;
            distance = 0;
            level = 1;
            combo = 0;
            highCombo = 0;
            carSpeed = 0;
            roadSpeed = 0.5;
            carTilt = 0;
            rockets = 0;
            trafficCarsDestroyedByRocket = 0; // Roketle vurulan araç sayacını sıfırla
            health = 100;
            updateHealthBar();
            document.getElementById('rocketsDisplay').textContent = rockets;
            lastPoliceCarDespawnTime = 0; // Bu, polis arabasının yeniden çıkması için gerekli soğuma süresini ayarlar.
            policeDifficultyMultiplier = 1.0;
            nextRadarSpawnDistance = 0; // Oyun başladığında radar mesafesini sıfırla

            // YENİ: Polis hasar sayaçlarını sıfırla
            policeDamageStartTime = 0;
            currentPoliceChaseDamage = 0;
            lastPoliceIncrementalDamageTime = 0;


            car.position.set(0, 0, -5);
            car.rotation.y = 0;
            car.rotation.z = 0;


            trafficCars.forEach(car => scene.remove(car));
            trafficCars = [];
            policeCarsPool.forEach(pCar => pCar.visible = false);


            createInitialTrafficCars(15);

            roadsideElements.forEach(obj => scene.remove(obj));
            roadsideElements = [];
            radarPoles.forEach(obj => scene.remove(obj));
            radarPoles = [];
            createInitialRoadsideElements(10); // Yeniden çağır


            rocketPowerUps.forEach(powerUp => scene.remove(powerUp));
            rocketPowerUps = [];
            lastRocketPowerUpSpawnTime = Date.now();

            if (activeRocket) {
                scene.remove(activeRocket);
                activeRocket = null;
            }
            rocketParticles.forEach(p => scene.remove(p));
            rocketParticles = [];


            if (activePoliceCar) {
                releasePooledPoliceCar(activePoliceCar);
                activePoliceCar = null;
            }

            if (!animationFrameId) {
                animationFrameId = requestAnimationFrame(update);
            }
        }

        // Polis Arabaları için Nesne Havuzu Fonksiyonları
        function getPooledPoliceCar() {
            let policeCar = policeCarsPool.find(car => !car.visible);
            if (policeCar) {
                policeCar.visible = true;
            } else {
                // Havuz boşsa, yeni bir tane oluştur (havuz boyutu yeterliyse bu durum sık olmamalı)
                // Polis rengi SADECE SİYAH olacağı için rastgele renk seçimi kaldırıldı
                const { car: newPoliceCar, length } = createTrafficCar(0x000000, 'sport', true); // isPolice için true geçildi, renk siyah
                newPoliceCar.userData.isPooled = true;
                newPoliceCar.userData.length = length;
                newPoliceCar.userData.type = 'sport';
                newPoliceCar.userData.isPolice = true; // Polis arabası olarak işaretle
                newPoliceCar.userData.currentLane = 0;
                newPoliceCar.userData.targetLane = 0;
                newPoliceCar.userData.isChangingLane = false;
                newPoliceCar.userData.wander = 0;
                newPoliceCar.userData.wanderTarget = 0;
                newPoliceCar.userData.lastX = 0;
                newPoliceCar.userData.trafficCollisions = 0; // YENİ: Polis çarpışma sayacı
                scene.add(newPoliceCar);
                policeCarsPool.push(newPoliceCar);
                policeCar = newPoliceCar;
            }
            policeCar.userData.policeStartTime = Date.now(); // Kovalamaca süresi için yeni özellik
            policeCar.userData.isChangingLane = false;
            policeCar.userData.wander = 0;
            policeCar.userData.wanderTarget = 0;
            policeCar.userData.lastSpeedSample = carSpeed; // Polis arabası hızını takip etmek için
            policeCar.userData.trafficCollisions = 0; // YENİ: Havuzdan alınan araç için sayacı sıfırla
            return policeCar;
        }

        function releasePooledPoliceCar(policeCar) {
            policeCar.visible = false;
            policeCar.position.set(0, 0, -1000); // Çok uzağa taşı
            if (policeCar.userData.policeLightGroup) {
                 policeCar.userData.policeLightGroup.userData.redLightBulb.material.emissiveIntensity = 0;
                 policeCar.userData.policeLightGroup.userData.blueLightBulb.material.emissiveIntensity = 0;
                 policeCar.userData.policeLightGroup.userData.lightState = 0; // Işık durumunu sıfırla
            }
        }


        function restartGame() {
            document.getElementById('leaderboardScreen').style.display = 'none';
            startGame();
        }

        function loadLeaderboard() {
            const leaderboard = JSON.parse(localStorage.getItem('trafficRacerLeaderboard')) || [];
            return leaderboard;
        }

        function saveScore(score, name, distance, maxCombo) {
            let leaderboard = loadLeaderboard();
            leaderboard.push({ name: name, score: score, distance: distance, maxCombo: maxCombo });
            leaderboard.sort((a, b) => b.score - a.score);
            leaderboard = leaderboard.slice(0, MAX_LEADERBOARD_ENTRIES);
            localStorage.setItem('trafficRacerLeaderboard', JSON.stringify(leaderboard));
        }

        function showLeaderboard() {
            const leaderboardScreen = document.getElementById('leaderboardScreen');
            const leaderboardList = document.getElementById('leaderboardList');
            leaderboardList.innerHTML = '';

            const leaderboard = loadLeaderboard();

            if (leaderboard.length === 0) {
                leaderboardList.innerHTML = '<li>Henüz rekor yok. İlk rekoru siz kırın!</li>';
            } else {
                leaderboard.forEach((entry, index) => {
                    const listItem = document.createElement('li');
                    listItem.innerHTML = `
                        <span class="rank">${index + 1}.</span>
                        <span class="name">${entry.name}</span>
                        <span class="score">${entry.score}</span>
                        <span class="details"> (${Math.floor(entry.distance)}m, ${entry.maxCombo} Kombo)</span>
                    `;
                    leaderboardList.appendChild(listItem);
                });
            }
            leaderboardScreen.style.display = 'block';
        }

        function hideLeaderboard() {
            document.getElementById('leaderboardScreen').style.display = 'none';
            document.getElementById('startScreen').style.display = 'block';
        }

        function clearLeaderboard() {
            if (confirm("Tüm rekorları temizlemek istediğinizden emin misiniz?")) {
                localStorage.removeItem('trafficRacerLeaderboard');
                showLeaderboard();
            }
        }

        function showNameInput() {
            document.getElementById('startScreen').style.display = 'none';
            document.getElementById('nameInputScreen').style.display = 'block';
            document.getElementById('playerNameInput').value = playerName === "Oyuncu" ? "" : playerName;
            document.getElementById('playerNameInput').focus();
        }

        function submitPlayerName() {
            const inputName = document.getElementById('playerNameInput').value.trim();
            if (inputName) {
                playerName = inputName;
            } else {
                playerName = "Misafir";
            }
            document.getElementById('nameInputScreen').style.display = 'none';
            startGame();
        }

        function gameOver() {
            gameRunning = false;
            cancelAnimationFrame(animationFrameId);
            animationFrameId = null;

            document.getElementById('finalScore').textContent = score;
            document.getElementById('finalDistance').textContent = Math.floor(distance);
            document.getElementById('maxCombo').textContent = highCombo;
            document.getElementById('gameOver').style.display = 'block';

            saveScore(score, playerName, Math.floor(distance), highCombo);

            // Oyuncunun canı bittiğinde aktif bir polis arabası varsa onu serbest bırak
            if (activePoliceCar) {
                releasePooledPoliceCar(activePoliceCar);
                activePoliceCar = null;
            }


            setTimeout(() => {
                document.getElementById('gameOver').style.display = 'none';
                showLeaderboard();
            }, 1000);
        }

        function createExplosion(x, y, z) {
            const particleCount = 100;
            const particles = new THREE.BufferGeometry();
            const positions = new Float32Array(particleCount * 3);
            const colors = new Float32Array(particleCount * 3);

            const color = new THREE.Color();

            for (let i = 0; i < particleCount; i++) {
                positions[i * 3] = x;
                positions[i * 3 + 1] = y;
                positions[i * 3 + 2] = z;

                color.setHSL(Math.random() * 0.2 + 0.1, 1.0, 0.5);
                colors[i * 3] = color.r;
                colors[i * 3 + 1] = color.g;
                colors[i * 3 + 2] = color.b;
            }

            particles.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            particles.setAttribute('color', new THREE.BufferAttribute(colors, 3));

            const particleMaterial = new THREE.PointsMaterial({
                size: 1.5,
                vertexColors: true,
                transparent: true,
                opacity: 0.8,
                blending: THREE.AdditiveBlending,
                sizeAttenuation: true
            });

            const particleSystem = new THREE.Points(particles, particleMaterial);
            scene.add(particleSystem);

            let frame = 0;
            const maxFrames = 60;

            const animateParticles = () => {
                if (!gameRunning) {
                    scene.remove(particleSystem);
                    return;
                }

                const positions = particles.attributes.position.array;

                for (let i = 0; i < particleCount; i++) {
                    positions[i * 3] += (Math.random() - 0.5) * 0.5;
                    positions[i * 3 + 1] += (Math.random() - 0.5) * 0.5;
                    positions[i * 3 + 2] += (Math.random() - 0.5) * 0.5;
                }

                particles.attributes.position.needsUpdate = true;

                particleMaterial.opacity = 0.8 * (1 - (frame / maxFrames));
                particleMaterial.size = 1.5 * (1 - (frame / maxFrames));

                frame++;

                if (frame < maxFrames) {
                    requestAnimationFrame(animateParticles);
                } else {
                    scene.remove(particleSystem);
                }
            };

            animateParticles();
        }

        function updateCarPosition() {
            const baseTurningSensitivity = 0.15;
            const speedAdjustedTurningSensitivity = baseTurningSensitivity * (1 + (carSpeed / maxSpeed) * 0.5);

            let targetTilt = 0;

            if (keys['arrowleft'] || keys['a'] || mobileControls.left) {
                car.position.x = Math.max(-roadWidth / 2 + 1.5, car.position.x - speedAdjustedTurningSensitivity);
                targetTilt = maxCarTilt;
            }
            if (keys['arrowright'] || keys['d'] || mobileControls.right) {
                car.position.x = Math.min(roadWidth / 2 - 1.5, car.position.x + speedAdjustedTurningSensitivity);
                targetTilt = -maxCarTilt;
            }

            const tiltResponsiveness = 0.1;
            carTilt += (targetTilt - carTilt) * tiltResponsiveness;
            car.rotation.z = carTilt;

            const cameraTiltFactor = 0.1;
            camera.rotation.z += (carTilt * cameraTiltFactor - camera.rotation.z) * 0.05;

            if (keys['arrowup'] || keys['w'] || mobileControls.accelerate) {
                carSpeed = Math.min(carSpeed + 0.8, maxSpeed);
            } else if (keys['arrowdown'] || keys['s'] || mobileControls.brake) {
                carSpeed = Math.max(carSpeed - 1.5, 0);
            } else {
                carSpeed = Math.max(carSpeed - 0.1, 0);
            }

            const roadBoundary = roadWidth / 2 - 1.5;
            car.position.x = Math.max(-roadBoundary, Math.min(roadBoundary, car.position.x));
        }

        function updateTraffic() {
            const laneChangeProbability = 0.003 * (level * 0.5 + 0.5);
            const wanderMagnitude = 0.6;
            const wanderSpeed = 0.02;
            const laneChangeSpeed = 0.03;
            const policeLaneChangeAggression = 0.005 * policeDifficultyMultiplier;

            trafficCars.forEach(trafficCar => {
                let carCurrentSpeed = (baseTrafficSpeed * (carSpeed / 100)) + (carSpeed * 0.01) + (level * 0.01);

                if (trafficCar.userData.isPolice) {
                    // Polis arabası hareketi ve kovalamaca mantığı
                    const policeOvertakeSpeed = carSpeed * (1.1 + (policeDifficultyMultiplier * 0.05));
                    const currentPoliceChaseDistance = policeChaseDistance * (1 - (policeDifficultyMultiplier * 0.05));

                    const distToPlayerZ = car.position.z - trafficCar.position.z;
                    const safeDistance = car.userData.length / 2 + trafficCar.userData.length / 2 + currentPoliceChaseDistance;

                    // Polis arabası ışık animasyonu
                    const policeLightGroup = trafficCar.userData.policeLightGroup;
                    if (policeLightGroup) {
                        policeLightGroup.rotation.y += 0.2; // Tüm ışık çubuğunu döndür
                        policeLightGroup.userData.lightState = (policeLightGroup.userData.lightState + 1) % 20; // Flaş hızını ayarla
                        if (policeLightGroup.userData.lightState < 10) {
                            policeLightGroup.userData.redLightBulb.material.emissiveIntensity = 2.0; // Daha parlak
                            policeLightGroup.userData.blueLightBulb.material.emissiveIntensity = 0.0;
                        } else {
                            policeLightGroup.userData.redLightBulb.material.emissiveIntensity = 0.0;
                            policeLightGroup.userData.blueLightBulb.material.emissiveIntensity = 2.0; // Daha parlak
                        }
                        policeLightGroup.userData.redLightBulb.material.needsUpdate = true;
                        policeLightGroup.userData.blueLightBulb.material.needsUpdate = true;
                    }

                    // YENİ DÜZELTME: Polis oyuncudan çok geride kalırsa veya çok öne geçerse ışınla
                    if (distToPlayerZ < -150 || distToPlayerZ > 50) { 
                        trafficCar.position.z = car.position.z + 10; // Oyuncunun biraz arkasına ışınla
                        // YENİ: Oyuncunun şeridine yakın bir noktaya ışınla
                        const playerLaneIndex = lanes.findIndex(lane => Math.abs(car.position.x - lane) < laneWidth / 2);
                        trafficCar.position.x = lanes[playerLaneIndex] + (Math.random() - 0.5) * laneWidth * 0.5; // Oyuncunun şeridine yakın, hafif rastgele
                        trafficCar.userData.currentLane = trafficCar.position.x;
                        trafficCar.userData.targetLane = trafficCar.position.x;
                        trafficCar.userData.isChangingLane = false;
                        showScoreFeedback('POLİS YENİDEN KONUMLANDI!', '#FFFF00');
                    }

                    // Polis arabası takibi bırakmalı mı kontrolü
                    // Oyuncu polisten belirli bir mesafeden daha uzakta ve daha hızlıysa
                    if (distToPlayerZ < -100 && carSpeed > (trafficCar.userData.lastSpeedSample || 0) + 20) { // Polis çok geride kaldı
                        showScoreFeedback('POLİS ATLATILDI! +750', '#00BFFF'); // Güncellenmiş mesaj ve bonus
                        releasePooledPoliceCar(trafficCar);
                        // trafficCars dizisinden de çıkar
                        const index = trafficCars.indexOf(trafficCar);
                        if (index > -1) {
                            trafficCars.splice(index, 1);
                        }
                        activePoliceCar = null;
                        lastPoliceCarDespawnTime = Date.now();
                        currentPoliceChaseDamage = 0; // Hasar sayacını sıfırla
                        return; // Bu araba için forEach'ten çık, çünkü kaldırıldı
                    }

                    const playerLaneIndex = lanes.findIndex(lane => Math.abs(car.position.x - lane) < laneWidth / 2);
                    const currentLaneIndex = lanes.findIndex(lane => Math.abs(trafficCar.position.x - lane) < laneWidth / 2);
                    let targetLaneX = trafficCar.userData.currentLane;

                    // YENİ DÜZENLEME: Polis şerit değiştirme ve agresif sürüş
                    // Oyuncuya yakınsa ve aynı şeritte değilse şerit değiştirmeye çalış
                    if (!trafficCar.userData.isChangingLane && Math.abs(distToPlayerZ) < 50) { // Oyuncuya 50 birim mesafedeyse
                        if (currentLaneIndex !== playerLaneIndex && Math.random() < policeLaneChangeAggression) {
                            const possibleDirections = [];
                            if (playerLaneIndex > currentLaneIndex) possibleDirections.push(1); // Sağa
                            if (playerLaneIndex < currentLaneIndex) possibleDirections.push(-1); // Sola

                            if (possibleDirections.length > 0) {
                                const direction = possibleDirections[Math.floor(Math.random() * possibleDirections.length)];
                                const newLaneTargetX = lanes[currentLaneIndex + direction];
                                // Şerit değiştirmeden önce hedef şeridin önünün açık olup olmadığını kontrol et (agresiflik için bu kontrolü hafifletebiliriz)
                                let isTargetLaneClear = true;
                                for (const otherCar of trafficCars) {
                                    if (otherCar !== trafficCar && Math.abs(otherCar.position.x - newLaneTargetX) < laneWidth / 2 && Math.abs(otherCar.position.z - trafficCar.position.z) < (trafficCar.userData.length / 2 + otherCar.userData.length / 2 + 10)) { // Biraz daha az güvenli mesafe
                                        isTargetLaneClear = false;
                                        break;
                                    }
                                }
                                if (isTargetLaneClear) {
                                    trafficCar.userData.targetLane = newLaneTargetX;
                                    trafficCar.userData.isChangingLane = true;
                                }
                            }
                        }
                    }

                    // Hız ayarlaması: Oyuncuya daha yakın ve takipçi olmalı
                    if (distToPlayerZ > -currentPoliceChaseDistance && distToPlayerZ < currentPoliceChaseDistance) {
                        // Oyuncuya yakınsa, hızını oyuncuya uyum sağlayacak şekilde ayarla
                        carCurrentSpeed = carSpeed * (1 + (policeDifficultyMultiplier * 0.01)); // Hafifçe hızlı
                    } else if (distToPlayerZ <= -currentPoliceChaseDistance) {
                        // Oyuncudan geride kaldıysa, hızlan
                        carCurrentSpeed = policeOvertakeSpeed * 1.5; // Çok daha hızlı yetişsin
                    } else if (distToPlayerZ >= currentPoliceChaseDistance) {
                        // Oyuncuyu geçtiyse, biraz yavaşla
                        carCurrentSpeed = carSpeed * (0.8 - (policeDifficultyMultiplier * 0.01)); // Hafifçe yavaşla
                    }
                    
                    // Şerit değiştirme ve kaydırma hareketi
                    if (trafficCar.userData.isChangingLane) {
                        trafficCar.position.x += (trafficCar.userData.targetLane - trafficCar.position.x) * laneChangeSpeed * (policeDifficultyMultiplier * 1.5); // Daha hızlı şerit değiştir
                        if (Math.abs(trafficCar.position.x - trafficCar.userData.targetLane) < 0.2) {
                            trafficCar.userData.currentLane = trafficCar.userData.targetLane;
                            trafficCar.userData.isChangingLane = false;
                        }
                    } else {
                        // Hafifçe oyuncuya doğru kayma (agresif yan çarpma için)
                        const aggressiveShift = (car.position.x - trafficCar.position.x) * 0.005 * policeDifficultyMultiplier;
                        trafficCar.position.x += aggressiveShift;
                        trafficCar.userData.currentLane = trafficCar.position.x; // Anlık konumunu güncelle
                    }

                    trafficCar.rotation.z = -((trafficCar.position.x - (trafficCar.userData.lastX || trafficCar.position.x)) * 0.5);
                    trafficCar.userData.lastX = trafficCar.position.x;
                    trafficCar.userData.lastSpeedSample = carCurrentSpeed;

                } else {
                    trafficCar.position.z += carCurrentSpeed;

                    if (!trafficCar.userData.isChangingLane) {
                        if (Math.random() < wanderSpeed) {
                            trafficCar.userData.wanderTarget = (Math.random() - 0.5) * wanderMagnitude;
                        }
                        trafficCar.userData.wander += (trafficCar.userData.wanderTarget - trafficCar.userData.wander) * 0.1;
                    }

                    if (!trafficCar.userData.isChangingLane) {
                        if (Math.random() < laneChangeProbability) {
                            const currentLaneIndex = lanes.indexOf(trafficCar.userData.currentLane);
                            const possibleDirections = [];
                            if (currentLaneIndex > 0) possibleDirections.push(-1);
                            if (currentLaneIndex < lanes.length - 1) possibleDirections.push(1);

                            if (possibleDirections.length > 0) {
                                const direction = possibleDirections[Math.floor(Math.random() * possibleDirections.length)];
                                const newLaneIndex = currentLaneIndex + direction;
                                let isTargetLaneClear = true;
                                const targetLaneX = lanes[newLaneIndex];
                                for (const otherCar of trafficCars) {
                                    if (otherCar !== trafficCar &&
                                        Math.abs(otherCar.position.x - targetLaneX) < laneWidth / 2 &&
                                        Math.abs(otherCar.position.z - trafficCar.position.z) < (trafficCar.userData.length / 2 + otherCar.userData.length / 2 + 5)) {
                                        isTargetLaneClear = false;
                                        break;
                                    }
                                }
                                if (isTargetLaneClear) {
                                    trafficCar.userData.targetLane = lanes[newLaneIndex];
                                    trafficCar.userData.isChangingLane = true;
                                }
                            }
                        }
                        trafficCar.position.x = trafficCar.userData.currentLane + trafficCar.userData.wander;

                    } else {
                        let targetX = trafficCar.userData.targetLane + trafficCar.userData.wander;
                        trafficCar.position.x += (targetX - trafficCar.position.x) * laneChangeSpeed;

                        if (Math.abs(trafficCar.position.x - trafficCar.userData.targetLane) < 0.2) {
                            trafficCar.userData.currentLane = trafficCar.userData.targetLane;
                            trafficCar.userData.isChangingLane = false;
                        }
                    }
                }

                const roadBoundary = roadWidth / 2 - 1.5;
                trafficCar.position.x = Math.max(-roadBoundary, Math.min(roadBoundary, trafficCar.position.x));

                if (trafficCar.position.z > camera.position.z + 50) {
                    if (!trafficCar.userData.isPooled) {
                        scene.remove(trafficCar);
                        // trafficCars dizisinden çıkar
                        const index = trafficCars.indexOf(trafficCar);
                        if (index > -1) {
                            trafficCars.splice(index, 1);
                        }
                    } else {
                        releasePooledPoliceCar(trafficCar);
                        // trafficCars dizisinden çıkar
                        const index = trafficCars.indexOf(trafficCar);
                        if (index > -1) {
                            trafficCars.splice(index, 1);
                        }
                        activePoliceCar = null;
                    }

                    if (!trafficCar.userData.isPolice) {
                        addScore(50 + Math.floor(carSpeed / 10));
                    }

                    const distanceX = Math.abs(trafficCar.position.x - car.position.x);
                    const carHalfWidth = 1.0;
                    const trafficCarHalfWidth = trafficCar.userData.type === 'truck' || trafficCar.userData.type === 'bus' ? 1.5 : 1.0;
                    const safeDistance = carHalfWidth + trafficCarHalfWidth + 0.5;

                    if (distanceX < safeDistance && trafficCar.position.z < car.position.z && trafficCar.position.z > car.position.z - 10) {
                        showCombo('YAKIN GEÇİŞ!', 100);
                    }
                }
            });

            // Trafik arabası oluşturma mantığı
            if (trafficCars.filter(car => !car.userData.isPolice).length < (5 + level * 2)) { 
                const colors = [
                    0x00FF00, 0x0000FF, 0xFFFF00, 0xFF00FF, 0x00FFFF,
                    0xFF8C00, 0x8A2BE2, 0x00CED1, 0xFF69B4, 0x4B0082, 0xADFF2F, 0xFFD700
                ];
                const types = ['sedan', 'truck', 'minivan', 'bus'];
                const color = colors[Math.floor(Math.random() * colors.length)];
                const type = types[Math.floor(Math.random() * types.length)];
                const { car: newCar, length } = createTrafficCar(color, type);

                const lane = lanes[Math.floor(Math.random() * lanes.length)];
                let zSpawnPosition = camera.position.z - 250 - (Math.random() * 50);

                let overlap = true;
                let attempts = 0;
                const minDistanceBetweenCars = 30;

                while (overlap && attempts < 20) {
                    overlap = false;
                    for (const existingCar of trafficCars) {
                        if (Math.abs(existingCar.position.x - lane) < laneWidth / 2 &&
                            Math.abs(existingCar.position.z - zSpawnPosition) < (existingCar.userData.length / 2 + length / 2 + minDistanceBetweenCars)) {
                            overlap = true;
                            zSpawnPosition -= (existingCar.userData.length + length + minDistanceBetweenCars);
                            break;
                        }
                    }
                    attempts++;
                }
                if (overlap) {
                    zSpawnPosition = camera.position.z - 500 - (Math.random() * 200);
                }


                newCar.position.set(lane, 0, zSpawnPosition);
                newCar.rotation.y = Math.PI;
                newCar.userData.length = length;
                newCar.userData.type = type;
                newCar.userData.isPolice = false; // Polis arabası değil
                newCar.userData.currentLane = lane;
                newCar.userData.targetLane = lane;
                newCar.userData.isChangingLane = false;
                newCar.userData.wander = (Math.random() - 0.5) * 0.5;
                newCar.userData.wanderTarget = (Math.random() - 0.5) * 0.5;

                scene.add(newCar);
                trafficCars.push(newCar);
            }
        }

        function updateRoad() {
            road.forEach(segment => {
                segment.position.z += roadSpeed + (carSpeed / 100);

                if (segment.position.z > camera.position.z + 20) {
                    segment.position.z -= 600;
                }
            });

            barriers.forEach(barrier => {
                barrier.position.z += roadSpeed + (carSpeed / 100);

                if (barrier.position.z > camera.position.z + 20) {
                    barrier.position.z -= 600;
                }
            });
        }

        function createTree(x, z) {
            const treeGroup = new THREE.Group();

            const trunkGeometry = new THREE.CylinderGeometry(0.5, 0.7, 5, 8);
            const trunkMaterial = new THREE.MeshStandardMaterial({
                color: 0x8B4513,
                roughness: 0.9,
                metalness: 0.0
            });
            const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
            trunk.position.y = 2.5;
            trunk.castShadow = true;
            treeGroup.add(trunk);

            const leavesMaterial = new THREE.MeshStandardMaterial({
                color: 0x228B22,
                roughness: 0.7,
                metalness: 0.0
            });

            const topLeaves = new THREE.Mesh(new THREE.ConeGeometry(2, 4, 8), leavesMaterial);
            topLeaves.position.y = 6;
            topLeaves.castShadow = true;
            treeGroup.add(topLeaves);

            const middleLeaves = new THREE.Mesh(new THREE.ConeGeometry(2.5, 3, 8), leavesMaterial);
            middleLeaves.position.y = 4;
            middleLeaves.castShadow = true;
            treeGroup.add(middleLeaves);

            treeGroup.position.set(x, 0, z);
            return treeGroup;
        }

        function createSign(x, z) {
            const signGroup = new THREE.Group();

            const poleGeometry = new THREE.CylinderGeometry(0.2, 0.2, 4, 6);
            const poleMaterial = new THREE.MeshStandardMaterial({
                color: 0xAAAAAA,
                roughness: 0.6,
                metalness: 0.4
            });
            const pole = new THREE.Mesh(poleGeometry, poleMaterial);
            pole.position.y = 2;
            pole.castShadow = true;
            signGroup.add(pole);

            const boardGeometry = new THREE.BoxGeometry(3, 1.5, 0.1);
            const boardMaterial = new THREE.MeshStandardMaterial({
                color: 0xFFFFFF,
                roughness: 0.7,
                metalness: 0.0
            });
            const board = new THREE.Mesh(boardGeometry, boardMaterial);
            board.position.set(0, 3.5, 0);
            board.castShadow = true;
            signGroup.add(board);

            signGroup.position.set(x, 0, z);
            return signGroup;
        }

        // Yeni: Geyik Objesi Oluşturma Fonksiyonu (Basit Grafiklerle)
        function createDeer(x, z) {
            const deerGroup = new THREE.Group();

            const bodyMaterial = new THREE.MeshStandardMaterial({ color: 0x8B4513, roughness: 0.8, metalness: 0.0 });
            const antlerMaterial = new THREE.MeshStandardMaterial({ color: 0xD2B48C, roughness: 0.8, metalness: 0.0 });

            // Gövde
            const bodyGeometry = new THREE.BoxGeometry(0.8, 1.0, 1.5);
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            body.position.y = 0.5;
            body.castShadow = true;
            deerGroup.add(body);

            // Baş
            const headGeometry = new THREE.BoxGeometry(0.5, 0.5, 0.5);
            const head = new THREE.Mesh(headGeometry, bodyMaterial);
            head.position.set(0, 1.2, 0.6);
            head.castShadow = true;
            deerGroup.add(head);

            // Bacaklar (4 adet)
            const legGeometry = new THREE.BoxGeometry(0.2, 0.8, 0.2);
            const legPositions = [
                { x: -0.3, z: 0.5 },
                { x: 0.3, z: 0.5 },
                { x: -0.3, z: -0.5 },
                { x: 0.3, z: -0.5 }
            ];
            legPositions.forEach(pos => {
                const leg = new THREE.Mesh(legGeometry, bodyMaterial);
                leg.position.set(pos.x, 0.4, pos.z);
                leg.castShadow = true;
                deerGroup.add(leg);
            });

            // Boynuzlar
            const antler1Geometry = new THREE.CylinderGeometry(0.1, 0.1, 0.8, 4);
            const antler1 = new THREE.Mesh(antler1Geometry, antlerMaterial);
            antler1.position.set(-0.15, 1.6, 0.7);
            antler1.rotation.z = Math.PI / 8;
            antler1.castShadow = true;
            deerGroup.add(antler1);

            const antler2Geometry = new THREE.CylinderGeometry(0.1, 0.1, 0.8, 4);
            const antler2 = new THREE.Mesh(antler2Geometry, antlerMaterial);
            antler2.position.set(0.15, 1.6, 0.7);
            antler2.rotation.z = -Math.PI / 8;
            antler2.castShadow = true;
            deerGroup.add(antler2);

            deerGroup.position.set(x, 0, z);
            return deerGroup;
        }

        // Yeni: Radarı yalnızca bir kez oluşturan fonksiyon
        function createRadarPoleOnce(zPos) {
            const radarSide = (Math.random() < 0.5 ? -1 : 1); // Sol veya sağ
            const xPos = radarSide * (roadWidth / 2 + roadsideWidth / 2 + (Math.random() * 5)); // Yol kenarı pozisyonu

            const radarGroup = new THREE.Group();

            const poleGeometry = new THREE.CylinderGeometry(0.2, 0.2, 5, 8);
            const poleMaterial = new THREE.MeshStandardMaterial({
                color: 0x888888,
                roughness: 0.6,
                metalness: 0.4
            });
            const pole = new THREE.Mesh(poleGeometry, poleMaterial);
            pole.position.y = 2.5;
            pole.castShadow = true;
            radarGroup.add(pole);

            const boxGeometry = new THREE.BoxGeometry(1.2, 0.8, 0.8);
            const boxMaterial = new THREE.MeshStandardMaterial({
                color: 0x000000,
                roughness: 0.5,
                metalness: 0.8
            });
            const box = new THREE.Mesh(boxGeometry, boxMaterial);
            box.position.set(0, 4.5, 0);
            box.castShadow = true;
            radarGroup.add(box);

            const lightMaterial = new THREE.MeshStandardMaterial({
                color: 0xFF0000,
                emissive: 0xFF0000,
                emissiveIntensity: 2.0,
                roughness: 0.1
            });
            const light1 = new THREE.Mesh(new THREE.SphereGeometry(0.15, 8, 8), lightMaterial);
            light1.position.set(-0.3, 4.8, 0.4);
            radarGroup.add(light1);
            const light2 = new THREE.Mesh(new THREE.SphereGeometry(0.15, 8, 8), lightMaterial);
            light2.position.set(0.3, 4.8, 0.4);
            radarGroup.add(light2);

            radarGroup.position.set(xPos, 0, zPos);
            radarGroup.userData.isRadar = true;
            radarGroup.userData.hitCooldown = 5000;
            radarGroup.userData.lastHit = 0;
            radarGroup.userData.spawnDistance = distance; // Radarın hangi mesafede oluştuğunu kaydet

            scene.add(radarGroup);
            radarPoles.push(radarGroup);

            // Bir sonraki radarın çıkması gereken mesafeyi ayarla
            nextRadarSpawnDistance = distance + 5000;
        }

        // YENİ: Polis Arabasını Başlatma Fonksiyonu
        function spawnPoliceCar() {
            const newPoliceCar = getPooledPoliceCar();
            if (newPoliceCar) {
                // Oyuncunun bulunduğu şeridi bul
                const playerLaneIndex = lanes.findIndex(lane => Math.abs(car.position.x - lane) < laneWidth / 2);
                let spawnLane;
                if (playerLaneIndex !== -1) { // Oyuncu geçerli bir şeritteyse
                    spawnLane = lanes[playerLaneIndex];
                } else { // Oyuncu şeritte değilse, rastgele bir şerit seç
                    spawnLane = lanes[Math.floor(Math.random() * lanes.length)];
                }

                // DÜZELTME: Polis arabasını oyuncunun ÇOK YAKIN arkasında ve kesinlikle çarpacak şekilde başlat
                newPoliceCar.position.set(spawnLane, 0, car.position.z + 2); // Z pozisyonu oyuncuya çok yakın
                newPoliceCar.rotation.y = Math.PI;
                newPoliceCar.userData.currentLane = spawnLane;
                newPoliceCar.userData.targetLane = spawnLane;
                newPoliceCar.userData.lastX = newPoliceCar.position.x;
                newPoliceCar.userData.trafficCollisions = 0; // Polis çarpışma sayacını sıfırla
                newPoliceCar.userData.initialHitOccurred = false; // İlk çarpışma bayrağı
                
                trafficCars.push(newPoliceCar);
                activePoliceCar = newPoliceCar;
                lastPoliceCarDespawnTime = Date.now(); // Polisin yeniden doğma zamanını sıfırla
                showScoreFeedback('POLİS PEŞİNİZDE!', '#FF4500');

                // YENİ DÜZENLEME: İlk spawn'da anında bir hasar ve hız düşüşü uygula
                takeDamage(5); // İlk çarpma 5 can
                carSpeed = Math.max(0, carSpeed - 20); // Hızı biraz düşür
                showScoreFeedback('POLİS ÇARPTI!', '#FF0000');

                // YENİ: Kademeli hasar sayaçlarını başlat
                policeDamageStartTime = Date.now();
                currentPoliceChaseDamage = 5; // İlk 5 canı başlangıç hasarı olarak say
                lastPoliceIncrementalDamageTime = Date.now();
            }
        }


        function createInitialRoadsideElements(count) {
            for (let i = 0; i < count; i++) {
                const zPos = camera.position.z - 200 - (i * (Math.random() * 50 + 30));

                let roadsideElement;
                let xPos;
                const typeRoll = Math.random();

                // Sol taraf (ağaçlar, geyikler)
                if (Math.random() < 0.5) { // Sol taraf için %50 olasılık
                    xPos = -(roadWidth / 2 + roadsideWidth / 2 + (Math.random() * 5));
                    if (Math.random() < 0.8) { // %80 ağaç, %20 geyik (sol tarafta)
                        roadsideElement = createTree(xPos, zPos);
                    } else {
                        roadsideElement = createDeer(xPos, zPos); // Yeni createDeer fonksiyonu
                    }
                } else { // Sağ taraf (tabelalar, ağaçlar)
                    xPos = (roadWidth / 2 + roadsideWidth / 2 + (Math.random() * 5));
                    if (Math.random() < 0.8) { // %80 tabela, %20 ağaç (sağ tarafta)
                        roadsideElement = createSign(xPos, zPos);
                    } else {
                        roadsideElement = createTree(xPos, zPos);
                    }
                }

                roadsideElements.push(roadsideElement);
                scene.add(roadsideElement);
            }

            // İlk radarı buraya ekleyelim (örneğin -200 metreye)
            // Oyun başladığında veya yeniden başlatıldığında ilk radarı oluştur
            if (radarPoles.length === 0) {
                createRadarPoleOnce(camera.position.z - 200);
            }
        }

        function updateRoadsideElements() {
            const roadsideSpawnDistance = camera.position.z - 250;
            const roadsideRemovalDistance = camera.position.z + 50;

            let currentSpeedEffectScale = 1.0;
            if (carSpeed > SPEED_EFFECT_THRESHOLD) {
                currentSpeedEffectScale = 1.0 + (carSpeed - SPEED_EFFECT_THRESHOLD) * speedEffectScaleFactor;
            } else {
                currentSpeedEffectScale = 1.0;
            }

            for (let i = roadsideElements.length - 1; i >= 0; i--) {
                const element = roadsideElements[i];
                element.position.z += roadSpeed + (carSpeed / 100);

                element.scale.z = currentSpeedEffectScale;

                if (element.position.z > roadsideRemovalDistance) {
                    let newZPos = roadsideSpawnDistance - (Math.random() * 100);

                    let overlap = true;
                    let attempts = 0;
                    while (overlap && attempts < 10) {
                        overlap = false;
                        for (const otherElement of roadsideElements.concat(radarPoles)) { // Radarları da çakışma kontrolüne dahil et
                            if (otherElement !== element &&
                                Math.abs(otherElement.position.x - element.position.x) < 5 && // X ekseni kontrolü
                                Math.abs(otherElement.position.z - newZPos) < 20) { // Z ekseni kontrolü
                                overlap = true;
                                newZPos -= 30;
                                break;
                            }
                        }
                        attempts++;
                    }

                    let newXPos;
                    // Elementin eski konumuna göre sol mu sağ mı olduğuna karar vererek yeniden konumlandır
                    scene.remove(element); // Eskiyi kaldır
                    if (element.position.x < 0) { // Sol taraftaki eleman
                        newXPos = -(roadWidth / 2 + roadsideWidth / 2 + (Math.random() * 5));
                        if (Math.random() < 0.8) { // %80 ağaç, %20 geyik
                            roadsideElements[i] = createTree(newXPos, newZPos); // Yenisini ekle
                        } else {
                            roadsideElements[i] = createDeer(newXPos, newZPos); // Yenisini ekle
                        }
                    } else { // Sağ taraftaki eleman
                        newXPos = (roadWidth / 2 + roadsideWidth / 2 + (Math.random() * 5));
                        if (Math.random() < 0.8) { // %80 tabela, %20 ağaç
                            roadsideElements[i] = createSign(newXPos, newZPos); // Yenisini ekle
                        } else {
                            roadsideElements[i] = createTree(newXPos, newZPos); // Yenisini ekle
                        }
                    }
                    scene.add(roadsideElements[i]);
                    roadsideElements[i].scale.set(1,1,1); // Ölçeği sıfırla
                }
            }

            // Radar güncellemeleri
            for (let i = radarPoles.length - 1; i >= 0; i--) {
                const radar = radarPoles[i];
                radar.position.z += roadSpeed + (carSpeed / 100);

                radar.scale.z = currentSpeedEffectScale;

                if (radar.position.z > roadsideRemovalDistance) {
                    scene.remove(radar); // Sahneden kaldır
                    radarPoles.splice(i, 1); // Diziden kaldır
                    nextRadarSpawnDistance = distance + 5000; // Yeni radarın çıkması gereken mesafeyi ayarla
                }
            }

            // Her 5 km'de bir radar oluşturma kontrolü
            const radarSpawnInterval = 5000; // 5000 metre = 5 km
            
            // Eğer yeni bir radarın oluşması gereken mesafeye ulaşıldysa ve aktif radar yoksa yeni bir radar oluştur
            if (distance >= nextRadarSpawnDistance && radarPoles.length === 0) {
                 createRadarPoleOnce(camera.position.z - 250); // Ekranın dışında yeni bir radar oluştur
            }
        }

        function createRocketPowerUp() {
            const geometry = new THREE.BoxGeometry(1, 1, 1);
            const material = new THREE.MeshStandardMaterial({
                color: 0xFF8800,
                emissive: 0xCC5500,
                emissiveIntensity: 0.7,
                roughness: 0.5,
                metalness: 0.0
            });
            const powerUp = new THREE.Mesh(geometry, material);

            const lane = lanes[Math.floor(Math.random() * lanes.length)];
            let zSpawnPosition = camera.position.z - 200 - (Math.random() * 100);

            let overlap = true;
            let attempts = 0;
            while (overlap && attempts < 5) {
                overlap = false;
                for (const existingCar of trafficCars) {
                    if (Math.abs(existingCar.position.x - lane) < laneWidth / 2 &&
                        Math.abs(existingCar.position.z - zSpawnPosition) < (existingCar.userData.length / 2 + 5)) {
                        overlap = true;
                        zSpawnPosition -= 15;
                        break;
                    }
                }
                attempts++;
            }

            powerUp.position.set(lane, 0.5, zSpawnPosition);
            powerUp.userData.isPowerUp = true;
            scene.add(powerUp);
            rocketPowerUps.push(powerUp);
        }

        function updateRocketPowerUps() {
            if (Date.now() - lastRocketPowerUpSpawnTime > rocketPowerUpSpawnInterval && rocketPowerUps.length < 2) {
                createRocketPowerUp();
                lastRocketPowerUpSpawnTime = Date.now();
            }

            for (let i = rocketPowerUps.length - 1; i >= 0; i--) {
                const powerUp = rocketPowerUps[i];
                powerUp.position.z += roadSpeed + (carSpeed / 100);
                powerUp.rotation.y += 0.05;

                if (powerUp.position.z > camera.position.z + 20) {
                    scene.remove(powerUp);
                    rocketPowerUps.splice(i, 1);
                }
            }
        }

        function fireRocket() {
            if (rockets > 0 && activeRocket === null && gameRunning && (Date.now() - lastRocketFireTime > rocketCooldown)) {
                activeRocket = new THREE.Group();

                const rocketBodyGeometry = new THREE.CylinderGeometry(0.3, 0.4, 2.0, 8);
                const rocketBodyMaterial = new THREE.MeshStandardMaterial({
                    color: 0xFF0000,
                    emissive: 0xCC0000,
                    emissiveIntensity: 1.0,
                    roughness: 0.5
                });
                const rocketBody = new THREE.Mesh(rocketBodyGeometry, rocketBodyMaterial);
                rocketBody.position.y = 0;
                activeRocket.add(rocketBody);

                const rocketTipGeometry = new THREE.ConeGeometry(0.3, 1.0, 8);
                const rocketTipMaterial = new THREE.MeshStandardMaterial({
                    color: 0xFFFFFF,
                    emissive: 0xAAAAAA,
                    emissiveIntensity: 1.0,
                    roughness: 0.1
                });
                const rocketTip = new THREE.Mesh(rocketTipGeometry, rocketTipMaterial);
                rocketTip.position.y = 1.0 + 0.5;
                activeRocket.add(rocketTip);

                activeRocket.position.set(car.position.x, car.position.y + 0.5, car.position.z - (car.userData.length || 4.2) / 2 - 0.5);
                activeRocket.rotation.x = Math.PI / 2;
                activeRocket.userData.rotationSpeed = 0;

                activeRocket.castShadow = true;
                scene.add(activeRocket);

                rockets--;
                document.getElementById('rocketsDisplay').textContent = rockets;
                lastRocketFireTime = Date.now();

                showScoreFeedback('ROKET ATEŞLENDİ!', '#FFD700');

                // Polis tetikleme mantığı updateRocket içinde roketle vurulan araç sayısına bağlı
            }
        }

        function createRocketParticle(x, y, z) {
            const particleGeometry = new THREE.SphereGeometry(0.08 + Math.random() * 0.05, 4, 4);
            const particleMaterial = new THREE.MeshBasicMaterial({
                color: new THREE.Color(1, Math.random() * 0.5 + 0.5, 0),
                transparent: true,
                opacity: 0.8
            });
            const particle = new THREE.Mesh(particleGeometry, particleMaterial);
            particle.position.set(x, y, z);
            particle.userData.life = 25 + Math.random() * 10;
            particle.userData.velocity = new THREE.Vector3((Math.random() - 0.5) * 0.08, (Math.random() - 0.5) * 0.08, Math.random() * 0.2 + 0.05);
            scene.add(particle);
            rocketParticles.push(particle);
        }

        function updateRocket() {
            if (activeRocket) {
                activeRocket.position.z -= rocketBaseSpeed + (carSpeed * 0.02);

                if (Math.random() < 0.7) {
                    createRocketParticle(activeRocket.position.x, activeRocket.position.y + 0.2, activeRocket.position.z + 1.2);
                }

                let hitTrafficCar = null;
                for (let i = trafficCars.length - 1; i >= 0; i--) {
                    const trafficCar = trafficCars[i];
                    if (trafficCar.userData.isPooled && !trafficCar.visible) continue;
                    if (trafficCar.userData.isPolice) continue; // Polis arabasına roketle çarpılmasını istemiyoruz

                    trafficBox.setFromObject(trafficCar);
                    const rocketBox = new THREE.Box3().setFromObject(activeRocket);

                    if (rocketBox.intersectsBox(trafficBox)) {
                        hitTrafficCar = trafficCar;
                        break;
                    }
                }

                if (hitTrafficCar) {
                    scene.remove(activeRocket);
                    activeRocket = null;
                    rocketParticles.forEach(p => {
                        scene.remove(p);
                        p.geometry.dispose(); // Geometriyi serbest bırak
                        p.material.dispose(); // Materyali serbest bırak
                    });
                    rocketParticles = [];

                    scene.remove(hitTrafficCar);
                    // trafficCars dizisinden çıkar
                    const index = trafficCars.indexOf(hitTrafficCar);
                    if (index > -1) {
                        trafficCars.splice(index, 1);
                    }
                    addScore(500);
                    showCombo('ROKET İSABETİ!', 200);

                    createExplosion(hitTrafficCar.position.x, hitTrafficCar.position.y, hitTrafficCar.position.z);
                    
                    // YENİ DÜZENLEME: Roketle vurulan araç sayısını artır ve polis tetikle
                    trafficCarsDestroyedByRocket++; 
                    if (trafficCarsDestroyedByRocket % 3 === 0 && activePoliceCar === null && (Date.now() - lastPoliceCarDespawnTime >= policeSpawnCooldownTime || lastPoliceCarDespawnTime === 0)) {
                        spawnPoliceCar();
                    }

                }
                else if (activeRocket.position.z < camera.position.z - 200) {
                    scene.remove(activeRocket);
                    activeRocket = null;
                    rocketParticles.forEach(p => {
                        scene.remove(p);
                        p.geometry.dispose();
                        p.material.dispose();
                    });
                    rocketParticles = [];
                }
            }

            for (let i = rocketParticles.length - 1; i >= 0; i--) {
                const particle = rocketParticles[i];
                particle.userData.life--;
                particle.position.z += roadSpeed + (carSpeed / 100);
                particle.position.z += particle.userData.velocity.z;
                particle.position.x += particle.userData.velocity.x;
                particle.position.y += particle.userData.velocity.y;
                
                particle.material.opacity = particle.userData.life / (25 + 10);
                particle.scale.setScalar(particle.userData.life / (25 + 10));

                if (particle.userData.life <= 0) {
                    scene.remove(particle);
                    rocketParticles.splice(i, 1);
                    particle.geometry.dispose(); // Geometriyi serbest bırak
                    particle.material.dispose(); // Materyali serbest bırak
                }
            }
        }

        function takeDamage(amount) {
            health -= amount;
            health = Math.max(0, health);
            updateHealthBar();
            if (health <= 0) {
                gameOver();
            }
        }

        function updateHealthBar() {
            const healthFillElement = document.getElementById('healthFill');
            const fillHeight = (health / maxHealth) * 100;

            // Calculate hue for green to red transition
            // When health is max (100%), hue is 120 (green).
            // When health is min (0%), hue is 0 (red).
            const hue = (health / maxHealth) * 120; // Hue ranges from 0 (red) to 120 (green)

            healthFillElement.style.height = `${fillHeight}%`;
            healthFillElement.style.background = `hsl(${hue}, 100%, 40%)`; // Full saturation, medium lightness
        }

        function checkCollisions() {
            carBox.setFromObject(car);

            for (let i = trafficCars.length - 1; i >= 0; i--) {
                const trafficCar = trafficCars[i];
                if (trafficCar.userData.isPooled && !trafficCar.visible) continue;

                trafficBox.setFromObject(trafficCar);

                if (carBox.intersectsBox(trafficBox)) {
                    const intersection = new THREE.Box3();
                    intersection.copy(carBox).intersect(trafficBox);

                    const carSize = carBox.getSize(new THREE.Vector3());
                    const trafficCarSize = trafficBox.getSize(new THREE.Vector3());

                    const intersectionZDepth = intersection.max.z - intersection.min.z;
                    const carFrontZ = car.position.z - carSize.z / 2;
                    const trafficCarRearZ = trafficCar.position.z + trafficCarSize.z / 2;

                    const intersectionXWidth = intersection.max.x - intersection.min.x;
                    const minCollisionOverlapX = 0.5;

                    // Polis Arabası Çarpışma Yönetimi
                    if (trafficCar.userData.isPolice) {
                        // YENİ DÜZENLEME: Polisle temas halindeyken kademeli hasar
                        // İlk çarpma hasarı spawnPoliceCar() içinde veriliyor.
                        // Burada sadece kademeli hasarı kontrol ediyoruz.
                        if (activePoliceCar && currentPoliceChaseDamage < policeTotalDamageLimit && (Date.now() - lastPoliceIncrementalDamageTime >= policeDamageInterval)) {
                            takeDamage(1); // Her saniyede 1 can
                            currentPoliceChaseDamage++;
                            lastPoliceIncrementalDamageTime = Date.now();
                            showScoreFeedback('POLİS TEMASI!', '#FF0000');
                        }

                        // YENİ DÜZENLEME: Toplam hasar limitine ulaşıldığında polis atlatıldı
                        if (activePoliceCar && currentPoliceChaseDamage >= policeTotalDamageLimit) {
                            showScoreFeedback('POLİS ATLATILDI! +750', '#00BFFF'); 
                            releasePooledPoliceCar(trafficCar);
                            const index = trafficCars.indexOf(trafficCar);
                            if (index > -1) {
                                trafficCars.splice(index, 1);
                            }
                            activePoliceCar = null;
                            lastPoliceCarDespawnTime = Date.now(); // Soğuma süresini başlat
                            currentPoliceChaseDamage = 0; // Hasar sayacını sıfırla
                            return; // Bu araba için forEach'ten çık
                        }

                        // Temas halinde hafifçe geri veya yana itme
                        if (car.position.x < trafficCar.position.x) {
                            car.position.x -= 0.5;
                        } else {
                            car.position.x += 0.5;
                        }
                        carSpeed = Math.max(0, carSpeed - 10); // Hızı hafifçe azalt
                        return; // Polis etkileşimini işledikten sonra bu araba için diğer çarpışma kontrollerini engelle
                    }
                    else {
                        if (carFrontZ < trafficCarRearZ && intersectionZDepth > directCollisionZThreshold) {
                            gameOver();
                            return;
                        } else if (intersectionXWidth > minCollisionOverlapX) {
                            const damage = Math.floor(carSpeed * sideCollisionDamageMultiplier * (intersectionXWidth / carSize.x));
                            takeDamage(damage);
                            if (car.position.x < trafficCar.position.x) {
                                car.position.x -= 1.0;
                            } else {
                                car.position.x += 1.0;
                            }
                            carSpeed = Math.max(0, carSpeed - 30);
                        }
                    }
                }
            }

            // Polis arabası vs. diğer trafik arabası çarpışma yönetimi
            if (activePoliceCar) {
                const policeBox = new THREE.Box3().setFromObject(activePoliceCar);

                for (let i = trafficCars.length - 1; i >= 0; i--) {
                    const otherTrafficCar = trafficCars[i];
                    // Polis arabasını, havuzdaki görünmeyen arabaları ve diğer polis arabalarını kontrol dışı bırak
                    if (otherTrafficCar === activePoliceCar || (otherTrafficCar.userData.isPooled && !otherTrafficCar.visible) || otherTrafficCar.userData.isPolice) continue; 
                    
                    trafficBox.setFromObject(otherTrafficCar);

                    if (policeBox.intersectsBox(trafficBox)) {
                        scene.remove(otherTrafficCar);
                        // trafficCars dizisinden çıkar
                        const index = trafficCars.indexOf(otherTrafficCar);
                        if (index > -1) {
                            trafficCars.splice(index, 1);
                        }
                        addScore(200);
                        showScoreFeedback('POLİS ÇARPIŞTI! +200', '#FF4500');
                        createExplosion(otherTrafficCar.position.x, otherTrafficCar.position.y, otherTrafficCar.position.z);
                        
                        // YENİ: Polis çarpışma sayacını artır
                        activePoliceCar.userData.trafficCollisions++;
                        if (activePoliceCar.userData.trafficCollisions >= 3) { // 3 kez çarptıysa pes eder
                            showScoreFeedback('POLİS PES ETTİ! +1000', '#00FF00'); // Polis pes etti mesajı ve bonus
                            releasePooledPoliceCar(activePoliceCar);
                            const activePoliceIndex = trafficCars.indexOf(activePoliceCar);
                            if (activePoliceIndex > -1) {
                                trafficCars.splice(activePoliceIndex, 1);
                            }
                            activePoliceCar = null;
                            lastPoliceCarDespawnTime = Date.now(); // Soğuma süresini başlat
                            currentPoliceChaseDamage = 0; // Hasar sayacını sıfırla
                        }
                    }
                }
            }

            for (let i = rocketPowerUps.length - 1; i >= 0; i--) {
                const powerUp = rocketPowerUps[i];
                powerUpBox.setFromObject(powerUp);

                if (carBox.intersectsBox(powerUpBox)) {
                    scene.remove(powerUp);
                    rocketPowerUps.splice(i, 1);
                    rockets++;
                    document.getElementById('rocketsDisplay').textContent = rockets;
                    showScoreFeedback('+1 ROKET!', '#FFD700');
                }
            }

            for (let i = 0; i < barriers.length; i++) {
                const barrierMesh = barriers[i];
                const barrierBox = new THREE.Box3().setFromObject(barrierMesh);
                if (carBox.intersectsBox(barrierBox)) {
                    if (car.position.x < barrierMesh.position.x) {
                        car.position.x -= 0.5;
                    } else {
                        car.position.x += 0.5;
                    }
                    carSpeed = Math.max(0, carSpeed - 50);
                    takeDamage(Math.floor(carSpeed * 0.2));
                }
            }
        }

        function updateDayNightCycle() {
            const distancePassed = distance - previousDistanceForTime;
            const timeProgressionRate = 0.005;
            timeOfDay = (timeOfDay + (distancePassed / dayDurationInGameMeters) * 24) % 24;
            previousDistanceForTime = distance;

            let ambientColor, directionalColor;
            let directionalIntensity, ambientIntensity;
            let fogColor, fogNear, fogFar;
            let timeOfDayText = '';
            let timeOfDayEmoji = '';
            let scoreMultiplier = 1.0;
            let roadLineEmissiveIntensity;
            let barrierStripeEmissiveIntensity;
            let playerHeadlightIntensity = 0;
            let trafficLightEmissiveIntensity = 0;

            const currentHour = Math.floor(timeOfDay);
            const currentMinute = Math.floor((timeOfDay - currentHour) * 60);

            if (timeOfDay >= 6 && timeOfDay < 18) {
                const progress = (timeOfDay - 6) / 12;
                ambientColor = new THREE.Color().lerpColors(new THREE.Color(0x6060A0), new THREE.Color(0xAAAAFF), progress);
                directionalColor = new THREE.Color().lerpColors(new THREE.Color(0xFFCC88), new THREE.Color(0xFFFFFF), progress);
                directionalIntensity = THREE.MathUtils.lerp(0.8, 1.2, progress);
                ambientIntensity = THREE.MathUtils.lerp(0.5, 0.8, progress);
                fogColor = new THREE.Color().lerpColors(new THREE.Color(0x87CEEB), new THREE.Color(0xADD8E6), progress);
                fogNear = 100;
                fogFar = 500;
                timeOfDayText = 'Gündüz';
                timeOfDayEmoji = '☀️';
                scoreMultiplier = 1.0;
                roadLineEmissiveIntensity = 0.2;
                barrierStripeEmissiveIntensity = 0.3;
                playerHeadlightIntensity = 0;
                trafficLightEmissiveIntensity = 0;
            } else if (timeOfDay >= 18 && timeOfDay < 20) {
                const progress = (timeOfDay - 18) / 2;
                ambientColor = new THREE.Color().lerpColors(new THREE.Color(0xAAAAFF), new THREE.Color(0x303060), progress);
                directionalColor = new THREE.Color().lerpColors(new THREE.Color(0xFFFFFF), new THREE.Color(0xFF8C00), progress);
                directionalIntensity = THREE.MathUtils.lerp(1.2, 0.5, progress);
                ambientIntensity = THREE.MathUtils.lerp(0.8, 0.3, progress);
                fogColor = new THREE.Color().lerpColors(new THREE.Color(0xADD8E6), new THREE.Color(0x505080), progress);
                fogNear = 80;
                fogFar = 400;
                timeOfDayText = 'Akşam';
                timeOfDayEmoji = '🌇';
                scoreMultiplier = 1.2;
                roadLineEmissiveIntensity = THREE.MathUtils.lerp(0.2, 1.5, progress);
                barrierStripeEmissiveIntensity = THREE.MathUtils.lerp(0.3, 2.5, progress);
                playerHeadlightIntensity = THREE.MathUtils.lerp(0, 0.8, progress);
                trafficLightEmissiveIntensity = THREE.MathUtils.lerp(0, 1.5, progress);
            } else if (timeOfDay >= 20 || timeOfDay < 4) {
                const progress = (timeOfDay >= 20 ? (timeOfDay - 20) : (timeOfDay + 4)) / 8;
                ambientColor = new THREE.Color().lerpColors(new THREE.Color(0x303060), new THREE.Color(0x101030), progress);
                directionalColor = new THREE.Color().lerpColors(new THREE.Color(0xFF8C00), new THREE.Color(0x050505), progress);
                directionalIntensity = THREE.MathUtils.lerp(0.5, 0.1, progress);
                ambientIntensity = THREE.MathUtils.lerp(0.3, 0.1, progress);
                fogColor = new THREE.Color().lerpColors(new THREE.Color(0x505080), new THREE.Color(0x050510), progress);
                fogNear = 20;
                fogFar = 200;
                timeOfDayText = 'Gece';
                timeOfDayEmoji = '🌙';
                scoreMultiplier = 1.5;
                roadLineEmissiveIntensity = 1.8;
                barrierStripeEmissiveIntensity = 3.0;
                playerHeadlightIntensity = 1.0;
                trafficLightEmissiveIntensity = 1.5;
            } else {
                const progress = (timeOfDay - 4) / 2;
                ambientColor = new THREE.Color().lerpColors(new THREE.Color(0x101030), new THREE.Color(0x6060A0), progress);
                directionalColor = new THREE.Color().lerpColors(new THREE.Color(0x050505), new THREE.Color(0xFFCC88), progress);
                directionalIntensity = THREE.MathUtils.lerp(0.1, 0.8, progress);
                ambientIntensity = THREE.MathUtils.lerp(0.1, 0.5, progress);
                fogColor = new THREE.Color().lerpColors(new THREE.Color(0x050510), new THREE.Color(0x87CEEB), progress);
                fogNear = 50;
                fogFar = 300;
                timeOfDayText = 'Şafak';
                timeOfDayEmoji = '🌅';
                scoreMultiplier = 1.2;
                roadLineEmissiveIntensity = THREE.MathUtils.lerp(1.8, 0.2, progress);
                barrierStripeEmissiveIntensity = THREE.MathUtils.lerp(3.0, 0.3, progress);
                playerHeadlightIntensity = THREE.MathUtils.lerp(1.0, 0, progress);
                trafficLightEmissiveIntensity = THREE.MathUtils.lerp(1.5, 0, progress);
            }

            scene.children.forEach(obj => {
                if (obj instanceof THREE.AmbientLight) {
                    obj.color.copy(ambientColor);
                    obj.intensity = ambientIntensity;
                }
                if (obj instanceof THREE.DirectionalLight) {
                    obj.color.copy(directionalColor);
                    obj.intensity = directionalIntensity;
                    const angle = (timeOfDay / 24) * Math.PI * 2;
                    obj.position.set(Math.sin(angle) * 30, Math.cos(angle) * 30 + 10, 10);
                }
            });

            if (skyDome && skyDome.material) {
                skyDome.material.color.set(fogColor);
            }

            renderer.setClearColor(fogColor);
            scene.fog.color.set(fogColor);
            scene.fog.near = fogNear;
            scene.fog.far = fogFar;

            car.traverse((object) => {
                if (object.material && object.userData.isLight) {
                    if (object.material instanceof THREE.MeshStandardMaterial || object.material instanceof THREE.MeshPhongMaterial) {
                        if (object.material.color.equals(new THREE.Color(0xFFFF88))) {
                            object.material.emissive.set(0xAAAA00);
                            object.material.emissiveIntensity = playerHeadlightIntensity;
                        }
                        else if (object.material.color.equals(new THREE.Color(0xFF0000))) {
                            object.material.emissive.set(0x880000);
                            object.material.emissiveIntensity = playerHeadlightIntensity > 0 ? 1.0 : 0.0;
                        }
                        object.material.needsUpdate = true;
                    }
                }
            });

            trafficCars.forEach(trafficCar => {
                trafficCar.traverse((object) => {
                    if (object.material && object.userData.isLight) {
                        if (object.material instanceof THREE.MeshStandardMaterial || object.material instanceof THREE.MeshPhongMaterial) {
                            if (object.material.color.equals(new THREE.Color(0xFFFF88))) {
                                object.material.emissive.set(0xCCCC00);
                                object.material.emissiveIntensity = trafficLightEmissiveIntensity;
                            }
                            else if (object.material.color.equals(new THREE.Color(0xFF0000))) {
                                object.material.emissive.set(0xAA0000);
                                object.material.emissiveIntensity = trafficLightEmissiveIntensity;
                            }
                            object.material.needsUpdate = true;
                        }
                    }
                });
            });


            road.forEach(obj => {
                if (obj.userData.isRoadLine && obj.material instanceof THREE.MeshPhongMaterial) {
                    obj.material.emissiveIntensity = roadLineEmissiveIntensity;
                    obj.material.needsUpdate = true;
                }
            });

            barriers.forEach(obj => {
                if (obj.userData.isBarrierStripe && obj.material instanceof THREE.MeshPhongMaterial) {
                    obj.material.emissiveIntensity = barrierStripeEmissiveIntensity;
                    obj.material.needsUpdate = true;
                }
            });

            if (playerHeadlight) {
                playerHeadlight.intensity = playerHeadlightIntensity;
                playerHeadlight.target.position.copy(car.position).add(new THREE.Vector3(0, 0, -50));
            }

            document.getElementById('timeOfDayDisplay').textContent = `${String(currentHour).padStart(2, '0')}:${String(currentMinute).padStart(2, '0')}`;
            document.getElementById('timeOfDayInfo').innerHTML = `${timeOfDayEmoji} ${timeOfDayText}: <span id="timeOfDayDisplay">${String(currentHour).padStart(2, '0')}:${String(currentMinute).padStart(2, '0')}</span>`;

            return scoreMultiplier;
        }

        function updateScoreAndLevel() {
            distance += carSpeed / 100;

            const currentScoreMultiplier = updateDayNightCycle();

            addScore(Math.floor(carSpeed / 50), currentScoreMultiplier);

            const newLevel = Math.floor(distance / 1000) + 1;
            if (newLevel > level) {
                level = newLevel;
                document.getElementById('level').textContent = level;

                baseTrafficSpeed += 0.02;
                maxSpeed += 10;
                policeDifficultyMultiplier += 0.1;

                showScoreFeedback(`SEVİYE ${level}!`, '#FFA500');
            }

            document.getElementById('distance').textContent = Math.floor(distance);
            document.getElementById('scoreDisplay').textContent = score;
            document.getElementById('comboDisplay').textContent = combo;

            // Hız göstergesi güncellemesi (sadece sayı)
            document.getElementById('currentSpeed').textContent = Math.floor(carSpeed);

            if (combo > 0 && Date.now() - lastComboTime > 3000) {
                combo = 0;
            }

            if (combo > highCombo) {
                highCombo = combo;
            }
        }

        function addScore(points, multiplier = 1.0) {
            const comboMultiplier = 1 + (combo * 0.1);
            const totalPoints = Math.floor(points * comboMultiplier * multiplier);
            score += totalPoints;

            if (totalPoints > 50) {
                showScoreFeedback(`+${totalPoints}`, '#00FF00');
            }

            if (points > 20) {
                combo++;
                lastComboTime = Date.now();

                if (combo % 5 === 0) {
                    showCombo(`${combo}X KOMBO!`, 100 + (combo * 10));
                }
            }
        }

        function showCombo(text, bonus) {
            const comboText = document.getElementById('comboText');
            comboText.textContent = `💥 ${text} 💥`;
            comboText.style.display = 'block';
            comboText.style.animation = 'none';
            void comboText.offsetWidth;
            comboText.style.animation = 'comboAnim 1.5s cubic-bezier(0.25, 0.46, 0.45, 0.94) forwards';

            if (bonus) {
                addScore(bonus, 1.0);
            }

            setTimeout(() => {
                comboText.style.display = 'none';
            }, 1500);
        }

        function showScoreFeedback(text, color) {
            const feedback = document.getElementById('scoreFeedback');
            let emoji = '';
            if (text.includes('+') || text.includes('ROKET')) {
                emoji = '💰';
            } else if (text.includes('SEVİYE')) {
                emoji = '🌟';
            } else if (text.includes('POLİS')) {
                emoji = '🚨';
            }
            feedback.textContent = `${emoji} ${text}`;
            feedback.style.color = color;
            feedback.style.textShadow = `0 0 5px ${color}80, 0 0 10px ${color}50`;
            feedback.style.animation = 'none';
            void feedback.offsetWidth;
            feedback.style.animation = 'scoreFeedbackAnim 1.0s ease-out forwards';
        }

        function checkRadar() {
            const radarDetectionRange = 10;
            const speedingThreshold = 120; // Hız eşiği 120 km/s olarak ayarlandı

            radarPoles.forEach(radar => {
                const distanceToRadar = car.position.z - radar.position.z;
                const radarX = radar.position.x;
                const carX = car.position.x;
                const currentSpeedKmH = Math.floor(carSpeed);

                if (distanceToRadar > -radarDetectionRange && distanceToRadar < radarDetectionRange &&
                    Math.abs(carX - radarX) < (roadsideWidth / 2 + 1) &&
                    currentSpeedKmH > speedingThreshold &&
                    (Date.now() - radar.userData.lastHit > radar.userData.hitCooldown)) {

                    const deductionAmount = Math.floor(score / 3);
                    score = Math.max(0, score - deductionAmount);
                    document.getElementById('scoreDisplay').textContent = score;

                    showSpeedingMessage();
                    
                    radar.userData.lastHit = Date.now();
                }
            });
        }

        function showSpeedingMessage() {
            const messageDiv = document.createElement('div');
            messageDiv.textContent = '🚨 RADARA YAKALANDIN! 🚨';
            messageDiv.style.cssText = `
                position: absolute;
                top: 25%;
                left: 50%;
                transform: translate(-50%, -50%);
                background: rgba(255, 0, 0, 0.8);
                color: white;
                padding: 20px 30px;
                border-radius: 10px;
                font-size: 32px;
                font-weight: bold;
                text-shadow: 2px 2px 5px rgba(0,0,0,0.7);
                z-index: 250;
                animation: fadeOut 2s forwards;
            `;
            document.body.appendChild(messageDiv);

            setTimeout(() => {
                messageDiv.remove();
            }, 2000);
        }

        function createSkyDome() {
            const skyGeometry = new THREE.SphereGeometry(700, 32, 15);
            const skyMaterial = new THREE.MeshBasicMaterial({
                color: 0x87CEEB,
                side: THREE.BackSide,
                fog: false
            });
            skyDome = new THREE.Mesh(skyGeometry, skyMaterial);
            skyDome.position.y = 100;
            scene.add(skyDome);
        }

        function createMountains() {
            const mountainMaterial = new THREE.MeshStandardMaterial({
                color: 0x6B8E23,
                roughness: 0.9,
                metalness: 0.0
            });
            const peakMaterial = new THREE.MeshStandardMaterial({
                color: 0xA9A9A9,
                roughness: 0.7,
                metalness: 0.1
            });

            const numMountains = 5;
            const mountainSpacing = 150;

            for (let i = 0; i < numMountains; i++) {
                const mountainGroup = new THREE.Group();

                const baseHeight = Math.random() * 30 + 50;
                const baseWidth = Math.random() * 50 + 80;

                const mountainGeometry = new THREE.ConeGeometry(baseWidth / 2, baseHeight, 6);
                const mountainBody = new THREE.Mesh(mountainGeometry, mountainMaterial);
                mountainBody.position.y = baseHeight / 2;
                mountainBody.castShadow = true;
                mountainGroup.add(mountainBody);

                const numPeaks = Math.floor(Math.random() * 3) + 1;
                for (let j = 0; j < numPeaks; j++) {
                    const peakHeight = Math.random() * 10 + 10;
                    const peakWidth = Math.random() * 15 + 10;
                    const peakGeometry = new THREE.ConeGeometry(peakWidth / 2, peakHeight, 5);
                    const peak = new THREE.Mesh(peakGeometry, peakMaterial);
                    peak.position.set(
                        (Math.random() - 0.5) * (baseWidth * 0.5),
                        baseHeight + (peakHeight / 2) - 5,
                        (Math.random() - 0.5) * (baseWidth * 0.2)
                    );
                    mountainBody.add(peak);
                }

                mountainGroup.add(mountainBody);

                const xPos = (i % 2 === 0 ? -1 : 1) * (roadWidth / 2 + roadsideWidth + 50 + Math.random() * 50);
                const zPos = camera.position.z - 700 - (i * mountainSpacing) - (Math.random() * mountainSpacing / 2);

                mountainGroup.position.set(xPos, 0, zPos);
                scene.add(mountainGroup);
                mountains.push(mountainGroup);
            }
        }

        function updateMountains() {
            const mountainRemovalDistance = camera.position.z + 50;
            const mountainSpawnDistance = camera.position.z - 700;

            mountains.forEach(mountain => {
                mountain.position.z += roadSpeed + (carSpeed / 100);

                if (mountain.position.z > mountainRemovalDistance) {
                    mountain.position.z -= mountains.length * 200;
                    mountain.position.x = (Math.random() < 0.5 ? -1 : 1) * (roadWidth / 2 + roadsideWidth + 50 + Math.random() * 50);
                }
            });
        }

        function update() {
            if (gameRunning) {
                updateCarPosition();
                updateTraffic();
                updateRoad();
                updateRoadsideElements();
                updateRocketPowerUps();
                updateRocket();
                checkCollisions();
                updateScoreAndLevel();
                checkRadar();

                // YENİ: Motor sesini hızla senkronize etme
                if (engineSound) {
                    const minSpeed = 0;
                    const maxSpeedForSound = maxSpeed; // Sesin tam potansiyele ulaşacağı hız
                    const minVolume = 0.1;
                    const maxVolume = 0.6;
                    const minPlaybackRate = 0.8;
                    const maxPlaybackRate = 1.5;

                    // Hıza göre ses seviyesini ayarla
                    engineSound.volume = THREE.MathUtils.mapLinear(carSpeed, minSpeed, maxSpeedForSound, minVolume, maxVolume);
                    // Hıza göre çalma hızını (pitch) ayarla
                    engineSound.playbackRate = THREE.MathUtils.mapLinear(carSpeed, minSpeed, maxSpeedForSound, minPlaybackRate, maxPlaybackRate);
                }

                // Dinamik kamera takibi
                const cameraFollowX = car.position.x * 0.3; // Aracın X pozisyonuna %30 duyarlılık
                const cameraFollowY = 7; // Y sabit kalabilir veya hafifçe ayarlanabilir
                const cameraFollowZ = 10; // Z sabit

                const lerpFactor = 0.05; // Kameranın ne kadar yumuşak takip edeceği (0-1 arası)

                camera.position.x += (cameraFollowX - camera.position.x) * lerpFactor;
                camera.position.y += (cameraFollowY - camera.position.y) * lerpFactor;
                camera.position.z += (cameraFollowZ - camera.position.z) * lerpFactor;

                // Kameranın bakış açısını da araca doğru çevir
                const targetLookAtX = car.position.x * 0.1; // Aracın X pozisyonuna %10 duyarlılık
                const targetLookAtY = 1;
                const targetLookAtZ = -5;

                camera.lookAt(
                    targetLookAtX,
                    targetLookAtY,
                    targetLookAtZ
                );


                // Kamera sallanması (hız efekti)
                if (carSpeed > SPEED_EFFECT_THRESHOLD) {
                    cameraShakeIntensity = THREE.MathUtils.mapLinear(carSpeed, SPEED_EFFECT_THRESHOLD, maxSpeed, 0, maxCameraShakeIntensity);
                    camera.position.y += (Math.sin(Date.now() * 0.01) * cameraShakeIntensity);
                    camera.position.x += (Math.cos(Date.now() * 0.012) * cameraShakeIntensity * 0.5);
                } else {
                    cameraShakeIntensity = THREE.MathUtils.lerp(cameraShakeIntensity, 0, 0.1);
                    camera.position.y += (Math.sin(Date.now() * 0.01) * cameraShakeIntensity);
                    camera.position.x += (Math.cos(Date.now() * 0.012) * cameraShakeIntensity * 0.5);
                }

                if (playerHeadlight && car) {
                    playerHeadlight.position.copy(car.position);
                    playerHeadlight.position.z -= 2;
                    playerHeadlight.position.y += 0.5;

                    playerHeadlight.target.position.copy(playerHeadlight.position).add(new THREE.Vector3(0, 0, -50));
                }

                skyDome.position.x = camera.position.x;
                skyDome.position.y = camera.position.y;
                skyDome.position.z = camera.position.z;

                updateMountains();
            }

            renderer.render(scene, camera);
            animationFrameId = requestAnimationFrame(update);
        }

        function render() {
            renderer.render(scene, camera);
        }

        // Ses dosyaları kaldırıldığı için initAudioAndStartGame doğrudan startGame'i çağırır.
        function initAudioAndStartGame() {
            // YENİ: Motor sesini al ve başlat
            engineSound = document.getElementById('engineSound');
            if (engineSound) {
                engineSound.volume = 0.2; // Başlangıç sesi düşük ayarlanabilir
                engineSound.play().catch(error => {
                    console.warn("Motor sesi çalma hatası:", error);
                    // Tarayıcı otomatik oynatma engeli olabilir, kullanıcıya bir mesaj gösterebilirsiniz.
                });
            }
            startGame();
        }

        init();
    </script>
</body>
</html>