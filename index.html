<!DOCTYPE html>
<html lang="tr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Enhanced 3D Traffic Racer</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: linear-gradient(to bottom, #1e3c72, #2a5298); /* Koyu mavi arka plan */
            font-family: 'Arial', sans-serif;
            overflow: hidden;
            user-select: none;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            width: 100vw;
        }

        canvas {
            display: block;
            cursor: crosshair;
            position: absolute; /* Canvas'ın diğer UI elemanlarının arkasında olmasını sağlar */
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }

        /* Tüm UI elemanları için genel stil */
        .ui-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 100; /* UI elemanlarının canvas'ın önünde olmasını sağlar */
            pointer-events: none; /* Varsayılan olarak olayları geçirme */
        }

        /* Giriş ekranları için genel stil */
        .screen {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: linear-gradient(135deg, rgba(0,0,0,0.8), rgba(20,20,20,0.8));
            color: white;
            padding: 30px;
            border-radius: 15px;
            text-align: center;
            z-index: 200;
            border: 2px solid rgba(255,255,255,0.2);
            backdrop-filter: blur(10px);
            max-width: 90%;
            pointer-events: all; /* Ekranlar aktifken olayları yakala */
            display: none; /* Varsayılan olarak gizli */
        }

        /* Yükleme Ekranı Stilleri */
        #loadingScreen {
            display: flex; /* Başlangıçta sadece yükleme ekranı görünür olacak */
            flex-direction: column;
            justify-content: center;
            align-items: center;
            padding: 40px 30px;
        }

        /* İlk Giriş Ekranı Stilleri */
        #firstEntryScreen {
            flex-direction: column;
            justify-content: center;
            align-items: center;
            padding: 40px 30px;
            background: black; /* Arka plan siyah */
            border: none;
            backdrop-filter: none;
        }

        #firstEntryScreen h1.company-logo {
            font-family: 'Arial Black', sans-serif;
            font-size: 56px; /* Daha büyük */
            font-weight: bold;
            color: #FF8C00; /* Koyu turuncu */
            text-shadow:
                0 0 10px rgba(255,140,0,0.7), /* Parlaklık */
                0 0 20px rgba(255,140,0,0.5), /* Daha fazla parlaklık */
                5px 5px 10px rgba(0,0,0,0.8); /* Derinlik */
            margin-bottom: 25px; /* Altındaki başlıktan daha fazla boşluk */
            -webkit-text-stroke: 2px #A0522D; /* Daha koyu turuncu-kahverengi kenarlık */
            letter-spacing: 3px; /* Harf aralığı */
        }

        #firstEntryScreen h2.game-title {
            font-family: 'Arial', sans-serif;
            font-size: 38px; /* Büyük */
            font-weight: bold;
            color: #C0C0C0; /* Metalik gri */
            text-shadow:
                0 0 5px rgba(192,192,192,0.5), /* Hafif parlaklık */
                0 0 10px rgba(192,192,192,0.3), /* Daha da hafif parlaklık */
                3px 3px 6px rgba(0,0,0,0.7); /* Derinlik */
            margin-bottom: 30px; /* İsim girişinden önce boşluk */
            -webkit-text-stroke: 1px #808080; /* Koyu gri kenarlık */
            letter-spacing: 2px;
        }

        #firstEntryScreen .input-group {
            margin-bottom: 20px;
        }

        #firstEntryScreen label {
            display: block;
            margin-bottom: 10px;
            font-size: 20px;
            color: #E0E0E0;
            text-shadow: 1px 1px 3px rgba(0,0,0,0.6);
        }

        #firstEntryScreen input[type="text"] {
            padding: 12px 15px;
            border-radius: 8px;
            border: 2px solid #555;
            background-color: rgba(255,255,255,0.1);
            color: white;
            font-size: 18px;
            width: 250px;
            max-width: 80%;
            text-align: center;
            box-shadow: inset 0 0 8px rgba(0,0,0,0.5);
            transition: border-color 0.3s ease;
        }

        #firstEntryScreen input[type="text"]:focus {
            outline: none;
            border-color: #007bff;
            box-shadow: inset 0 0 8px rgba(0,123,255,0.5), 0 0 10px rgba(0,123,255,0.3);
        }

        #firstEntryScreen .credits {
            margin-top: 40px; /* Butondan sonra boşluk */
            text-align: center;
        }

        #firstEntryScreen .credits p {
            color: #FF8C00; /* Koyu turuncu */
            font-size: 15px;
            text-shadow:
                0 0 5px rgba(255,140,0,0.7),
                0 0 10px rgba(255,140,0,0.5);
            margin: 5px 0;
            -webkit-text-stroke: 0.5px rgba(160,82,45,0.5); /* Hafif kenarlık */
            letter-spacing: 1px;
        }

        /* İkinci Giriş Ekranı Stilleri */
        #secondStartScreen {
            flex-direction: column;
            justify-content: center;
            align-items: center;
            padding: 50px 30px;
        }

        #secondStartScreen .welcome-message {
            font-size: 28px;
            color: #E0E0E0;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.7);
            margin-bottom: 40px; /* Butondan önce boşluk */
        }

        /* Ortak Buton Stilleri */
        button {
            background: linear-gradient(45deg, #66BB6A, #4CAF50); /* Daha açık yeşil */
            color: white;
            border: 2px solid rgba(255,255,255,0.3); /* Belirgin çerçeve */
            padding: 15px 30px; /* Daha büyük butonlar */
            font-size: 20px; /* Daha büyük font */
            border-radius: 10px; /* Daha yuvarlak köşeler */
            cursor: pointer;
            margin-top: 20px; /* Butonlar arası boşluk */
            transition: all 0.2s ease; /* Daha hızlı geçiş */
            box-shadow: 0 6px 15px rgba(0,0,0,0.4); /* Hafif gölge */
            font-weight: bold;
            letter-spacing: 1px;
        }

        button:hover {
            transform: translateY(-3px);
            box-shadow: 0 8px 20px rgba(0,0,0,0.6);
            background: linear-gradient(45deg, #76C77C, #5CBF60); /* Hover rengi */
        }

        button:active {
            background: linear-gradient(45deg, #388E3C, #4CAF50); /* Daha koyu yeşil */
            transform: translateY(0px);
            box-shadow: 0 2px 8px rgba(0,0,0,0.5);
        }

        /* "GAZLA!!!" butonu için özel stil */
        #gasButton {
            font-size: 40px;
            padding: 25px 60px;
            background: linear-gradient(45deg, #28A745, #218838); /* Daha koyu yeşil */
            border-color: rgba(255,255,255,0.5);
            box-shadow: 0 8px 20px rgba(0,0,0,0.6);
            margin-top: 50px;
        }
        #gasButton:hover {
            background: linear-gradient(45deg, #2ED955, #28A745);
            transform: translateY(-5px);
            box-shadow: 0 12px 25px rgba(0,0,0,0.8);
        }
        #gasButton:active {
            background: linear-gradient(45deg, #1C7433, #218838);
            transform: translateY(0px);
            box-shadow: 0 4px 10px rgba(0,0,0,0.6);
        }

        /* Oyun İçi UI Elemanları */
        .ui, .top-info, .health-bar-container, .combo, .score-feedback,
        .instructions, .speed-controls, .rocket-btn, .mobile-controls, .speed-display, .game-over {
            display: none; /* Başlangıçta hepsi gizli */
            pointer-events: none; /* Varsayılan olarak olayları geçirme */
        }

        /* Oyun başladığında görünür olacak UI elemanları */
        body.game-active .ui,
        body.game-active .top-info,
        body.game-active .health-bar-container,
        /* body.game-active .instructions, */ /* Konsol ile değiştirildiği için kaldırıldı */
        body.game-active .speed-controls,
        body.game-active .rocket-btn, /* Roket tuşu eklendi */
        body.game-active .mobile-controls,
        /* body.game-active .speed-display, */ /* Hız göstergesi kokpite taşındığı için kaldırıldı */
        body.game-active .cockpit-console { /* Kokpit konsolu görünür olacak */
            display: block; /* Veya flex, duruma göre */
            pointer-events: auto; /* Oyun başladığında olayları yakala */
        }

        /* Özel flexbox düzenlemeleri */
        body.game-active .top-info {
            display: flex;
            flex-direction: column;
            align-items: flex-end;
            gap: 8px;
            position: absolute;
            top: 10px;
            right: 10px;
            z-index: 100;
        }

        body.game-active .speed-controls,
        body.game-active .mobile-controls {
            display: flex;
        }

        /* Roket tuşu stil başlangıcı */
        .rocket-btn {
            position: absolute;
            bottom: 50px; /* Hız kontrol butonlarının alt hizasına getirildi */
            left: 100px; /* Hızlan/Yavaşla butonlarının sağına kaydırıldı (varsayılan hızlan/yavaşla butonu genişliği 80px + biraz boşluk) */
            width: 100px;
            height: 60px;
            background: linear-gradient(45deg, #FF4500, #FF0000);
            border: 2px solid rgba(255,255,255,0.4);
            border-radius: 10px;
            color: white;
            font-size: 18px;
            font-weight: bold;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            user-select: none;
            backdrop-filter: blur(5px);
            transition: all 0.2s ease;
            box-shadow: 0 4px 10px rgba(0,0,0,0.4);
            z-index: 100;
        }

        .rocket-btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 6px 15px rgba(0,0,0,0.6);
            background: linear-gradient(45deg, #FF6347, #FF3333); /* Hover rengi */
        }

        .rocket-btn:active {
            transform: translateY(0px);
            box-shadow: 0 2px 5px rgba(0,0,0,0.5);
            background: linear-gradient(45deg, #CC3300, #CC0000); /* Active rengi */
        }
        /* Roket tuşu stil sonu */

        /* Mevcut UI stilleri (sadece oyun aktifken görünür) */
        .ui {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            font-size: 16px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
            z-index: 100;
            background: rgba(0,0,0,0.3);
            padding: 10px;
            border-radius: 8px;
            backdrop-filter: blur(5px);
        }

        .info-box {
            background: rgba(0,0,0,0.4);
            color: white;
            padding: 8px 15px;
            border-radius: 8px;
            font-size: 20px;
            font-weight: bold;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
            backdrop-filter: blur(5px);
            min-width: 120px;
            text-align: right;
        }

        /* Health Bar Styles */
        .health-bar-container {
            position: absolute;
            top: 50%; /* Dikeyde ortala */
            right: 50px; /* Sağ tarafa konumlandır */
            transform: translateY(-50%); /* Dikey hizalama için ayarla */
            width: 30px; /* Barın genişliği */
            height: 150px; /* Barın yüksekliği */
            background: rgba(255,255,255,0.2);
            border-radius: 5px;
            overflow: hidden;
            border: 2px solid rgba(255,255,255,0.3);
            z-index: 100;
            display: flex;
            flex-direction: column; /* İçeriği yukarıdan aşağıya düzenle */
            align-items: center;
            justify-content: flex-start; /* Yukarıdan aşağıya dolması için */
        }

        .health-label {
            position: absolute;
            top: -25px; /* Barın üzerinde */
            right: 0;
            width: 100%;
            text-align: center;
            color: white;
            font-size: 16px;
            font-weight: bold;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.8);
            z-index: 101;
        }

        .health-fill {
            width: 100%; /* Genişliği tam olsun */
            background: hsl(120, 100%, 40%); /* Başlangıç rengi yeşil */
            transition: height 0.3s ease-out, background-color 0.3s ease-out; /* Hem yükseklik hem renk geçişi ekle */
            /* height başlangıçta JS tarafından ayarlanacak */
            align-self: flex-end; /* İçeriğin yukarıdan aşağıya doğru azalması için */
        }

        .game-over {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: linear-gradient(135deg, rgba(0,0,0,0.9), rgba(20,20,20,0.9));
            color: white;
            padding: 30px;
            border-radius: 15px;
            text-align: center;
            z-index: 200;
            border: 2px solid rgba(255,255,255,0.2);
            backdrop-filter: blur(10px);
            box-shadow: 0 20px 40px rgba(0,0,0,0.5);
            max-width: 90%;
            pointer-events: all;
        }
        
        #countdownOverlay {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 150px; /* Büyük geri sayım */
            color: #FFD700; /* Altın rengi */
            text-shadow:
                0 0 20px rgba(255,215,0,0.8),
                0 0 40px rgba(255,215,0,0.6),
                0 0 60px rgba(255,215,0,0.4);
            z-index: 300; /* En üstte olmalı */
            display: none; /* Varsayılan olarak gizli */
            font-weight: bold;
        }

        @keyframes countdownFade {
            0% { opacity: 1; transform: translate(-50%, -50%) scale(1); }
            80% { opacity: 1; transform: translate(-50%, -50%) scale(1.2); }
            100% { opacity: 0; transform: translate(-50%, -50%) scale(1.5); }
        }

        .instructions {
            /* Bu kısım artık kullanılmıyor, cockpit-console ile değiştirildi */
            display: none !important;
        }

        .combo {
            position: absolute;
            top: 3%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #FFFF00;
            font-size: 38px;
            font-weight: bolder;
            text-shadow:
                0 0 8px rgba(255,255,0,0.7),
                0 0 15px rgba(255,165,0,0.7),
                0 0 20px rgba(255,0,0,0.7),
                3px 3px 5px rgba(0,0,0,0.9);
            z-index: 150;
            animation: comboAnim 1.5s cubic-bezier(0.25, 0.46, 0.45, 0.94) forwards;
            letter-spacing: 1px;
            -webkit-text-stroke: 1px black;
        }

        @keyframes comboAnim {
            0% { opacity: 0; transform: translate(-50%, -50%) scale(0.5); letter-spacing: -3px; }
            30% { opacity: 1; transform: translate(-50%, -50%) scale(1.1); letter-spacing: 3px; }
            70% { opacity: 1; transform: translate(-50%, -50%) scale(1.0); letter-spacing: 1px; }
            100% { opacity: 0; transform: translate(-50%, -50%) scale(0.9); }
        }

        .score-feedback {
            position: absolute;
            top: 8%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #00FF00;
            font-size: 28px;
            font-weight: bold;
            text-shadow: 0 0 4px rgba(0,255,0,0.8), 0 0 8px rgba(0,255,0,0.5);
            z-index: 160;
            opacity: 0;
            animation: scoreFeedbackAnim 1.0s ease-out forwards;
            pointer-events: none;
        }

        @keyframes scoreFeedbackAnim {
            0% { opacity: 0; transform: translate(-50%, -30%) scale(0.7); }
            20% { opacity: 1; transform: translate(-50%, -50%) scale(1.0); }
            80% { opacity: 1; transform: translate(-50%, -70%) scale(0.9); }
            100% { opacity: 0; transform: translate(-50%, -80%) scale(0.8); }
        }

        .speed-controls {
            position: absolute;
            bottom: 30px; /* Yavaşla tuşuyla aynı hizada kalması için ayarlandı */
            left: 10px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            z-index: 100;
        }

        .speed-btn {
            width: 80px;
            height: 50px;
            background: linear-gradient(45deg, rgba(255,255,255,0.3), rgba(200,200,200,0.3));
            border: 2px solid rgba(255,255,255,0.4);
            border-radius: 8px;
            color: white;
            font-size: 18px;
            font-weight: bold;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            user-select: none;
            backdrop-filter: blur(5px);
            transition: all 0.2s ease;
            box-shadow: 0 4px 10px rgba(0,0,0,0.4);
        }

        .speed-btn.accelerate { background: linear-gradient(45deg, rgba(0,200,0,0.5), rgba(0,150,0,0.5)); }
        .speed-btn.brake { background: linear-gradient(45deg, rgba(200,0,0,0.5), rgba(150,0,0,0.5)); }

        .speed-btn:active {
            transform: scale(0.95);
            box-shadow: 0 2px 5px rgba(0,0,0,0.5);
            background: linear-gradient(45deg, rgba(255,255,255,0.5), rgba(200,200,200,0.5));
        }

        .speed-btn.accelerate:active { background: linear-gradient(45deg, rgba(0,150,0,0.7), rgba(0,100,0,0.7)); }
        .speed-btn.brake:active { background: linear-gradient(45deg, rgba(150,0,0,0.7), rgba(100,0,0,0.7)); }


        .mobile-controls {
            position: absolute;
            bottom: 50px;
            right: 10px;
            display: flex;
            gap: 10px;
            z-index: 100;
        }

        .control-btn {
            width: 60px;
            height: 60px;
            background: linear-gradient(45deg, rgba(255,255,255,0.3), rgba(200,200,200,0.3));
            border: 2px solid rgba(255,255,255,0.4);
            border-radius: 50%;
            color: white;
            font-size: 24px;
            font-weight: bold;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            user-select: none;
            backdrop-filter: blur(5px);
            transition: all 0.2s ease;
            box-shadow: 0 4px 10px rgba(0,0,0,0.4);
        }

        .control-btn:active {
            background: linear-gradient(45deg, rgba(255,255,255,0.5), rgba(200,200,200,0.5));
            transform: scale(0.95);
            box-shadow: 0 2px 5px rgba(0,0,0,0.5);
        }

        .time-of-day-info {
            color: white;
            font-size: 16px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
            margin-top: 5px;
            display: block;
        }

        @keyframes fadeOut {
            0% { opacity: 1; transform: translate(-50%, -50%) scale(1); }
            100% { opacity: 0; transform: translate(-50%, -100%) scale(0.8); }
        }

        /* Hız Göstergesi Div'ini gizle, çünkü artık kokpit içinde gösterilecek */
        .speed-display {
            display: none !important;
        }

        .speed-bar-container, .speed-bar-fill {
            display: none;
        }

        /* NEW: Kokpit Konsolu Stilleri */
        .cockpit-console {
            position: absolute;
            bottom: -50px; /* Başlangıçta ekranın biraz altında */
            left: 50%;
            transform: translateX(-50%);
            width: 300px; /* Genişlik ayarlandı */
            max-width: 90%;
            height: 250px; /* Konsolun yüksekliği ayarlandı */
            background: linear-gradient(to bottom, #3a3a3a, #1a1a1a); /* Koyu gri gradient */
            border-radius: 20px 20px 0 0; /* Üst köşeler yuvarlak */
            box-shadow: 0 -10px 20px rgba(0,0,0,0.7);
            padding: 15px;
            box-sizing: border-box;
            display: flex;
            flex-direction: column;
            align-items: center;
            opacity: 0; /* Başlangıçta görünmez */
            transition: bottom 0.8s ease-out, opacity 0.8s ease-out; /* Animasyon için */
            z-index: 90; /* Diğer UI elemanlarının altında */
            pointer-events: none; /* Konsol başlangıçta etkileşim kabul etmez */
        }

        /* Oyun başında konsolun görünür olması için */
        body.game-active .cockpit-console {
            bottom: 10px; /* Oyun başladığında ekranın altına gelsin */
            opacity: 1; /* Görünür olsun */
            pointer-events: all; /* Etkileşim kabul etsin */
        }

        /* Konsolun üst ve alt kenarlıkları */
        .console-border-top {
            width: 100%;
            height: 10px;
            background: #555;
            border-radius: 10px 10px 0 0;
            margin-bottom: 5px;
        }
        .console-border-bottom {
            width: 100%;
            height: 10px;
            background: #555;
            border-radius: 0 0 10px 10px;
            margin-top: 5px;
        }

        .console-screen {
            width: 100%;
            background-color: #0d0d0d; /* Ekranın koyu arka planı */
            border: 2px solid #222;
            border-radius: 8px;
            padding: 10px;
            box-sizing: border-box;
            text-align: center;
            color: #00FF00; /* Yeşil metin */
            font-family: 'Consolas', monospace;
            font-size: 16px;
            text-shadow: 0 0 5px rgba(0,255,0,0.5); /* Yeşil parlaklık */
            display: flex; /* İçeriklerini flexbox ile yönetmek için */
            flex-direction: column; /* Kontroller başlığı üste, içerik alta */
            align-items: center; /* Ortalamak için */
        }

        .console-screen p {
            margin-top: 0;
            margin-bottom: 10px;
            font-weight: bold;
        }

        .cockpit-content {
            display: flex;
            justify-content: space-around; /* Elemanlar arasında eşit boşluk bırak */
            align-items: center; /* Dikeyde ortala */
            width: 100%;
            flex-grow: 1; /* Kalan alanı kapla */
            padding-bottom: 10px; /* Alt boşluk */
        }

        .key-display-group {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .key-group-left {
            align-items: flex-end; /* Sol gruptaki tuşları sağa hizala */
            padding-right: 15px; /* Kadranla arasına boşluk */
        }

        .key-group-right {
            align-items: flex-start; /* Sağ gruptaki tuşları sola hizala */
            padding-left: 15px; /* Kadranla arasına boşluk */
        }

        .key-row {
            display: flex;
            gap: 5px;
            justify-content: center; /* Tuşları ortala */
        }
        .key-row-left {
             /* Tuşları kendi grubunda sağa hizala */
            justify-content: flex-end;
        }
        .key-row-right {
            /* Tuşları kendi grubunda sola hizala */
            justify-content: flex-start;
        }
        .key-row-single {
            margin-top: 10px;
        }


        .key-button {
            width: 40px;
            height: 40px;
            background: rgba(50,50,50,0.8); /* Koyu gri tuş arka planı */
            border: 2px solid #666;
            border-radius: 5px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 18px;
            font-weight: bold;
            color: #C0C0C0; /* Gri tuş metni */
            text-shadow: 1px 1px 2px rgba(0,0,0,0.6);
            box-shadow: inset 0 0 5px rgba(0,0,0,0.5);
            transition: background-color 0.1s ease, box-shadow 0.1s ease, color 0.1s ease;
        }

        .key-button-large {
            width: 80px; /* Daha geniş tuşlar için */
        }

        /* Tuşa basıldığında vurgu */
        .key-button.active {
            background-color: #00FF00; /* Yeşil vurgu */
            color: black; /* Siyah metin */
            box-shadow: inset 0 0 8px rgba(0,255,0,0.8), 0 0 10px rgba(0,255,0,0.5); /* Yeşil parlaklık */
        }

        /* NEW: Hız Kadranı Stilleri */
        .speed-gauge {
            position: relative;
            width: 120px; /* Kadran genişliği */
            height: 120px; /* Kadran yüksekliği */
            border-radius: 50%;
            background: radial-gradient(circle at center, #111 0%, #333 70%, #555 100%); /* Hafif içbükey efekt */
            box-shadow: inset 0 0 10px rgba(0,0,0,0.8), 0 0 15px rgba(0,0,0,0.5);
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 28px;
            font-weight: bolder;
            text-shadow: 0 0 8px rgba(255,255,255,0.7);
            border: 3px solid #666; /* Dış çerçeve */
        }

        .gauge-ring {
            position: absolute;
            width: 100%;
            height: 100%;
            border-radius: 50%;
            border: 8px solid transparent; /* Kalın halka */
            border-top-color: #4CAF50; /* Başlangıç rengi yeşil */
            border-right-color: #4CAF50;
            border-bottom-color: #4CAF50;
            border-left-color: #4CAF50;
            transform: rotate(-45deg); /* Halkanın başlangıç açısını ayarla */
            box-sizing: border-box;
            transition: border-color 0.3s ease; /* Renk geçişi için */
        }

        .gauge-center {
            position: relative; /* İçerik için */
            z-index: 2; /* Halkanın üzerinde olsun */
            text-align: center;
        }

        #currentSpeedGauge {
            display: block; /* Sayı ve etiket alt alta gelsin */
            font-size: 32px; /* Sayı boyutu */
            line-height: 1;
            /* Renk JavaScript ile yönetilecek */
        }

        .gauge-label {
            font-size: 12px;
            color: #DDD;
            margin-top: 5px;
        }

        /* Mobil ekranlar için uyarlama */
        @media (max-width: 768px) {
            .cockpit-console {
                width: 280px; /* Daha geniş mobil konsol */
                height: 200px; /* Mobil konsol yüksekliği */
                padding: 10px;
                bottom: 5px; 
            }
            .console-screen {
                font-size: 14px;
            }
            .key-button {
                width: 30px;
                height: 30px;
                font-size: 14px;
            }
            .key-button-large {
                width: 60px;
            }
            body.game-active .cockpit-console {
                bottom: 5px; 
            }
            .speed-gauge {
                width: 100px;
                height: 100px;
            }
            #currentSpeedGauge {
                font-size: 28px;
            }
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>

    <div class="ui-overlay">
        <div class="screen" id="loadingScreen">
            <h1 class="company-logo">KuAtAmA Games</h1>
            <p style="font-size: 24px; margin-top: 20px; color: #E0E0E0;">Yükleniyor...</p>
            <p id="loadingTip" style="font-size: 18px; margin-top: 20px; color: #ADD8E6; text-shadow: 1px 1px 3px rgba(0,0,0,0.5); opacity: 0; transition: opacity 0.5s ease-in-out; min-height: 40px;"></p>
            <div style="width: 200px; height: 4px; background: rgba(255,255,255,0.2); border-radius: 2px; overflow: hidden; margin-top: 30px;">
                <div id="progressBar" style="width: 0%; height: 100%; background: #4CAF50; transition: width 0.1s linear;"></div>
            </div>
        </div>

        <div class="screen" id="firstEntryScreen">
            <h1 class="company-logo">KuAtAmA Games</h1>
            <button id="gasButton">GAZLA!!!</button>
            <div class="credits">
                <p>Create By Atakan Cerrahoğlu</p>
                <p>Müzik: Kırılmış Kolum / Atakan Cerrahoğlu</p>
            </div>
        </div>

        <div class="screen" id="secondStartScreen">
            <p class="welcome-message">İyi oyunlar!</p>
            <div class="input-group">
                <label for="playerNameInput">İsim giriniz:</label>
                <input type="text" id="playerNameInput" placeholder="Adınız" maxlength="10">
            </div>
            <button id="startButton">BAŞLA</button>
        </div>
        
        <div id="countdownOverlay"></div>

        <div class="ui">
            <div>📍 Mesafe: <span id="distance">0</span>m</div>
            <div>⭐ Seviye: <span id="level">1</span></div>
            <div>🚀 Roketler: <span id="rocketsDisplay">0</span></div>
            <div class="time-of-day-info" id="timeOfDayInfo">
                ☀️ Gündüz: <span id="timeOfDayDisplay">00:00</span>
            </div>
        </div>

        <div class="top-info">
            <div class="info-box">💰 Skor: <span id="scoreDisplay">0</span></div>
            <div class="info-box">🔥 Kombo: <span id="comboDisplay">0</span></div>
        </div>

        <div class="health-bar-container">
            <div class="health-label">Can</div>
            <div class="health-fill" id="healthFill"></div>
        </div>

        <div class="combo" id="comboText">SÜPER!</div>

        <div id="scoreFeedback" class="score-feedback"></div>

        <div class="cockpit-console" id="cockpitConsole">
            <div class="console-border-top"></div>
            <div class="console-screen">
                <p>KONTROLLER</p>
                <div class="cockpit-content">
                    <div class="key-display-group key-group-left">
                        <div class="key-row key-row-left">
                            <div class="key-button" id="keyW">W</div>
                            <div class="key-button" id="keyUp">↑</div>
                        </div>
                        <div class="key-row key-row-left">
                            <div class="key-button" id="keyA">A</div>
                            <div class="key-button" id="keyS">S</div>
                            <div class="key-button" id="keyD">D</div>
                        </div>
                        <div class="key-row key-row-left">
                            <div class="key-button" id="keyLeft">←</div>
                            <div class="key-button" id="keyDown">↓</div>
                            <div class="key-button" id="keyRight">→</div>
                        </div>
                    </div>

                    <div class="speed-gauge">
                        <div class="gauge-ring"></div>
                        <div class="gauge-center">
                            <span id="currentSpeedGauge">0</span>
                            <div class="gauge-label">KM/S</div>
                        </div>
                    </div>

                    <div class="key-display-group key-group-right">
                        <div class="key-row key-row-single key-row-right">
                            <div class="key-button" id="keyR">R</div>
                        </div>
                    </div>
                </div>
            </div>
            <div class="console-border-bottom"></div>
        </div>


        <div class="rocket-btn" id="rocketBtn">
            🔥 ROKET
        </div>

        <div class="speed-controls" id="speedControls">
            <div class="speed-btn accelerate" id="accelerateBtn">Hızlan</div>
            <div class="speed-btn brake" id="brakeBtn">Yavaşla</div>
        </div>

        <div class="mobile-controls" id="mobileControls">
            <div class="control-btn" id="leftBtn">←</div>
            <div class="control-btn" id="rightBtn">→</div>
        </div>

        <div class="speed-display" id="speedDisplay">
            <span id="currentSpeed">0</span>
        </div>

        <div class="game-over" id="gameOver">
            <h2>💥 KAZA!</h2>
            <p>Toplam Skor: <span id="finalScore">0</span></p>
            <p>Mesafe: <span id="finalDistance">0</span>m</p>
            <p>En Yüksek Kombo: <span id="maxCombo">0</span></p>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Oyun değişkenleri
        let scene, camera, renderer, car, road = [], trafficCars = [], barriers = [];
        let roadsideElements = [];
        let gameRunning = false;
        let score = 0, distance = 0, level = 1;
        let carSpeed = 0, maxSpeed = 250;
        let roadSpeed = 0.5;
        let baseTrafficSpeed = 0.3;
        let keys = {};
        let gameStarted = false;
        let combo = 0;
        let highCombo = 0;
        let lastComboTime = 0;
        let mobileControls = { left: false, right: false, accelerate: false, brake: false };
        let animationFrameId;
        let carTilt = 0;
        const maxCarTilt = Math.PI / 24; 

        let audioContext;
        let engineGainNode; 
        let engineSource; 
        let engineBuffer; 

        let brakeBuffer; 
        let policeSirenBuffer; 
        let introBuffer; 
        let introGainNode; 
        let powerUpCollectBuffer; // Bu ses dosyasının URL'si verilmediği için şimdilik pasif kalacak.

        let brakeLightMesh = null;
        let spoilerTaillights = [];
        let pooledTrafficCars = [];
        const MAX_POOLED_TRAFFIC_CARS = 20;


        let health = 100;
        const maxHealth = 100;
        const sideCollisionDamageMultiplier = 0.1; 
        const directCollisionZThreshold = 2.0;

        let playerHeadlight;

        const carBox = new THREE.Box3();
        const trafficBox = new THREE.Box3();
        const powerUpBox = new THREE.Box3(); 

        const roadWidth = 20;
        const lanes = [-7, 0, 7];
        const laneWidth = 7;
        const roadsideWidth = 15;

        let rocketParticles = [];

        let rockets = 0; 
        let activeRocket = null;
        const rocketBaseSpeed = 1.5;
        const rocketCooldown = 1000;
        let lastRocketFireTime = 0;
        let trafficCarsDestroyedByRocket = 0; // Roketle yok edilen araç sayısı
        let rocketsFiredCount = 0; 

        let rocketPowerUps = [];
        const rocketPowerUpSpawnInterval = 10000;
        let lastRocketPowerUpSpawnTime = 0;

        let skyDome;
        let mountains = [];

        let activePoliceCar = null;
        const policeChaseDistance = 5; 

        const policeSpawnCooldownTime = 30000; 
        let lastPoliceCarDespawnTime = 0;
        let policeDifficultyMultiplier = 1.0;

        let policeDamageStartTime = 0;
        const policeTotalDamageLimit = 10;
        const policeDamageInterval = 1000;
        let lastPoliceIncrementalDamageTime = 0;
        let currentPoliceChaseDamage = 0;

        const MAX_POOLED_POLICE_CARS = 2;
        let policeCarsPool = [];

        let playerName = "Oyuncu";

        let timeOfDay = 6;
        const dayDurationInGameMeters = 5000;
        let previousDistanceForTime = 0;

        let radarPoles = [];
        let lastRadarHitTime = {};
        let nextRadarSpawnDistance = 0;

        const SPEED_EFFECT_THRESHOLD = 200;
        let cameraShakeIntensity = 0;
        const maxCameraShakeIntensity = 0.08;
        const speedEffectScaleFactor = 0.0005;

        // LoadingManager ve İlerleme Çubuğu Değişkenleri
        let loadingManager;
        let progressBar = document.getElementById('progressBar');
        let loadingScreen = document.getElementById('loadingScreen');
        let loadingTip = document.getElementById('loadingTip'); 

        // Kokpit elemanları için referanslar
        let cockpitConsole = document.getElementById('cockpitConsole');
        let currentSpeedGauge = document.getElementById('currentSpeedGauge');
        let gaugeRing = document.querySelector('.gauge-ring');

        const loadingTips = [ 
            "Hız ve şiddet içerir.",
            "Hız kadar, yavaşlamak da önemlidir.",
            "Roketle ve polisden kaç!",
            "Trafik araçlarına yakın geçerek bonus puanlar kazan!",
            "Radar cezalarına dikkat et, hız limitini aşma!",
            "Gündüz-gece döngüsü oyun deneyimini etkiler.",
            "Sağlık barına göz kulak ol, çarpışmalardan kaçın!",
            "Polis arabaları peşini bırakmaz, onları atlat!"
        ];
        let currentTipIndex = 0;
        let lastTipChangeProgress = -1; 

        // Tuş elementleri için referanslar
        const keyMap = {
            'w': document.getElementById('keyW'),
            'a': document.getElementById('keyA'),
            's': document.getElementById('keyS'),
            'd': document.getElementById('keyD'),
            'arrowup': document.getElementById('keyUp'),
            'arrowleft': document.getElementById('keyLeft'),
            'arrowdown': document.getElementById('keyDown'),
            'arrowright': document.getElementById('keyRight'),
            'r': document.getElementById('keyR')
        };


        function init() {
            // LoadingManager oluştur
            loadingManager = new THREE.LoadingManager();

            loadingManager.onProgress = function (url, itemsLoaded, itemsTotal) {
                console.log('Yükleniyor: ' + url + '.  Yüklenen öğe: ' + itemsLoaded + '/' + itemsTotal);
                const progress = (itemsLoaded / itemsTotal) * 100;
                if (progressBar) { 
                    progressBar.style.width = progress + '%';
                }

                // İlerleme çubuğuna göre ipuçlarını güncelle
                if (loadingTip) {
                    const totalTips = loadingTips.length;
                    const tipInterval = 100 / totalTips; 

                    const newTipIndex = Math.floor(progress / tipInterval);

                    if (newTipIndex !== currentTipIndex && newTipIndex < totalTips) {
                        currentTipIndex = newTipIndex;
                        loadingTip.style.opacity = 0; 
                        setTimeout(() => {
                            loadingTip.textContent = loadingTips[currentTipIndex];
                            loadingTip.style.opacity = 1; 
                        }, 500); 
                    } else if (progress >= 99 && currentTipIndex < totalTips -1 && lastTipChangeProgress < 99) {
                        currentTipIndex = totalTips - 1;
                        loadingTip.style.opacity = 0;
                        setTimeout(() => {
                            loadingTip.textContent = loadingTips[currentTipIndex];
                            loadingTip.style.opacity = 1; 
                        }, 500);
                    }
                    lastTipChangeProgress = progress; 
                }
            };

            loadingManager.onLoad = function () {
                console.log('Tüm varlıklar yüklendi!');
                initAudioAndLoadGame(); 
                if (loadingTip) {
                     loadingTip.textContent = "Hazır!"; 
                     loadingTip.style.opacity = 1;
                }
            };

            loadingManager.onError = function (url) {
                console.error('Yüklenirken hata oluştu: ' + url);
                initAudioAndLoadGame(); 
            };

            scene = new THREE.Scene();
            scene.fog = new THREE.Fog(0x87CEEB, 100, 500);

            camera = new THREE.PerspectiveCamera(80, window.innerWidth / window.innerHeight, 0.1, 1000); 
            camera.position.set(0, 9, 14); 
            camera.lookAt(0, 2, -5); 


            renderer = new THREE.WebGLRenderer({
                canvas: document.getElementById('gameCanvas'),
                antialias: true
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.setClearColor(0x87CEEB);

            const ambientLight = new THREE.AmbientLight(0x404080, 0.8);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionionalLight(0xffffff, 1.2);
            directionalLight.position.set(20, 30, 10);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 1024;
            directionalLight.shadow.mapSize.height = 1024;
            directionalLight.shadow.camera.near = 0.5;
            directionalLight.shadow.camera.far = 100;
            directionalLight.shadow.camera.left = -50;
            directionalLight.shadow.camera.right = 50;
            directionalLight.shadow.camera.top = 50;
            directionalLight.shadow.camera.bottom = -50;
            scene.add(directionalLight);

            createPlayerCar();
            createPlayerHeadlight();
            createRoad();
            createRoadside();
            createBarriers();
            createInitialTrafficCars(5);
            createInitialRoadsideElements(10);
            createSkyDome();
            createMountains();

            for (let i = 0; i < MAX_POOLED_POLICE_CARS; i++) {
                const { car: policeCar, length } = createTrafficCar(0x0000FF, 'sport', true);
                policeCar.visible = false;
                policeCar.userData.isPooled = true;
                policeCar.userData.length = length;
                policeCar.userData.type = 'sport';
                policeCar.userData.isPolice = true;
                policeCar.userData.currentLane = 0;
                policeCar.userData.targetLane = 0;
                policeCar.userData.isChangingLane = false;
                policeCar.userData.wander = 0;
                policeCar.userData.wanderTarget = 0;
                policeCar.userData.lastX = 0;
                policeCar.userData.trafficCollisions = 0;
                scene.add(policeCar);
                policeCarsPool.push(policeCar);
            }

            for (let i = 0; i < MAX_POOLED_TRAFFIC_CARS; i++) {
                const colors = [0x00FF00, 0x0000FF, 0xFFFF00, 0xFF00FF, 0x00FFFF, 0xFF8C00, 0x8A2BE2, 0x00CED1, 0xFF69B4, 0x4B0082, 0xADFF2F, 0xFFD700];
                const types = ['sedan', 'truck', 'minivan', 'bus'];
                const color = colors[Math.floor(Math.random() * colors.length)];
                const type = types[Math.floor(Math.random() * types.length)];
                const { car: trafficCar, length } = createTrafficCar(color, type);
                trafficCar.visible = false;
                trafficCar.userData.isPooled = true;
                trafficCar.userData.length = length;
                trafficCar.userData.type = type;
                trafficCar.userData.isPolice = false;
                trafficCar.userData.currentLane = 0;
                trafficCar.userData.targetLane = 0;
                trafficCar.userData.isChangingLane = false;
                trafficCar.userData.wander = 0;
                trafficCar.userData.wanderTarget = 0;
                trafficCar.userData.lastX = 0;
                trafficCar.userData.trafficCollisions = 0;
                scene.add(trafficCar);
                pooledTrafficCars.push(trafficCar);
            }


            window.addEventListener('resize', onWindowResize);
            document.addEventListener('keydown', onKeyDown);
            document.addEventListener('keyup', onKeyUp);

            setupMobileControls();

            render();
        }

        function showFirstScreen() {
            document.getElementById('loadingScreen').style.display = 'none'; 
            document.getElementById('firstEntryScreen').style.display = 'flex';
            document.getElementById('secondStartScreen').style.display = 'none';
            document.getElementById('gameOver').style.display = 'none';
            document.body.classList.remove('game-active'); 

            if (cockpitConsole) {
                cockpitConsole.style.bottom = '-50px'; 
                cockpitConsole.style.opacity = '0'; 
                cockpitConsole.style.pointerEvents = 'none'; 
            }
        }
        
        function showSecondScreen() {
            document.getElementById('loadingScreen').style.display = 'none'; 
            document.getElementById('firstEntryScreen').style.display = 'none';
            document.getElementById('secondStartScreen').style.display = 'flex';
            document.getElementById('gameOver').style.display = 'none';
            document.body.classList.remove('game-active'); 

            if (introGainNode) {
                introGainNode.gain.setValueAtTime(0.25, audioContext.currentTime);
            }
        }

        function hideAllScreensForGame() {
            document.getElementById('loadingScreen').style.display = 'none'; 
            document.getElementById('firstEntryScreen').style.display = 'none';
            document.getElementById('secondStartScreen').style.display = 'none';
            document.getElementById('gameOver').style.display = 'none';
            document.body.classList.add('game-active'); 

            if (cockpitConsole) {
                cockpitConsole.style.bottom = '10px'; 
                cockpitConsole.style.opacity = '1'; 
                cockpitConsole.style.pointerEvents = 'all'; 
            }
        }

        document.getElementById('gasButton').addEventListener('click', () => {
            if (audioContext && audioContext.state === 'suspended') {
                audioContext.resume().then(() => {
                    console.log('AudioContext resumed (first interaction).');
                    if (introBuffer && (!introSource || introSource.playState !== 'playing')) {
                        introSource = audioContext.createBufferSource();
                        introSource.buffer = introBuffer;
                        introSource.loop = true;
                        introGainNode = audioContext.createGain();
                        introGainNode.gain.setValueAtTime(0.9, audioContext.currentTime); 
                        introSource.connect(introGainNode);
                        introGainNode.connect(audioContext.destination);
                        introSource.start(0);
                        introSource.playState = 'playing';
                        console.log("Intro sound started on first interaction.");
                    }
                }).catch(error => {
                    console.error("Failed to resume AudioContext:", error);
                });
            } else if (introBuffer && (!introSource || introSource.playState !== 'playing')) {
                introSource = audioContext.createBufferSource();
                introSource.buffer = introBuffer;
                introSource.loop = true;
                introGainNode = audioContext.createGain();
                introGainNode.gain.setValueAtTime(0.9, audioContext.currentTime); 
                introSource.connect(introGainNode);
                introGainNode.connect(audioContext.destination);
                introSource.start(0);
                introSource.playState = 'playing';
                console.log("Intro sound started with already running AudioContext.");
            }
            showSecondScreen();
        });

        document.getElementById('startButton').addEventListener('click', () => {
            const inputName = document.getElementById('playerNameInput').value.trim();
            if (inputName) {
                playerName = inputName;
            } else {
                playerName = "Misafir";
            }
            startActuallyGame();
        });

        document.getElementById('playerNameInput').addEventListener('keydown', (e) => {
            if (e.key === 'Enter') {
                document.getElementById('startButton').click(); 
            }
        });


        function isMobileDevice() {
            return (typeof window.orientation !== "undefined") || (navigator.userAgent.indexOf('Mobi') !== -1);
        }

        function setupMobileControls() {
            const leftBtn = document.getElementById('leftBtn');
            const rightBtn = document.getElementById('rightBtn');
            const accelerateBtn = document.getElementById('accelerateBtn');
            const brakeBtn = document.getElementById('brakeBtn');
            const rocketBtn = document.getElementById('rocketBtn'); 

            const mobileControlsDiv = document.getElementById('mobileControls');
            const speedControlsDiv = document.getElementById('speedControls');
            const rocketBtnDiv = document.getElementById('rocketBtn'); 

            if (isMobileDevice()) {
                mobileControlsDiv.style.display = 'flex';
                speedControlsDiv.style.display = 'flex';
                rocketBtnDiv.style.display = 'flex'; 

                leftBtn.addEventListener('touchstart', (e) => { e.preventDefault(); mobileControls.left = true; if(keyMap['arrowleft']) keyMap['arrowleft'].classList.add('active'); }, { passive: false });
                leftBtn.addEventListener('touchend', (e) => { e.preventDefault(); mobileControls.left = false; if(keyMap['arrowleft']) keyMap['arrowleft'].classList.remove('active'); });

                rightBtn.addEventListener('touchstart', (e) => { e.preventDefault(); mobileControls.right = true; if(keyMap['arrowright']) keyMap['arrowright'].classList.add('active'); }, { passive: false });
                rightBtn.addEventListener('touchend', (e) => { e.preventDefault(); mobileControls.right = false; if(keyMap['arrowright']) keyMap['arrowright'].classList.remove('active'); });

                accelerateBtn.addEventListener('touchstart', (e) => { e.preventDefault(); mobileControls.accelerate = true; if(keyMap['arrowup']) keyMap['arrowup'].classList.add('active'); }, { passive: false });
                accelerateBtn.addEventListener('touchend', (e) => { e.preventDefault(); mobileControls.accelerate = false; if(keyMap['arrowup']) keyMap['arrowup'].classList.remove('active'); });

                brakeBtn.addEventListener('touchstart', (e) => { e.preventDefault(); mobileControls.brake = true; if(keyMap['arrowdown']) keyMap['arrowdown'].classList.add('active'); }, { passive: false });
                brakeBtn.addEventListener('touchend', (e) => { e.preventDefault(); mobileControls.brake = false; if(keyMap['arrowdown']) keyMap['arrowdown'].classList.remove('active'); });

                rocketBtn.addEventListener('touchstart', (e) => { e.preventDefault(); fireRocket(); if(keyMap['r']) keyMap['r'].classList.add('active'); }, { passive: false });
                rocketBtn.addEventListener('touchend', (e) => { e.preventDefault(); if(keyMap['r']) keyMap['r'].classList.remove('active'); });
            } else {
                mobileControlsDiv.style.display = 'none';
                speedControlsDiv.style.display = 'none';
                rocketBtnDiv.style.display = 'none'; 
            }
        }

        function createPlayerCar() {
            const carGroup = new THREE.Group();

            const bodyMaterial = new THREE.MeshStandardMaterial({
                color: 0xFF0000, 
                roughness: 0.5, 
                metalness: 0.1, 
            });
            const windowMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x000000, 
                transparent: true,
                opacity: 0.85, 
                roughness: 0.05, 
                metalness: 0.95, 
                envMapIntensity: 1.5, 
            });
            const wheelMaterial = new THREE.MeshStandardMaterial({
                color: 0x1A1A1A,
                roughness: 0.8,
                metalness: 0.5,
            });
            const playerHeadlightMaterial = new THREE.MeshStandardMaterial({
                color: 0xFFFF88,
                emissive: 0xAAAA00,
                emissiveIntensity: 0.8,
                roughness: 0.1,
                metalness: 0.0,
            });
            const playerTaillightMaterial = new THREE.MeshStandardMaterial({
                color: 0x8B0000, 
                emissive: 0xFF0000, 
                emissiveIntensity: 5.0, 
                roughness: 0.1,
                metalness: 0.0,
            });
            const frontBumperMaterial = new THREE.MeshStandardMaterial({
                color: 0x333333, 
                roughness: 0.6,
                metalness: 0.7,
            });
            const airIntakeMaterial = new THREE.MeshStandardMaterial({
                color: 0x000000, 
                roughness: 0.4,
                metalness: 0.9
            });
            const diffuserMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x111111, 
                roughness: 0.6,
                metalness: 0.8, 
            });
            const finMaterial = new THREE.MeshStandardMaterial({
                color: 0x000000,
                roughness: 0.5,
                metalness: 0.7
            });


            const bodyGeometry = new THREE.BoxGeometry(2.6, 0.5, 5.0); 
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            body.position.y = 0.25; 
            body.castShadow = true;
            carGroup.add(body);


            const carBodyTopY = 0.5; 
            const roofThickness = 0.1; 
            const roofWidth = 2.2;     

            const metalRoofDepth = 2.5; 
            const metalRoofGeometry = new THREE.BoxGeometry(roofWidth, roofThickness, metalRoofDepth);
            const metalRoof = new THREE.Mesh(metalRoofGeometry, bodyMaterial);
            metalRoof.position.set(
                0,
                carBodyTopY + (roofThickness / 2), 
                -metalRoofDepth / 2 
            );
            metalRoof.castShadow = true;
            carGroup.add(metalRoof);

            const windshieldRearY = carBodyTopY + roofThickness; 
            const windshieldRearZ = 0;                          
            const windshieldFrontY = carBodyTopY - 0.1; 
            const windshieldFrontZ = 1.8;              

            const deltaZ_ws = windshieldFrontZ - windshieldRearZ; 
            const deltaY_ws = windshieldRearY - windshieldFrontY; 

            const windshieldLengthOnSlant = Math.sqrt(deltaZ_ws * deltaZ_ws + deltaY_ws * deltaY_ws);
            const windshieldRotationX = Math.atan2(deltaY_ws, deltaZ_ws); 

            const glassThickness = 0.05; 
            const frontWindshieldGeometry = new THREE.BoxGeometry(roofWidth, glassThickness, windshieldLengthOnSlant);
            const frontWindshield = new THREE.Mesh(frontWindshieldGeometry, windowMaterial);

            frontWindshield.position.set(
                0,
                (windshieldRearY + windshieldFrontY) / 2, 
                (windshieldRearZ + windshieldFrontZ) / 2  
            );
            frontWindshield.rotation.x = windshieldRotationX;
            frontWindshield.castShadow = true; 
            carGroup.add(frontWindshield);

            const carBodyWidth = 2.6;
            const sidePanelThickness = 0.1; 
            const sideWindowThickness = 0.05; 

            const rearSidePanelDepth = 2.5; 
            const rearSidePanelHeight = carBodyTopY + roofThickness; 
            const rearSidePanelGeometry = new THREE.BoxGeometry(sidePanelThickness, rearSidePanelHeight, rearSidePanelDepth);

            const leftRearSidePanel = new THREE.Mesh(rearSidePanelGeometry, diffuserMaterial);
            leftRearSidePanel.position.set(
                -carBodyWidth / 2 - sidePanelThickness / 2, 
                rearSidePanelHeight / 2,                    
                -rearSidePanelDepth / 2                      
            );
            leftRearSidePanel.castShadow = true;
            carGroup.add(leftRearSidePanel);

            const rightRearSidePanel = new THREE.Mesh(rearSidePanelGeometry, diffuserMaterial);
            rightRearSidePanel.position.set(
                carBodyWidth / 2 + sidePanelThickness / 2,
                rearSidePanelHeight / 2,
                -rearSidePanelDepth / 2
            );
            rightRearSidePanel.castShadow = true;
            carGroup.add(rightRearSidePanel);

            const sideWindowShapeXY = new THREE.Shape();
            sideWindowShapeXY.moveTo(windshieldRearZ, sideWindowBottomY);    
            sideWindowShapeXY.lineTo(windshieldRearZ, windshieldRearY);      
            sideWindowShapeXY.lineTo(windshieldFrontZ, windshieldFrontY);    
            sideWindowShapeXY.lineTo(windshieldFrontZ, sideWindowBottomY);   
            sideWindowShapeXY.closePath();

            const sideWindowExtrudeSettings = { depth: sideWindowThickness, bevelEnabled: false };
            const sideWindowGeomXY = new THREE.ExtrudeGeometry(sideWindowShapeXY, sideWindowExtrudeSettings);

            const lsw = new THREE.Mesh(sideWindowGeomXY, windowMaterial);
            lsw.rotation.y = Math.PI / 2; 
            lsw.position.set(
                -carBodyWidth / 2, 
                0,                 
                sideWindowThickness / 2 
            );
            lsw.castShadow = true;
            carGroup.add(lsw);

            const rsw = new THREE.Mesh(sideWindowGeomXY, windowMaterial);
            rsw.rotation.y = -Math.PI / 2; 
            rsw.position.set(
                carBodyWidth / 2,  
                0,
                -sideWindowThickness / 2 
            );
            rsw.castShadow = true;
            carGroup.add(rsw);

            const wheelGeometry = new THREE.CylinderGeometry(0.5, 0.5, 0.5, 16); 
            const wheelPositions = [
                { x: -1.2, y: 0.25, z: 2.0 }, 
                { x: 1.2, y: 0.25, z: 2.0 },  
                { x: -1.2, y: 0.25, z: -2.0 },
                { x: 1.2, y: 0.25, z: -2.0 } 
            ];

            const wheelGroup = new THREE.Group();
            wheelPositions.forEach(pos => {
                const wheel = new THREE.Mesh(wheelGeometry, wheelMaterial);
                wheel.position.set(pos.x, pos.y, pos.z);
                wheel.rotation.z = Math.PI / 2;
                wheel.castShadow = true;
                wheelGroup.add(wheel);
            });
            carGroup.add(wheelGroup); 


            const headlightStripGeometry = new THREE.BoxGeometry(0.4, 0.1, 0.05);
            [-0.8, 0.8].forEach(x => {
                const headlight = new THREE.Mesh(headlightStripGeometry, playerHeadlightMaterial);
                headlight.position.set(x, 0.4, 2.4); 
                headlight.userData.isLight = true;
                carGroup.add(headlight);
            });

            const rearBumperMaterial = new THREE.MeshStandardMaterial({
                color: 0x333333, 
                roughness: 0.6,
                metalness: 0.7,
            });
            const rearBumperGeometry = new THREE.BoxGeometry(2.6, 0.25, 0.7);
            const rearBumper = new THREE.Mesh(rearBumperGeometry, rearBumperMaterial);
            rearBumper.position.set(0, 0.125, -2.6); 
            carGroup.add(rearBumper);


            const newSpoilerTaillightMaterial = new THREE.MeshStandardMaterial({
                color: 0x8B0000, 
                emissive: 0xFF0000, 
                emissiveIntensity: 5.0, 
                roughness: 0.1,
                metalness: 0.0,
            });
            const spoilerTaillightWidth = 0.15; 
            const spoilerTaillightHeight = 0.6; 
            const spoilerTaillightDepth = 0.1; 
            const spoilerTaillightSpacing = 0.1; 
            const spoilerTaillightXOffset = 1.0; 

            for (let i = 0; i < 3; i++) { 
                const taillightGeometry = new THREE.BoxGeometry(spoilerTaillightWidth, spoilerTaillightHeight, spoilerTaillightDepth);
                const taillight = new THREE.Mesh(taillightGeometry, newSpoilerTaillightMaterial); 
                taillight.position.set(
                    -(spoilerTaillightXOffset), 
                    1.15 + (0.2 - i * spoilerTaillightSpacing), 
                    -2.8 
                );
                taillight.userData.isLight = true;
                spoilerTaillights.push(taillight); 
                carGroup.add(taillight);
            }
            for (let i = 0; i < 3; i++) { 
                const taillightGeometry = new THREE.BoxGeometry(spoilerTaillightWidth, spoilerTaillightHeight, spoilerTaillightDepth);
                const taillight = new THREE.Mesh(taillightGeometry, newSpoilerTaillightMaterial);
                taillight.position.set(
                    (spoilerTaillightXOffset), 
                    1.15 + (0.2 - i * spoilerTaillightSpacing), 
                    -2.8 
                );
                taillight.userData.isLight = true;
                spoilerTaillights.push(taillight); 
                carGroup.add(taillight);
            }

            const f1BrakeLightGeometry = new THREE.BoxGeometry(0.5, 0.2, 0.1); 
            const f1BrakeLightMaterial = new THREE.MeshStandardMaterial({
                color: 0xFF0000, 
                emissive: 0xFF0000,
                emissiveIntensity: 0.0, 
                roughness: 0.1,
                metalness: 0.0,
            });
            brakeLightMesh = new THREE.Mesh(f1BrakeLightGeometry, f1BrakeLightMaterial);
            brakeLightMesh.position.set(0, 0.05, -2.6); 
            brakeLightMesh.userData.isBrakeLight = true;
            carGroup.add(brakeLightMesh);

            const frontBumperGeometry = new THREE.BoxGeometry(2.6, 0.25, 0.7);
            const frontBumper = new THREE.Mesh(frontBumperGeometry, frontBumperMaterial);
            frontBumper.position.set(0, 0.125, 2.6); 
            carGroup.add(frontBumper);

            const airIntakeGeometry = new THREE.BoxGeometry(0.9, 0.15, 0.1);
            const airIntakeLeft = new THREE.Mesh(airIntakeGeometry, airIntakeMaterial);
            airIntakeLeft.position.set(-0.8, 0.125, 2.65); 
            carGroup.add(airIntakeLeft);
            const airIntakeRight = new THREE.Mesh(airIntakeGeometry, airIntakeMaterial);
            airIntakeRight.position.set(0.8, 0.125, 2.65); 
            carGroup.add(airIntakeRight);
            const centerAirIntakeGeometry = new THREE.BoxGeometry(0.7, 0.12, 0.1);
            const centerAirIntake = new THREE.Mesh(centerAirIntakeGeometry, airIntakeMaterial);
            centerAirIntake.position.set(0, 0.125, 2.65); 
            carGroup.add(centerAirIntake);


            const diffuserMainGeometry = new THREE.BoxGeometry(2.0, 0.3, 1.2);
            const diffuserMain = new THREE.Mesh(diffuserMainGeometry, diffuserMaterial);
            diffuserMain.position.set(0, -0.05, -2.6); 
            carGroup.add(diffuserMain);

            const grilleStripMaterial = new THREE.MeshStandardMaterial({ color: 0x000000, roughness: 0.5, metalness: 0.9 });
            const numStrips = 5;
            const stripWidth = 0.1;
            const stripSpacing = (2.0 - (numStrips * stripWidth)) / (numStrips + 1);
            for (let i = 0; i < numStrips; i++) {
                const strip = new THREE.Mesh(new THREE.BoxGeometry(stripWidth, 0.25, 1.0), grilleStripMaterial);
                strip.position.set(
                    -1.0 + (i * (stripWidth + stripSpacing)) + stripWidth / 2 + stripSpacing,
                    -0.05, 
                    -2.6 
                );
                carGroup.add(strip);
            }

            const finGeometry = new THREE.BoxGeometry(0.18, 0.6, 0.7);
            const fin1 = new THREE.Mesh(finGeometry, finMaterial);
            fin1.position.set(-0.7, 0.1, -2.5); 
            fin1.rotation.y = Math.PI / 6;
            carGroup.add(fin1);
            const fin2 = new THREE.Mesh(finGeometry, finMaterial);
            fin2.position.set(0.7, 0.1, -2.5); 
            fin2.rotation.y = -Math.PI / 6;
            carGroup.add(fin2);

            const exhaustGeometry = new THREE.CylinderGeometry(0.2, 0.2, 0.4, 8);
            const exhaustMaterial = new THREE.MeshStandardMaterial({ color: 0x333333, roughness: 0.3, metalness: 0.9 });
            const exhaust1 = new THREE.Mesh(exhaustGeometry, exhaustMaterial);
            exhaust1.position.set(-0.9, -0.05, -2.6); 
            exhaust1.rotation.x = Math.PI / 2;
            carGroup.add(exhaust1);
            const exhaust2 = new THREE.Mesh(exhaustGeometry, exhaustMaterial);
            exhaust2.position.set(0.9, -0.05, -2.6); 
            exhaust2.rotation.x = Math.PI / 2;
            carGroup.add(exhaust2);

            const spoilerSupportGeometry = new THREE.BoxGeometry(0.15, 0.8, 0.15); 
            const spoilerSupportMaterial = new THREE.MeshStandardMaterial({ color: 0x222222, roughness: 0.6, metalness: 0.7 });
            const leftSupport = new THREE.Mesh(spoilerSupportGeometry, spoilerSupportMaterial);
            leftSupport.position.set(-1.1, 0.8, -2.5); 
            carGroup.add(leftSupport);
            const rightSupport = new THREE.Mesh(spoilerSupportGeometry, spoilerSupportMaterial);
            rightSupport.position.set(1.1, 0.8, -2.5); 
            carGroup.add(rightSupport);

            const spoilerWingMaterial = new THREE.MeshStandardMaterial({
                color: 0x000000, 
                roughness: 0.4,
                metalness: 0.8
            });
            const spoilerWingGeometry = new THREE.BoxGeometry(2.6, 0.15, 0.6); 
            const spoilerWing = new THREE.Mesh(spoilerWingGeometry, spoilerWingMaterial);
            spoilerWing.position.set(0, 1.25, -2.7); 
            spoilerWing.rotation.x = -Math.PI / 10;
            carGroup.add(spoilerWing);

            const cutGeometry = new THREE.BoxGeometry(2.0, 0.05, 0.05); 
            const cutMaterial = new THREE.MeshBasicMaterial({ color: 0x111111 }); 
            for (let i = 0; i < 3; i++) {
                const cut = new THREE.Mesh(cutGeometry, cutMaterial);
                cut.position.set(
                    0,
                    1.25 + (0.1 - i * 0.07), 
                    -2.7 
                );
                carGroup.add(cut);
            }

            car = carGroup;
            car.rotation.y = Math.PI; 
            scene.add(car);
            car.position.z = -5; 
        }


        function createPlayerHeadlight() {
            playerHeadlight = new THREE.SpotLight(0xFFFFFF, 0, 100, Math.PI / 8, 0.5, 2);
            playerHeadlight.position.set(0, 1.0, 2.5); 
            playerHeadlight.target = new THREE.Object3D();
            playerHeadlight.target.position.set(0, 0.5, 50); 

            car.add(playerHeadlight); 
            car.add(playerHeadlight.target); 

            playerHeadlight.castShadow = true;
            playerHeadlight.shadow.mapSize.width = 512;
            playerHeadlight.shadow.mapSize.height = 512;
            playerHeadlight.shadow.camera.near = 0.1;
            playerHeadlight.shadow.camera.far = 100;
        }

        function createRoad() {
            const roadMaterial = new THREE.MeshStandardMaterial({
                color: 0xBBBBBB,
                roughness: 0.8,
                metalness: 0.1,
            });

            for (let i = 0; i < 30; i++) {
                const roadGeometry = new THREE.PlaneGeometry(roadWidth, 20);
                const roadSegment = new THREE.Mesh(roadGeometry, roadMaterial);
                roadSegment.rotation.x = -Math.PI / 2;
                roadSegment.position.z = i * 20 - 200;
                roadSegment.receiveShadow = true;
                scene.add(roadSegment);
                road.push(roadSegment);

                const dashedLineGeometry = new THREE.PlaneGeometry(0.4, 8);
                const lineMaterial = new THREE.MeshPhongMaterial({ color: 0xAAAAAA, emissive: 0x444444, emissiveIntensity: 1.5 });

                const laneDivider1X = -laneWidth / 2;
                const laneDivider2X = laneWidth / 2;

                [laneDivider1X, laneDivider2X].forEach(xOffset => {
                    for (let j = 0; j < 3; j++) {
                        const dashedLine = new THREE.Mesh(dashedLineGeometry, lineMaterial);
                        dashedLine.rotation.x = -Math.PI / 2;
                        dashedLine.position.set(xOffset, 0.01, (i * 20 - 200) + (j * 8 - 8));
                        dashedLine.userData.isRoadLine = true;
                        scene.add(dashedLine);
                        road.push(dashedLine);
                    }
                });
            }
        }

        function createRoadside() {
            const grassMaterial = new THREE.MeshStandardMaterial({
                color: 0x4CAF50,
                roughness: 0.9,
                metalness: 0.0
            });

            for (let i = 0; i < 30; i++) {
                const zPos = i * 20 - 200;

                const leftRoadsideGeometry = new THREE.PlaneGeometry(roadsideWidth, 20);
                const leftRoadside = new THREE.Mesh(leftRoadsideGeometry, grassMaterial);
                leftRoadside.rotation.x = -Math.PI / 2;
                leftRoadside.position.set(-(roadWidth / 2) - (roadsideWidth / 2), -0.01, zPos);
                leftRoadside.receiveShadow = true;
                scene.add(leftRoadside);
                road.push(leftRoadside);

                const rightRoadsideGeometry = new THREE.PlaneGeometry(roadsideWidth, 20);
                const rightRoadside = new THREE.Mesh(rightRoadsideGeometry, grassMaterial);
                rightRoadside.rotation.x = -Math.PI / 2;
                rightRoadside.position.set((roadWidth / 2) + (roadsideWidth / 2), -0.01, zPos);
                rightRoadside.receiveShadow = true;
                scene.add(rightRoadside);
                road.push(rightRoadside);
            }
        }

        function createBarriers() {
            const barrierHeight = 1;
            const barrierWidth = 0.5;
            const barrierMaterial = new THREE.MeshStandardMaterial({
                color: 0x555555,
                roughness: 0.7,
                metalness: 0.3
            });
            const barrierStripeMaterial = new THREE.MeshPhongMaterial({ color: 0xFF6600, emissive: 0xFF8800, emissiveIntensity: 2.0 });

            const barrierLeftX = -(roadWidth / 2) - (barrierWidth / 2);
            const barrierRightX = (roadWidth / 2) + (barrierWidth / 2);

            for (let i = 0; i < 30; i++) {
                const zPos = i * 20 - 200;

                const leftBarrier = new THREE.Mesh(new THREE.BoxGeometry(barrierWidth, barrierHeight, 20), barrierMaterial);
                leftBarrier.position.set(barrierLeftX, barrierHeight / 2, zPos);
                leftBarrier.castShadow = true;
                leftBarrier.receiveShadow = true;
                scene.add(leftBarrier);
                barriers.push(leftBarrier);

                for (let k = 0; k < 5; k++) {
                    const stripe = new THREE.Mesh(new THREE.BoxGeometry(barrierWidth + 0.01, barrierHeight + 0.01, 2), barrierStripeMaterial);
                    stripe.position.set(barrierLeftX, barrierHeight / 2, zPos - 10 + k * 4);
                    stripe.userData.isBarrierStripe = true;
                    scene.add(stripe);
                    barriers.push(stripe);
                }

                const rightBarrier = new THREE.Mesh(new THREE.BoxGeometry(barrierWidth, barrierHeight, 20), barrierMaterial);
                rightBarrier.position.set(barrierRightX, barrierHeight / 2, zPos);
                rightBarrier.castShadow = true;
                rightBarrier.receiveShadow = true;
                scene.add(rightBarrier);
                barriers.push(rightBarrier);

                for (let k = 0; k < 5; k++) {
                    const stripe = new THREE.Mesh(new THREE.BoxGeometry(barrierWidth + 0.01, barrierHeight + 0.01, 2), barrierStripeMaterial);
                    stripe.position.set(barrierRightX, barrierHeight / 2, zPos - 10 + k * 4);
                    stripe.userData.isBarrierStripe = true;
                    scene.add(stripe);
                    barriers.push(stripe);
                }
            }
        }

        function createTrafficCar(color, type = 'sedan', isPolice = false) {
            const carGroup = new THREE.Group();
            let bodyGeometry, roofGeometry, cabGeometry;
            let wheelPositions;
            let carLength;
            let bodyYPosition;

            const bodyMaterial = new THREE.MeshStandardMaterial({
                color: color,
                roughness: 0.6,
                metalness: 0.1
            });
            const windowMaterial = new THREE.MeshStandardMaterial({
                color: 0x99DDFf,
                transparent: true,
                opacity: 0.7,
                roughness: 0.3,
                metalness: 0.0
            });
            const wheelMaterial = new THREE.MeshStandardMaterial({
                color: 0x1A1A1A,
                roughness: 0.8,
                metalness: 0.6
            });
            const trafficHeadlightMaterial = new THREE.MeshStandardMaterial({
                color: 0xFFFF88,
                emissive: 0xCCCC00,
                emissiveIntensity: 1.0,
                roughness: 0.1
            });
            const trafficTaillightMaterial = new THREE.MeshStandardMaterial({
                color: 0xFF0000,
                emissive: 0xAA0000,
                emissiveIntensity: 1.0,
                roughness: 0.1
            });

            switch (type) {
                case 'sedan':
                    bodyGeometry = new THREE.BoxGeometry(1.9, 0.9, 4.0);
                    roofGeometry = new THREE.BoxGeometry(1.7, 0.7, 2.2);
                    wheelPositions = [
                        { x: -1.05, y: 0.35, z: 1.6 },
                        { x: 1.05, y: 0.35, z: 1.6 },
                        { x: -1.05, y: 0.35, z: -1.6 },
                        { x: 1.05, y: 0.35, z: -1.6 }
                    ];
                    carLength = 4.0;
                    bodyYPosition = 0.45;
                    break;
                case 'truck':
                    bodyGeometry = new THREE.BoxGeometry(2.2, 1.2, 6.5);
                    cabGeometry = new THREE.BoxGeometry(2.0, 1.5, 2.5);
                    wheelPositions = [
                        { x: -1.0, y: 0.6, z: 2.8 },
                        { x: 1.0, y: 0.6, z: 2.8 },
                        { x: -1.0, y: 0.6, z: -2.8 },
                        { x: 1.0, y: 0.6, z: -2.8 }
                    ];
                    carLength = 6.5;
                    bodyYPosition = 0.6;
                    break;
                case 'sport': 
                    bodyGeometry = new THREE.BoxGeometry(1.8, 0.6, 3.8);
                    roofGeometry = new THREE.BoxGeometry(1.6, 0.4, 1.5);
                    wheelPositions = [
                        { x: -1.1, y: 0.2, z: 1.4 },
                        { x: 1.1, y: 0.2, z: 1.4 },
                        { x: -1.1, y: 0.2, z: -1.4 },
                        { x: 1.1, y: 0.2, z: -1.4 }
                    ];
                    carLength = 3.8;
                    bodyYPosition = 0.3;

                    if (isPolice) {
                        bodyMaterial.color.set(0x000000);
                        
                        const policeLightGroup = new THREE.Group();
                        const lightBarGeometry = new THREE.BoxGeometry(1.2, 0.2, 0.3); 
                        const lightBarMesh = new THREE.Mesh(lightBarGeometry, new THREE.MeshStandardMaterial({color: 0x333333, roughness: 0.5, metalness: 0.8}));
                        lightBarMesh.position.y = 0.6; 
                        policeLightGroup.add(lightBarMesh);

                        const redLightBulb = new THREE.Mesh(new THREE.SphereGeometry(0.1, 8, 8), new THREE.MeshBasicMaterial({ color: 0xFF0000 }));
                        redLightBulb.position.set(-0.3, 0.6, 0.1); 
                        policeLightGroup.add(redLightBulb);

                        const blueLightBulb = new THREE.Mesh(new THREE.SphereGeometry(0.1, 8, 8), new THREE.MeshBasicMaterial({ color: 0x0000FF }));
                        blueLightBulb.position.set(0.3, 0.6, 0.1); 
                        policeLightGroup.add(blueLightBulb);
                        
                        const polisTextGeometry = new THREE.PlaneGeometry(1.2, 0.4); 
                        const polisTextMaterial = new THREE.MeshBasicMaterial({ color: 0xFFFFFF, side: THREE.DoubleSide }); 
                        const polisTextPlane = new THREE.Mesh(polisTextGeometry, polisTextMaterial);
                        polisTextPlane.position.set(0, 0.8, 2.0); 
                        polisTextPlane.rotation.x = Math.PI / 2; 
                        carGroup.add(polisTextPlane);

                        policeLightGroup.userData.redLightBulb = redLightBulb;
                        policeLightGroup.userData.blueLightBulb = blueLightBulb;
                        policeLightGroup.userData.lightState = 0; 

                        policeLightGroup.position.set(0, bodyYPosition + 0.5, 0); 
                        carGroup.add(policeLightGroup);

                        carGroup.userData.policeLightGroup = policeLightGroup; 
                    }
                    break;
                case 'minivan':
                    bodyGeometry = new THREE.BoxGeometry(2.1, 1.4, 4.5);
                    roofGeometry = new THREE.BoxGeometry(1.9, 1.1, 2.8);
                    wheelPositions = [
                        { x: -1.15, y: 0.6, z: 1.8 },
                        { x: 1.15, y: 0.6, z: 1.8 },
                        { x: -1.15, y: 0.6, z: -1.8 },
                        { x: 1.15, y: 0.6, z: -1.8 }
                    ];
                    carLength = 4.5;
                    bodyYPosition = 0.7;
                    break;
                case 'bus':
                    bodyGeometry = new THREE.BoxGeometry(2.8, 2.2, 9.0);
                    wheelPositions = [
                        { x: -1.2, y: 1.0, z: 3.5 },
                        { x: 1.2, y: 1.0, z: 3.5 },
                        { x: -1.2, y: 1.0, z: -3.5 },
                        { x: 1.2, y: 1.0, z: -3.5 }
                    ];
                    carLength = 9.0;
                    bodyYPosition = 1.1;
                    break;
                default: // sedan as default
                    bodyGeometry = new THREE.BoxGeometry(1.9, 0.9, 4.0);
                    roofGeometry = new THREE.BoxGeometry(1.7, 0.7, 2.2);
                    wheelPositions = [
                        { x: -1.05, y: 0.35, z: 1.6 },
                        { x: 1.05, y: 0.35, z: 1.6 },
                        { x: -1.05, y: 0.35, z: -1.6 },
                        { x: 1.05, y: 0.35, z: -1.6 }
                    ];
                    carLength = 4.0;
                    bodyYPosition = 0.45;
                    break;
            }

            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            body.position.y = bodyYPosition;
            body.castShadow = true;
            carGroup.add(body);

            if (type === 'sedan' || type === 'minivan') {
                const roof = new THREE.Mesh(roofGeometry, bodyMaterial);
                roof.position.y = bodyYPosition + (bodyGeometry.parameters.height / 2) + (roofGeometry.parameters.height / 2) - 0.2;
                roof.position.z = bodyGeometry.parameters.depth / 2 - roofGeometry.parameters.depth / 2 - (type === 'minivan' ? 0.3 : 0.5);
                roof.castShadow = true;
                carGroup.add(roof);

                const windowGeom = new THREE.BoxGeometry(roofGeometry.parameters.width * 0.9, roofGeometry.parameters.height * 0.8, roofGeometry.parameters.depth * 0.9);
                const frontWindow = new THREE.Mesh(windowGeom, windowMaterial);
                frontWindow.position.set(0, roof.position.y, roof.position.z + roofGeometry.parameters.depth / 4);
                carGroup.add(frontWindow);

                const rearWindow = new THREE.Mesh(windowGeom, windowMaterial);
                rearWindow.position.set(0, roof.position.y, roof.position.z - roofGeometry.parameters.depth / 4);
                carGroup.add(rearWindow);

            } else if (type === 'sport' && !isPolice) { 
                const sportCabGeometry = new THREE.BoxGeometry(1.6, 0.5, 2.0);
                const sportCab = new THREE.Mesh(sportCabGeometry, bodyMaterial);
                sportCab.position.y = bodyYPosition + 0.5;
                sportCab.position.z = 0;
                sportCab.castShadow = true;
                carGroup.add(sportCab);

                const spoilerGeometry = new THREE.BoxGeometry(1.5, 0.1, 0.3);
                const spoiler = new THREE.Mesh(spoilerGeometry, bodyMaterial);
                spoiler.position.set(0, bodyYPosition + 0.8, -bodyGeometry.parameters.depth / 2 - 0.1);
                spoiler.castShadow = true;
                carGroup.add(spoiler);

            } else if (type === 'truck') {
                const cab = new THREE.Mesh(cabGeometry, bodyMaterial);
                cab.position.y = bodyYPosition + (bodyGeometry.parameters.height / 2) + (cabGeometry.parameters.height / 2) - 0.6;
                cab.position.z = bodyGeometry.parameters.depth / 2 - cabGeometry.parameters.depth / 2 + 1;
                cab.castShadow = true;
                carGroup.add(cab);
            }

            const wheelGeometry = new THREE.CylinderGeometry(0.4, 0.4, 0.35, 16);
            wheelPositions.forEach(pos => {
                const wheel = new THREE.Mesh(wheelGeometry, wheelMaterial);
                wheel.position.set(pos.x, pos.y, pos.z);
                wheel.rotation.z = Math.PI / 2;
                wheel.castShadow = true;
                carGroup.add(wheel);
            });

            const generalHeadlightMaterial = trafficHeadlightMaterial;
            const generalTaillightMaterial = trafficTaillightMaterial;

            if (type === 'sedan' || type === 'sport' || type === 'minivan') {
                const headlightStripGeometry = new THREE.BoxGeometry(0.3, 0.1, 0.05);
                [-0.7, 0.7].forEach(x => {
                    const headlight = new THREE.Mesh(headlightStripGeometry, generalHeadlightMaterial);
                    headlight.position.set(x, bodyYPosition + 0.2, bodyGeometry.parameters.depth / 2 - 0.05);
                    headlight.userData.isLight = true;
                    carGroup.add(headlight);
                });

                const taillightStripGeometry = new THREE.BoxGeometry(0.3, 0.1, 0.05);
                [-0.7, 0.7].forEach(x => {
                    const taillight = new THREE.Mesh(taillightStripGeometry, generalTaillightMaterial);
                    taillight.position.set(x, bodyYPosition + 0.2, -bodyGeometry.parameters.depth / 2 + 0.05);
                    taillight.userData.isLight = true;
                    carGroup.add(taillight);
                });
            } else if (type === 'truck') {
                const headlightGeometry = new THREE.BoxGeometry(0.3, 0.2, 0.1);
                [-0.7, 0.7].forEach(x => {
                    const headlight = new THREE.Mesh(headlightGeometry, generalHeadlightMaterial);
                    headlight.position.set(x, bodyYPosition + 1.0, (bodyGeometry.parameters.depth / 2) + 0.5);
                    headlight.userData.isLight = true;
                    carGroup.add(headlight);
                });
                const taillightGeometry = new THREE.BoxGeometry(0.5, 0.2, 0.1);
                [-0.7, 0.7].forEach(x => {
                    const taillight = new THREE.Mesh(taillightGeometry, generalTaillightMaterial);
                    taillight.position.set(x, bodyYPosition + 0.2, -(bodyGeometry.parameters.depth / 2) - 0.05);
                    taillight.userData.isLight = true;
                    carGroup.add(taillight);
                });
            } else if (type === 'bus') {
                const headlightGeometry = new THREE.BoxGeometry(0.6, 0.3, 0.1);
                [-0.9, 0.9].forEach(x => {
                    const headlight = new THREE.Mesh(headlightGeometry, generalHeadlightMaterial);
                    headlight.position.set(x, bodyYPosition + 1.2, bodyGeometry.parameters.depth / 2 - 0.1);
                    headlight.userData.isLight = true;
                    carGroup.add(headlight);
                });
                 const taillightGeometry = new THREE.BoxGeometry(0.8, 0.4, 0.1);
                [-0.9, 0.9].forEach(x => {
                    const taillight = new THREE.Mesh(taillightGeometry, generalTaillightMaterial);
                    taillight.position.set(x, bodyYPosition + 0.4, -(bodyGeometry.parameters.depth / 2) + 0.05);
                    taillight.userData.isLight = true;
                    carGroup.add(taillight);
                });
            }

            return { car: carGroup, length: carLength };
        }

        function createInitialTrafficCars(count) {
            for (let i = 0; i < count; i++) {
                let newCar = getPooledTrafficCar();
                if (newCar) {
                    const lane = lanes[Math.floor(Math.random() * lanes.length)];
                    const zPos = -150 - (i * (Math.random() * 40 + 40));

                    newCar.position.set(lane, 0, zPos);
                    newCar.rotation.y = Math.PI; 
                    newCar.userData.currentLane = lane;
                    newCar.userData.targetLane = lane;
                    newCar.userData.isChangingLane = false;
                    newCar.userData.wander = (Math.random() - 0.5) * 0.5;
                    newCar.userData.wanderTarget = (Math.random() - 0.5) * 0.5;
                    newCar.visible = true;
                    trafficCars.push(newCar);
                }
            }
        }

        function getPooledTrafficCar() {
            let car = pooledTrafficCars.find(pCar => !pCar.visible);
            if (!car) {
                const colors = [0x00FF00, 0x0000FF, 0xFFFF00, 0xFF00FF, 0x00FFFF, 0xFF8C00, 0x8A2BE2, 0x00CED1, 0xFF69B4, 0x4B0082, 0xADFF2F, 0xFFD700];
                const types = ['sedan', 'truck', 'minivan', 'bus'];
                const color = colors[Math.floor(Math.random() * colors.length)];
                const type = types[Math.floor(Math.random() * types.length)];
                const { car: newCar, length } = createTrafficCar(color, type);
                newCar.userData.isPooled = true;
                newCar.userData.length = length;
                newCar.userData.type = type;
                newCar.userData.isPolice = false;
                newCar.userData.currentLane = 0;
                newCar.userData.targetLane = 0;
                newCar.userData.isChangingLane = false;
                newCar.userData.wander = 0;
                newCar.userData.wanderTarget = 0;
                newCar.userData.lastX = 0;
                newCar.userData.trafficCollisions = 0;
                scene.add(newCar);
                pooledTrafficCars.push(newCar);
                car = newCar;
            }
            return car;
        }

        function releasePooledTrafficCar(car) {
            car.visible = false;
            car.position.set(0, 0, -1000); 
        }


        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function onKeyDown(e) {
            if (e.key) {
                const lowerKey = e.key.toLowerCase();
                keys[lowerKey] = true;

                if (keyMap[lowerKey]) {
                    keyMap[lowerKey].classList.add('active');
                } else if (lowerKey === 'arrowup' && keyMap['arrowup']) {
                    keyMap['arrowup'].classList.add('active');
                } else if (lowerKey === 'arrowdown' && keyMap['arrowdown']) {
                    keyMap['arrowdown'].classList.add('active');
                } else if (lowerKey === 'arrowleft' && keyMap['arrowleft']) {
                    keyMap['arrowleft'].classList.add('active');
                } else if (lowerKey === 'arrowright' && keyMap['arrowright']) {
                    keyMap['arrowright'].classList.add('active');
                }
            }
            if ((e.key === 'arrowdown' || e.key === 's') && gameRunning) {
                if (brakeLightMesh) {
                    brakeLightMesh.material.emissiveIntensity = 5.0; 
                    brakeLightMesh.material.needsUpdate = true;
                }
                if (carSpeed > 5 && (!window.currentBrakeSound || window.currentBrakeSound.playState !== 'playing')) {
                    window.currentBrakeSound = playSound(brakeBuffer, THREE.MathUtils.mapLinear(carSpeed, 0, maxSpeed, 0.2, 0.8), true);
                } else if (window.currentBrakeSound) {
                    window.currentBrakeSound.gainNode.gain.setValueAtTime(THREE.MathUtils.mapLinear(carSpeed, 0, maxSpeed, 0.2, 0.8), audioContext.currentTime);
                }
            }
            if ((e.key === 'r' || e.key === 'R') && gameRunning) {
                fireRocket();
            }
        }

        function onKeyUp(e) {
            if (e.key) {
                const lowerKey = e.key.toLowerCase();
                keys[lowerKey] = false;

                if (keyMap[lowerKey]) {
                    keyMap[lowerKey].classList.remove('active');
                } else if (lowerKey === 'arrowup' && keyMap['arrowup']) {
                    keyMap['arrowup'].classList.remove('active');
                } else if (lowerKey === 'arrowdown' && keyMap['arrowdown']) {
                    keyMap['arrowdown'].classList.remove('active');
                } else if (lowerKey === 'arrowleft' && keyMap['arrowleft']) {
                    keyMap['arrowleft'].classList.remove('active');
                } else if (lowerKey === 'arrowright' && keyMap['arrowright']) {
                    keyMap['arrowright'].classList.remove('active');
                }
            }
            if (window.currentBrakeSound) {
                window.currentBrakeSound.stop();
                window.currentBrakeSound = null;
            }
            if (brakeLightMesh) {
                brakeLightMesh.material.emissiveIntensity = 0.0;
                brakeLightMesh.material.needsUpdate = true;
            }
        }

        function startActuallyGame() {
            console.log("startActuallyGame called.");
            if (introGainNode) {
                introGainNode.gain.setValueAtTime(0.0, audioContext.currentTime); // Intro müziğini yavaşça kıs
            }
            startEngineSound(); // Motor sesini başlat
            startCountdown(); // Geri sayımı başlat
        }

        function startCountdown() {
            hideAllScreensForGame();
            const countdownOverlay = document.getElementById('countdownOverlay');
            countdownOverlay.style.display = 'block';
            let count = 3;

            const countdownInterval = setInterval(() => {
                if (count > 0) {
                    countdownOverlay.textContent = count;
                    countdownOverlay.style.animation = 'none'; // Reset animation
                    void countdownOverlay.offsetWidth; // Trigger reflow
                    countdownOverlay.style.animation = 'countdownFade 1s ease-out forwards';
                    count--;
                } else {
                    clearInterval(countdownInterval);
                    countdownOverlay.textContent = 'GO!';
                    countdownOverlay.style.animation = 'none'; // Reset animation
                    void countdownOverlay.offsetWidth; // Trigger reflow
                    countdownOverlay.style.animation = 'countdownFade 1s ease-out forwards';
                    setTimeout(() => {
                        countdownOverlay.style.display = 'none';
                        startGame(); // Oyunun gerçek başlangıcı
                    }, 800); // "GO!" animasyonu bitince oyunu başlat
                }
            }, 1000);
        }

        function startGame() {
            console.log("startGame called.");

            gameRunning = true;
            gameStarted = true;
            score = 0;
            distance = 0;
            level = 1;
            combo = 0;
            highCombo = 0;
            carSpeed = 0;
            roadSpeed = 0.5;
            carTilt = 0;
            rockets = 0; 
            trafficCarsDestroyedByRocket = 0; 
            rocketsFiredCount = 0; 
            health = 100;
            updateHealthBar();
            document.getElementById('rocketsDisplay').textContent = rockets;
            lastPoliceCarDespawnTime = 0;
            policeDifficultyMultiplier = 1.0;
            nextRadarSpawnDistance = 0;

            policeDamageStartTime = 0;
            currentPoliceChaseDamage = 0;
            lastPoliceIncrementalDamageTime = 0;

            car.position.set(0, 0, -5);
            car.rotation.y = Math.PI; 
            car.rotation.z = 0; 

            car.children.forEach(child => {
                if (child.isGroup && child.children.some(grandchild => grandchild.geometry instanceof THREE.CylinderGeometry)) {
                    child.rotation.z = 0; 
                }
            });

            if (brakeLightMesh) {
                brakeLightMesh.material.emissiveIntensity = 0.0;
                brakeLightMesh.material.needsUpdate = true;
            }
            spoilerTaillights.forEach(light => {
                if (light && light.material) {
                    light.material.emissiveIntensity = 5.0; 
                    light.material.needsUpdate = true;
                }
            });


            if (window.currentBrakeSound) {
                window.currentBrakeSound.stop();
                window.currentBrakeSound = null;
            }
            if (activePoliceCar && activePoliceCar.userData.sirenSource) {
                activePoliceCar.userData.sirenSource.stop();
                activePoliceCar.userData.sirenSource.disconnect();
                activePoliceCar.userData.sirenSource = null;
                activePoliceCar.userData.sirenGainNode = null;
            }

            trafficCars.forEach(car => releasePooledTrafficCar(car));
            trafficCars = [];
            policeCarsPool.forEach(pCar => pCar.visible = false); 

            createInitialTrafficCars(15); 


            roadsideElements.forEach(obj => scene.remove(obj));
            roadsideElements = [];
            radarPoles.forEach(obj => scene.remove(obj));
            radarPoles = [];
            createInitialRoadsideElements(10);

            rocketPowerUps.forEach(powerUp => scene.remove(powerUp)); 
            rocketPowerUps = []; 
            lastRocketPowerUpSpawnTime = Date.now(); 

            if (activeRocket) {
                scene.remove(activeRocket);
                activeRocket = null;
            }
            rocketParticles.forEach(p => scene.remove(p));
            rocketParticles = [];

            // Konsolu belirli bir süre sonra gizle
            if (cockpitConsole) {
                setTimeout(() => {
                    cockpitConsole.style.bottom = '-200px'; 
                    cockpitConsole.style.opacity = '0'; 
                    cockpitConsole.style.pointerEvents = 'none'; 
                }, 5000); 
            }

            if (!animationFrameId) {
                animationFrameId = requestAnimationFrame(update);
            }
        }

        function getPooledPoliceCar() {
            let policeCar = policeCarsPool.find(car => !car.visible);
            if (policeCar) {
                policeCar.visible = true;
            } else {
                const { car: newPoliceCar, length } = createTrafficCar(0x000000, 'sport', true);
                newPoliceCar.userData.isPooled = true;
                newPoliceCar.userData.length = length;
                newPoliceCar.userData.type = 'sport';
                newPoliceCar.userData.isPolice = true;
                newPoliceCar.userData.currentLane = 0;
                newPoliceCar.userData.targetLane = 0;
                newPoliceCar.userData.isChangingLane = false;
                newPoliceCar.userData.wander = 0;
                newPoliceCar.userData.wanderTarget = 0;
                newPoliceCar.userData.lastX = 0;
                newPoliceCar.userData.trafficCollisions = 0;
                scene.add(newPoliceCar);
                policeCarsPool.push(newPoliceCar);
                policeCar = newPoliceCar;
            }
            policeCar.userData.policeStartTime = Date.now();
            policeCar.userData.isChangingLane = false;
            policeCar.userData.wander = 0;
            policeCar.userData.wanderTarget = 0;
            policeCar.userData.lastSpeedSample = carSpeed;
            policeCar.userData.trafficCollisions = 0;
            return policeCar;
        }

        function releasePooledPoliceCar(policeCar) {
            policeCar.visible = false;
            policeCar.position.set(0, 0, -1000);
            if (policeCar.userData.policeLightGroup) {
                 policeCar.userData.policeLightGroup.userData.redLightBulb.material.emissiveIntensity = 0;
                 policeCar.userData.policeLightGroup.userData.blueLightBulb.material.emissiveIntensity = 0;
                 policeCar.userData.policeLightGroup.userData.lightState = 0;
            }
            if (policeCar.userData.sirenSource) {
                policeCar.userData.sirenSource.stop();
                policeCar.userData.sirenSource.disconnect();
                policeCar.userData.sirenSource = null;
                policeCar.userData.sirenGainNode = null;
            }
        }

        function gameOver() {
            gameRunning = false;
            cancelAnimationFrame(animationFrameId);
            animationFrameId = null;

            if (engineSource) {
                engineSource.stop();
                engineSource.disconnect();
                engineSource = null;
                engineGainNode = null;
            }
            if (activePoliceCar && activePoliceCar.userData.sirenSource) {
                activePoliceCar.userData.sirenSource.stop();
                activePoliceCar.userData.sirenSource.disconnect();
                activePoliceCar.userData.sirenSource = null;
                activePoliceCar.userData.sirenGainNode = null;
            }
            if (window.currentBrakeSound) {
                window.currentBrakeSound.stop();
                window.currentBrakeSound = null;
            }
            if (brakeLightMesh) {
                brakeLightMesh.material.emissiveIntensity = 0.0;
                brakeLightMesh.material.needsUpdate = true;
            }
            spoilerTaillights.forEach(light => {
                if (light && light.material) {
                    light.material.emissiveIntensity = 0.0; 
                    light.material.needsUpdate = true;
                }
            });
            
            if (introBuffer && introGainNode) {
                introGainNode.gain.setValueAtTime(0.9, audioContext.currentTime); 
                if (introSource && introSource.playState !== 'playing') {
                    introSource.start(0);
                    introSource.playState = 'playing';
                }
                console.log("Intro sound started after game over.");
            } else if (introBuffer && audioContext) { 
                introSource = audioContext.createBufferSource();
                introSource.buffer = introBuffer;
                introSource.loop = true;
                introGainNode = audioContext.createGain();
                introGainNode.gain.setValueAtTime(0.9, audioContext.currentTime);
                introSource.connect(introGainNode);
                introGainNode.connect(audioContext.destination);
                introSource.start(0);
                introSource.playState = 'playing';
                console.log("Intro sound started after game over (new source).");
            } else {
                console.error("Intro sound buffer not loaded.");
            }


            document.getElementById('finalScore').textContent = score;
            document.getElementById('finalDistance').textContent = Math.floor(distance);
            document.getElementById('maxCombo').textContent = highCombo;
            document.getElementById('gameOver').style.display = 'block';

            setTimeout(() => {
                document.getElementById('gameOver').style.display = 'none';
                showFirstScreen(); 
            }, 1000);
        }

        function createExplosion(x, y, z) {
            const particleCount = 100;
            const particles = new THREE.BufferGeometry();
            const positions = new Float32Array(particleCount * 3);
            const colors = new Float32Array(particleCount * 3);

            const color = new THREE.Color();

            for (let i = 0; i < particleCount; i++) {
                positions[i * 3] = x;
                positions[i * 3 + 1] = y;
                positions[i * 3 + 2] = z;

                color.setHSL(Math.random() * 0.2 + 0.1, 1.0, 0.5);
                colors[i * 3] = color.r;
                colors[i * 3 + 1] = color.g;
                colors[i * 3 + 2] = color.b;
            }

            particles.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            particles.setAttribute('color', new THREE.BufferAttribute(colors, 3));

            const particleMaterial = new THREE.PointsMaterial({
                size: 1.5,
                vertexColors: true,
                transparent: true,
                opacity: 0.8,
                blending: THREE.AdditiveBlending,
                sizeAttenuation: true
            });

            const particleSystem = new THREE.Points(particles, particleMaterial);
            scene.add(particleSystem);

            let frame = 0;
            const maxFrames = 60;

            const animateParticles = () => {
                if (!gameRunning) {
                    scene.remove(particleSystem);
                    return;
                }

                const positions = particles.attributes.position.array;

                for (let i = 0; i < particleCount; i++) {
                    positions[i * 3] += (Math.random() - 0.5) * 0.5;
                    positions[i * 3 + 1] += (Math.random() - 0.5) * 0.5;
                    positions[i * 3 + 2] += (Math.random() - 0.5) * 0.5;
                }

                particles.attributes.position.needsUpdate = true;

                particleMaterial.opacity = 0.8 * (1 - (frame / maxFrames));
                particleMaterial.size = 1.5 * (1 - (frame / maxFrames));

                frame++;

                if (frame < maxFrames) {
                    requestAnimationFrame(animateParticles);
                } else {
                    scene.remove(particleSystem);
                }
            };
            animateParticles();
        }

        function updateCarPosition() {
            const baseTurningSensitivity = 0.15;
            const speedAdjustedTurningSensitivity = baseTurningSensitivity * (1 + (carSpeed / maxSpeed) * 1.0); 

            let targetTilt = 0; 
            let currentYaw = 0; 
            const maxYaw = Math.PI / 16; 
            const yawResponsiveness = 0.08; 

            let wheelGroup = null;
            car.children.forEach(child => {
                if (child.isGroup && child.children.some(grandchild => grandchild.geometry instanceof THREE.CylinderGeometry)) {
                    wheelGroup = child;
                }
            });

            if (wheelGroup) {
                wheelGroup.position.set(0, 0, 0); 
                wheelGroup.rotation.z = 0; 
            }

            if (keys['arrowleft'] || keys['a'] || mobileControls.left) {
                car.position.x = Math.max(-roadWidth / 2 + 1.5, car.position.x - speedAdjustedTurningSensitivity);
                targetTilt = -maxCarTilt; 
                currentYaw = THREE.MathUtils.lerp(currentYaw, maxYaw, yawResponsiveness); 
            } else if (keys['arrowright'] || keys['d'] || mobileControls.right) {
                car.position.x = Math.min(roadWidth / 2 - 1.5, car.position.x + speedAdjustedTurningSensitivity);
                targetTilt = maxCarTilt; 
                currentYaw = THREE.MathUtils.lerp(currentYaw, -maxYaw, yawResponsiveness); 
            } else {
                currentYaw = THREE.MathUtils.lerp(currentYaw, 0, yawResponsiveness * 2); 
            }

            const tiltResponsiveness = 0.1;
            carTilt += (targetTilt - carTilt) * tiltResponsiveness;
            car.rotation.z = carTilt; 
            car.rotation.y = Math.PI + currentYaw; 
            
            if (keys['arrowup'] || keys['w'] || mobileControls.accelerate) {
                carSpeed = Math.min(carSpeed + 0.8, maxSpeed);
            } else if (keys['arrowdown'] || keys['s'] || mobileControls.brake) {
                if (brakeLightMesh) {
                    brakeLightMesh.material.emissiveIntensity = 5.0; 
                    brakeLightMesh.material.needsUpdate = true;
                }
                if (carSpeed > 5 && (!window.currentBrakeSound || window.currentBrakeSound.playState !== 'playing')) {
                    window.currentBrakeSound = playSound(brakeBuffer, THREE.MathUtils.mapLinear(carSpeed, 0, maxSpeed, 0.2, 0.8), true);
                } else if (window.currentBrakeSound) {
                    window.currentBrakeSound.gainNode.gain.setValueAtTime(THREE.MathUtils.mapLinear(carSpeed, 0, maxSpeed, 0.2, 0.8), audioContext.currentTime);
                }
            } else {
                if (brakeLightMesh) {
                    brakeLightMesh.material.emissiveIntensity = 0.0; 
                    brakeLightMesh.material.needsUpdate = true;
                }
                carSpeed = Math.max(carSpeed - 0.1, 0);
                if (window.currentBrakeSound) {
                    window.currentBrakeSound.stop();
                    window.currentBrakeSound = null;
                }
            }

            const roadBoundary = roadWidth / 2 - 1.5;
            car.position.x = Math.max(-roadBoundary, Math.min(roadBoundary, car.position.x));
        }

        function updateTraffic() {
            const laneChangeProbability = 0.003 * (level * 0.5 + 0.5);
            const wanderMagnitude = 0.6;
            const wanderSpeed = 0.02;
            const laneChangeSpeed = 0.03;
            const policeLaneChangeAggression = 0.005 * policeDifficultyMultiplier;

            trafficCars.forEach(trafficCar => {
                let carCurrentSpeed = (baseTrafficSpeed * (carSpeed / 100)) + (carSpeed * 0.01) + (level * 0.01);

                if (trafficCar.userData.isPolice) {
                    const policeOvertakeSpeed = carSpeed * (1.1 + (policeDifficultyMultiplier * 0.05));
                    const currentPoliceChaseDistance = policeChaseDistance * (1 - (policeDifficultyMultiplier * 0.05));

                    const distToPlayerZ = car.position.z - trafficCar.position.z;

                    const policeLightGroup = trafficCar.userData.policeLightGroup;
                    if (policeLightGroup) {
                        policeLightGroup.rotation.y += 0.2;
                        policeLightGroup.userData.lightState = (policeLightGroup.userData.lightState + 1) % 20;
                        if (policeLightGroup.userData.lightState < 10) {
                            policeLightGroup.userData.redLightBulb.material.emissiveIntensity = 2.0;
                            policeLightGroup.userData.blueLightBulb.material.emissiveIntensity = 0.0;
                        } else {
                            policeLightGroup.userData.redLightBulb.material.emissiveIntensity = 0.0;
                            policeLightGroup.userData.blueLightBulb.material.emissiveIntensity = 2.0;
                        }
                        policeLightGroup.userData.redLightBulb.material.needsUpdate = true;
                        policeLightGroup.userData.blueLightBulb.material.needsUpdate = true;
                    }

                    if (distToPlayerZ < -150 || distToPlayerZ > 50) {
                        trafficCar.position.z = car.position.z + 10;
                        const playerLaneIndex = lanes.findIndex(lane => Math.abs(car.position.x - lane) < laneWidth / 2);
                        trafficCar.position.x = lanes[playerLaneIndex] + (Math.random() - 0.5) * laneWidth * 0.5;
                        trafficCar.userData.currentLane = trafficCar.position.x;
                        trafficCar.userData.targetLane = trafficCar.position.x;
                        trafficCar.userData.isChangingLane = false;
                        showScoreFeedback('POLİS YENİDEN KONUMLANDI!', '#FFFF00');
                    }

                    if (distToPlayerZ < -100 && carSpeed > (trafficCar.userData.lastSpeedSample || 0) + 20) {
                        showScoreFeedback('POLİS ATLATILDI! +750', '#00BFFF');
                        if (trafficCar.userData.sirenSource && trafficCar.userData.sirenSource.source) { 
                            trafficCar.userData.sirenSource.stop();
                            trafficCar.userData.sirenSource = null;
                            console.log("Police siren stopped.");
                        }
                        releasePooledPoliceCar(trafficCar);
                        activePoliceCar = null;
                        lastPoliceCarDespawnTime = Date.now();
                        currentPoliceChaseDamage = 0;
                        return;
                    }

                    const playerLaneIndex = lanes.findIndex(lane => Math.abs(car.position.x - lane) < laneWidth / 2);
                    const currentLaneIndex = lanes.findIndex(lane => Math.abs(trafficCar.position.x - lane) < laneWidth / 2);

                    if (!trafficCar.userData.isChangingLane && Math.abs(distToPlayerZ) < 50) {
                        if (currentLaneIndex !== playerLaneIndex && Math.random() < policeLaneChangeAggression) {
                            const possibleDirections = [];
                            if (playerLaneIndex > currentLaneIndex && currentLaneIndex < lanes.length -1 ) possibleDirections.push(1); 
                            if (playerLaneIndex < currentLaneIndex && currentLaneIndex > 0) possibleDirections.push(-1); 

                            if (possibleDirections.length > 0) {
                                const direction = possibleDirections[Math.floor(Math.random() * possibleDirections.length)];
                                const newLaneTargetX = lanes[currentLaneIndex + direction];
                                let isTargetLaneClear = true;
                                for (const otherCar of trafficCars) {
                                    if (otherCar !== trafficCar &&
                                        Math.abs(otherCar.position.x - newLaneTargetX) < laneWidth / 2 &&
                                        Math.abs(otherCar.position.z - trafficCar.position.z) < (trafficCar.userData.length / 2 + otherCar.userData.length / 2 + 10)) {
                                        isTargetLaneClear = false;
                                        break;
                                    }
                                }
                                if (isTargetLaneClear) {
                                    trafficCar.userData.targetLane = newLaneTargetX;
                                    trafficCar.userData.isChangingLane = true;
                                    }
                                }
                            }
                        }

                    if (distToPlayerZ > -currentPoliceChaseDistance && distToPlayerZ < currentPoliceChaseDistance) {
                        carCurrentSpeed = carSpeed * (1 + (policeDifficultyMultiplier * 0.01));
                    } else if (distToPlayerZ <= -currentPoliceChaseDistance) {
                        carCurrentSpeed = policeOvertakeSpeed * 1.5;
                    } else if (distToPlayerZ >= currentPoliceChaseDistance) {
                        carCurrentSpeed = carSpeed * (0.8 - (policeDifficultyMultiplier * 0.01));
                    }
                    
                    if (trafficCar.userData.isChangingLane) {
                        trafficCar.position.x += (trafficCar.userData.targetLane - trafficCar.position.x) * laneChangeSpeed * (policeDifficultyMultiplier * 1.5);
                        if (Math.abs(trafficCar.position.x - trafficCar.userData.targetLane) < 0.2) {
                            trafficCar.userData.currentLane = trafficCar.userData.targetLane;
                            trafficCar.userData.isChangingLane = false;
                        }
                    } else {
                        const aggressiveShift = (car.position.x - trafficCar.position.x) * 0.005 * policeDifficultyMultiplier;
                        trafficCar.position.x += aggressiveShift;
                        trafficCar.userData.currentLane = trafficCar.position.x;
                    }

                    trafficCar.rotation.z = -((trafficCar.position.x - (trafficCar.userData.lastX || trafficCar.position.x)) * 0.5);
                    trafficCar.userData.lastX = trafficCar.position.x;
                    trafficCar.userData.lastSpeedSample = carCurrentSpeed;

                } else { 
                    trafficCar.position.z += carCurrentSpeed;

                    if (!trafficCar.userData.isChangingLane) {
                        if (Math.random() < wanderSpeed) {
                            trafficCar.userData.wanderTarget = (Math.random() - 0.5) * wanderMagnitude;
                        }
                        trafficCar.userData.wander += (trafficCar.userData.wanderTarget - trafficCar.userData.wander) * 0.1;
                    }

                    if (!trafficCar.userData.isChangingLane) {
                        if (Math.random() < laneChangeProbability) {
                            const currentLaneIndex = lanes.findIndex(lane => Math.abs(trafficCar.position.x - lane) < laneWidth / 2);
                            const possibleDirections = [];
                            if (currentLaneIndex > 0) possibleDirections.push(-1);
                            if (currentLaneIndex < lanes.length - 1) possibleDirections.push(1);

                            if (possibleDirections.length > 0) {
                                const direction = possibleDirections[Math.floor(Math.random() * possibleDirections.length)];
                                const newLaneTargetX = lanes[currentLaneIndex + direction];
                                let isTargetLaneClear = true;
                                for (const otherCar of trafficCars) {
                                    if (otherCar !== trafficCar &&
                                        Math.abs(otherCar.position.x - newLaneTargetX) < laneWidth / 2 &&
                                        Math.abs(otherCar.position.z - trafficCar.position.z) < (trafficCar.userData.length / 2 + otherCar.userData.length / 2 + 5)) {
                                        isTargetLaneClear = false;
                                        break;
                                    }
                                }
                                if (isTargetLaneClear) {
                                    trafficCar.userData.targetLane = newLaneTargetX;
                                    trafficCar.userData.isChangingLane = true;
                                }
                            }
                        }
                        trafficCar.position.x = trafficCar.userData.currentLane + trafficCar.userData.wander;

                    } else { 
                        let targetX = trafficCar.userData.targetLane + trafficCar.userData.wander;
                        trafficCar.position.x += (targetX - trafficCar.position.x) * laneChangeSpeed;

                        if (Math.abs(trafficCar.position.x - trafficCar.userData.targetLane) < 0.2) {
                            trafficCar.userData.currentLane = trafficCar.userData.targetLane;
                            trafficCar.userData.isChangingLane = false;
                        }
                    }
                } 

                const roadBoundary = roadWidth / 2 - 1.5;
                trafficCar.position.x = Math.max(-roadBoundary, Math.min(roadBoundary, trafficCar.position.x));

                if (trafficCar.position.z > camera.position.z + 50) {
                    if (trafficCar.userData.isPooled) {
                        releasePooledTrafficCar(trafficCar);
                        const index = trafficCars.indexOf(trafficCar);
                        if (index > -1) {
                            trafficCars.splice(index, 1);
                        }
                    } else { 
                        scene.remove(trafficCar);
                        const index = trafficCars.indexOf(trafficCar);
                        if (index > -1) {
                            trafficCars.splice(index, 1);
                        }
                    }

                    if (!trafficCar.userData.isPolice) {
                        addScore(50 + Math.floor(carSpeed / 10));
                    }
                }
            }); 

            if (trafficCars.filter(tc => !tc.userData.isPolice).length < (5 + level * 2)) { 
                let newCar = getPooledTrafficCar();
                if (newCar) {
                    const lane = lanes[Math.floor(Math.random() * lanes.length)];
                    let zSpawnPosition = camera.position.z - 250 - (Math.random() * 50);

                    let overlap = true;
                    let attempts = 0;
                    const minDistanceBetweenCars = 30;

                    while (overlap && attempts < 20) {
                        overlap = false;
                        for (const existingCar of trafficCars) {
                            if (Math.abs(existingCar.position.x - lane) < laneWidth / 2 &&
                                Math.abs(existingCar.position.z - zSpawnPosition) < (existingCar.userData.length / 2 + newCar.userData.length / 2 + minDistanceBetweenCars)) {
                                overlap = true;
                                zSpawnPosition -= (existingCar.userData.length + newCar.userData.length + minDistanceBetweenCars);
                                break;
                            }
                        }
                        attempts++;
                    }
                    if (overlap) { 
                        zSpawnPosition = camera.position.z - 500 - (Math.random() * 200);
                    }

                    newCar.position.set(lane, 0, zSpawnPosition);
                    newCar.rotation.y = Math.PI; 
                    newCar.userData.currentLane = lane;
                    newCar.userData.targetLane = lane;
                    newCar.userData.isChangingLane = false;
                    newCar.userData.wander = (Math.random() - 0.5) * 0.5;
                    newCar.userData.wanderTarget = (Math.random() - 0.5) * 0.5;
                    newCar.visible = true; 
                    trafficCars.push(newCar);
                }
            }
        } 


        function updateRoad() {
            road.forEach(segment => {
                segment.position.z += roadSpeed + (carSpeed / 100);

                if (segment.position.z > camera.position.z + 20) {
                    segment.position.z -= 600;
                }
            });

            barriers.forEach(barrier => {
                barrier.position.z += roadSpeed + (carSpeed / 100);

                if (barrier.position.z > camera.position.z + 20) {
                    barrier.position.z -= 600;
                }
            });
        }

        function createTree(x, z) {
            const treeGroup = new THREE.Group();

            const trunkGeometry = new THREE.CylinderGeometry(0.5, 0.7, 5, 8);
            const trunkMaterial = new THREE.MeshStandardMaterial({
                color: 0x8B4513,
                roughness: 0.9,
                metalness: 0.0
            });
            const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
            trunk.position.y = 2.5;
            trunk.castShadow = true;
            treeGroup.add(trunk);

            const leavesMaterial = new THREE.MeshStandardMaterial({
                color: 0x228B22,
                roughness: 0.7,
                metalness: 0.0
            });

            const topLeaves = new THREE.Mesh(new THREE.ConeGeometry(2, 4, 8), leavesMaterial);
            topLeaves.position.y = 6;
            topLeaves.castShadow = true;
            treeGroup.add(topLeaves);

            const middleLeaves = new THREE.Mesh(new THREE.ConeGeometry(2.5, 3, 8), leavesMaterial);
            middleLeaves.position.y = 4;
            middleLeaves.castShadow = true;
            treeGroup.add(middleLeaves);

            treeGroup.position.set(x, 0, z);
            return treeGroup;
        }

        function createSign(x, z) {
            const signGroup = new THREE.Group();

            const poleGeometry = new THREE.CylinderGeometry(0.2, 0.2, 4, 6);
            const poleMaterial = new THREE.MeshStandardMaterial({
                color: 0xAAAAAA,
                roughness: 0.6,
                metalness: 0.4
            });
            const pole = new THREE.Mesh(poleGeometry, poleMaterial);
            pole.position.y = 2;
            pole.castShadow = true;
            signGroup.add(pole);

            const boardGeometry = new THREE.BoxGeometry(3, 1.5, 0.1);
            const boardMaterial = new THREE.MeshStandardMaterial({
                color: 0xFFFFFF,
                roughness: 0.7,
                metalness: 0.0
            });
            const board = new THREE.Mesh(boardGeometry, boardMaterial);
            board.position.set(0, 3.5, 0);
            board.castShadow = true;
            signGroup.add(board);

            signGroup.position.set(x, 0, z);
            return signGroup;
        }

        function createDeer(x, z) {
            const deerGroup = new THREE.Group();

            const bodyMaterial = new THREE.MeshStandardMaterial({ color: 0x8B4513, roughness: 0.8, metalness: 0.0 });
            const antlerMaterial = new THREE.MeshStandardMaterial({ color: 0xD2B48C, roughness: 0.8, metalness: 0.0 });

            const bodyGeometry = new THREE.BoxGeometry(0.8, 1.0, 1.5);
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            body.position.y = 0.5;
            body.castShadow = true;
            deerGroup.add(body);

            const headGeometry = new THREE.BoxGeometry(0.5, 0.5, 0.5);
            const head = new THREE.Mesh(headGeometry, bodyMaterial);
            head.position.set(0, 1.2, 0.6);
            head.castShadow = true;
            deerGroup.add(head);

            const legGeometry = new THREE.BoxGeometry(0.2, 0.8, 0.2);
            const legPositions = [
                { x: -0.3, z: 0.5 },
                { x: 0.3, z: 0.5 },
                { x: -0.3, z: -0.5 },
                { x: 0.3, z: -0.5 }
            ];
            legPositions.forEach(pos => {
                const leg = new THREE.Mesh(legGeometry, bodyMaterial);
                leg.position.set(pos.x, 0.4, pos.z);
                leg.castShadow = true;
                deerGroup.add(leg);
            });

            const antler1Geometry = new THREE.CylinderGeometry(0.1, 0.1, 0.8, 4);
            const antler1 = new THREE.Mesh(antler1Geometry, antlerMaterial);
            antler1.position.set(-0.15, 1.6, 0.7);
            antler1.rotation.z = Math.PI / 8;
            antler1.castShadow = true;
            deerGroup.add(antler1);

            const antler2Geometry = new THREE.CylinderGeometry(0.1, 0.1, 0.8, 4);
            const antler2 = new THREE.Mesh(antler2Geometry, antlerMaterial);
            antler2.position.set(0.15, 1.6, 0.7);
            antler2.rotation.z = -Math.PI / 8;
            antler2.castShadow = true;
            deerGroup.add(antler2);

            deerGroup.position.set(x, 0, z);
            return deerGroup;
        }

        function createRadarPoleOnce(zPos) {
            const radarSide = (Math.random() < 0.5 ? -1 : 1);
            const xPos = radarSide * (roadWidth / 2 + roadsideWidth / 2 + (Math.random() * 5));

            const radarGroup = new THREE.Group();

            const poleGeometry = new THREE.CylinderGeometry(0.2, 0.2, 5, 8);
            const poleMaterial = new THREE.MeshStandardMaterial({
                color: 0x888888,
                roughness: 0.6,
                metalness: 0.4
            });
            const pole = new THREE.Mesh(poleGeometry, poleMaterial);
            pole.position.y = 2.5;
            pole.castShadow = true;
            radarGroup.add(pole);

            const boxGeometry = new THREE.BoxGeometry(1.2, 0.8, 0.8);
            const boxMaterial = new THREE.MeshStandardMaterial({
                color: 0x000000,
                roughness: 0.5,
                metalness: 0.8
            });
            const box = new THREE.Mesh(boxGeometry, boxMaterial);
            box.position.set(0, 4.5, 0);
            box.castShadow = true;
            radarGroup.add(box);

            const lightMaterial = new THREE.MeshStandardMaterial({
                color: 0xFF0000,
                emissive: 0xFF0000,
                emissiveIntensity: 2.0,
                roughness: 0.1
            });
            const light1 = new THREE.Mesh(new THREE.SphereGeometry(0.15, 8, 8), lightMaterial);
            light1.position.set(-0.3, 4.8, 0.4);
            radarGroup.add(light1);
            const light2 = new THREE.Mesh(new THREE.SphereGeometry(0.15, 8, 8), lightMaterial);
            light2.position.set(0.3, 4.8, 0.4);
            radarGroup.add(light2);

            radarGroup.position.set(xPos, 0, zPos);
            radarGroup.userData.isRadar = true;
            radarGroup.userData.hitCooldown = 5000;
            radarGroup.userData.lastHit = 0;
            radarGroup.userData.spawnDistance = distance;

            scene.add(radarGroup);
            radarPoles.push(radarGroup);

            nextRadarSpawnDistance = distance + 5000;
        }

        function spawnPoliceCar() {
            const newPoliceCar = getPooledPoliceCar();
            if (newPoliceCar) {
                const playerLaneIndex = lanes.findIndex(lane => Math.abs(car.position.x - lane) < laneWidth / 2);
                let spawnLane;
                if (playerLaneIndex !== -1) {
                    spawnLane = lanes[playerLaneIndex];
                } else {
                    spawnLane = lanes[Math.floor(Math.random() * lanes.length)];
                }

                newPoliceCar.position.set(spawnLane, 0, car.position.z + 50); // Oyuncunun biraz arkasından spawn et
                newPoliceCar.rotation.y = Math.PI;
                newPoliceCar.userData.currentLane = spawnLane;
                newPoliceCar.userData.targetLane = spawnLane;
                newPoliceCar.userData.lastX = newPoliceCar.position.x;
                newPoliceCar.userData.trafficCollisions = 0;
                newPoliceCar.userData.initialHitOccurred = false;
                
                trafficCars.push(newPoliceCar);
                activePoliceCar = newPoliceCar;
                lastPoliceCarDespawnTime = Date.now();
                currentPoliceChaseDamage = 0;

                showScoreFeedback('POLİS PEŞİNİZDE!', '#FF4500');

                if (policeSirenBuffer && audioContext) {
                    if (activePoliceCar.userData.sirenSource && activePoliceCar.userData.sirenSource.playState === 'playing') {
                        activePoliceCar.userData.sirenSource.stop();
                    }
                    const sirenSourceNode = audioContext.createBufferSource(); 
                    sirenSourceNode.buffer = policeSirenBuffer;
                    sirenSourceNode.loop = true;
                    const sirenGainNode = audioContext.createGain();
                    sirenGainNode.gain.setValueAtTime(1.0, audioContext.currentTime);
                    sirenSourceNode.connect(sirenGainNode);
                    sirenGainNode.connect(audioContext.destination);
                    sirenSourceNode.start(0);
                    newPoliceCar.userData.sirenSource = {
                        source: sirenSourceNode, 
                        gainNode: sirenGainNode, 
                        playState: 'playing', 
                        stop: function() { 
                            if (this.playState === 'playing') {
                                this.source.stop(); 
                                this.source.disconnect(); 
                                this.gainNode.disconnect(); 
                                this.playState = 'stopped'; 
                                console.log("Police siren (from object) stopped.");
                            }
                        }
                    };
                    console.log("Police siren started playing.");
                }

                policeDamageStartTime = Date.now();
                currentPoliceChaseDamage = 0; 
                lastPoliceIncrementalDamageTime = Date.now();
            }
        }

        function createInitialRoadsideElements(count) {
            for (let i = 0; i < count; i++) {
                const zPos = camera.position.z - 200 - (i * (Math.random() * 50 + 30));

                let roadsideElement;
                let xPos;

                if (Math.random() < 0.5) {
                    xPos = -(roadWidth / 2 + roadsideWidth / 2 + (Math.random() * 5));
                    if (Math.random() < 0.8) {
                        roadsideElement = createTree(xPos, zPos);
                    } else {
                        roadsideElement = createDeer(xPos, zPos);
                    }
                } else {
                    xPos = (roadWidth / 2 + roadsideWidth / 2 + (Math.random() * 5));
                    if (Math.random() < 0.8) {
                        roadsideElement = createSign(xPos, zPos);
                    } else {
                        roadsideElement = createTree(xPos, zPos);
                    }
                }

                roadsideElements.push(roadsideElement);
                scene.add(roadsideElement);
            }

            if (radarPoles.length === 0) {
                createRadarPoleOnce(camera.position.z - 200);
            }
        }

        function updateRoadsideElements() {
            const roadsideSpawnDistance = camera.position.z - 250;
            const roadsideRemovalDistance = camera.position.z + 50;

            let currentSpeedEffectScale = 1.0;
            if (carSpeed > SPEED_EFFECT_THRESHOLD) {
                currentSpeedEffectScale = 1.0 + (carSpeed - SPEED_EFFECT_THRESHOLD) * speedEffectScaleFactor;
            } else {
                currentSpeedEffectScale = 1.0;
            }

            for (let i = roadsideElements.length - 1; i >= 0; i--) {
                const element = roadsideElements[i];
                element.position.z += roadSpeed + (carSpeed / 100);

                element.scale.z = currentSpeedEffectScale;

                if (element.position.z > roadsideRemovalDistance) {
                    let newZPos = roadsideSpawnDistance - (Math.random() * 100);

                    let overlap = true;
                    let attempts = 0;
                    while (overlap && attempts < 10) {
                        overlap = false;
                        for (const otherElement of roadsideElements.concat(radarPoles)) {
                            if (otherElement !== element &&
                                Math.abs(otherElement.position.x - element.position.x) < 5 && 
                                Math.abs(otherElement.position.z - newZPos) < 20) { 
                                overlap = true;
                                newZPos -= 30; 
                                break;
                            }
                        }
                        attempts++;
                    }

                    let newXPos;
                    scene.remove(element); 
                    if (element.position.x < 0) { 
                        newXPos = -(roadWidth / 2 + roadsideWidth / 2 + (Math.random() * 5));
                        if (Math.random() < 0.8) {
                            roadsideElements[i] = createTree(newXPos, newZPos);
                        } else {
                            roadsideElements[i] = createDeer(newXPos, newZPos);
                        }
                    } else { 
                        newXPos = (roadWidth / 2 + roadsideWidth / 2 + (Math.random() * 5));
                        if (Math.random() < 0.8) {
                            roadsideElements[i] = createSign(newXPos, newZPos);
                        } else {
                            roadsideElements[i] = createTree(newXPos, newZPos);
                        }
                    }
                    scene.add(roadsideElements[i]); 
                    roadsideElements[i].scale.set(1,1,1); 
                }
            }

            for (let i = radarPoles.length - 1; i >= 0; i--) {
                const radar = radarPoles[i];
                radar.position.z += roadSpeed + (carSpeed / 100);
                radar.scale.z = currentSpeedEffectScale;

                if (radar.position.z > roadsideRemovalDistance) {
                    scene.remove(radar);
                    radarPoles.splice(i, 1);
                    nextRadarSpawnDistance = distance + 5000; 
                }
            }
            
            if (distance >= nextRadarSpawnDistance && radarPoles.length === 0) {
                 createRadarPoleOnce(camera.position.z - 250);
            }
        }


        function createRocketPowerUp(x, z) {
            const powerUpGroup = new THREE.Group();

            const baseMaterial = new THREE.MeshStandardMaterial({
                color: 0x00BFFF, 
                emissive: 0x00AADD, 
                emissiveIntensity: 0.8, 
                roughness: 0.3, 
                metalness: 0.7, 
            });
            const baseGeometry = new THREE.BoxGeometry(1.0, 1.0, 1.0);
            const base = new THREE.Mesh(baseGeometry, baseMaterial);
            base.position.y = 0.5; 
            base.castShadow = true;
            powerUpGroup.add(base);

            const rocketBodyMaterial = new THREE.MeshStandardMaterial({
                color: 0xFF4500, 
                emissive: 0xEE3300, 
                emissiveIntensity: 1.0, 
                roughness: 0.4,
                metalness: 0.2
            });
            const rocketBodyGeometry = new THREE.CylinderGeometry(0.3, 0.5, 1.5, 8);
            const rocketBody = new THREE.Mesh(rocketBodyGeometry, rocketBodyMaterial);
            rocketBody.position.set(0, 1.2, 0); 
            rocketBody.rotation.x = Math.PI / 2; 
            rocketBody.castShadow = true;
            powerUpGroup.add(rocketBody);

            const rocketNoseMaterial = new THREE.MeshStandardMaterial({
                color: 0x808080, 
                emissive: 0x606060, 
                emissiveIntensity: 0.5,
                roughness: 0.5,
                metalness: 0.6
            });
            const rocketNoseGeometry = new THREE.ConeGeometry(0.5, 0.8, 8);
            const rocketNose = new THREE.Mesh(rocketNoseGeometry, rocketNoseMaterial);
            rocketNose.position.set(0, 1.2 + (1.5 / 2) + (0.8 / 2), 0); 
            rocketNose.rotation.x = Math.PI / 2;
            rocketNose.castShadow = true;
            powerUpGroup.add(rocketNose);

            const finMaterial = new THREE.MeshStandardMaterial({
                color: 0xAAAAAA, 
                emissive: 0x888888, 
                emissiveIntensity: 0.4,
                roughness: 0.5,
                metalness: 0.3
            });
            const finGeometry = new THREE.BoxGeometry(0.1, 0.7, 0.5);

            const fin1 = new THREE.Mesh(finGeometry, finMaterial);
            fin1.position.set(0, 1.2, 0.4);
            fin1.rotation.y = Math.PI / 2;
            fin1.castShadow = true;
            powerUpGroup.add(fin1);

            const fin2 = new THREE.Mesh(finGeometry, finMaterial);
            fin2.position.set(0.4, 1.2, 0);
            fin2.rotation.y = 0;
            fin2.castShadow = true;
            powerUpGroup.add(fin2);

            powerUpGroup.position.set(x, 0, z);
            powerUpGroup.userData.isPowerUp = true; 
            powerUpGroup.userData.rotationSpeed = Math.random() * 0.05 + 0.02; 
            powerUpGroup.userData.bobbingSpeed = Math.random() * 0.05 + 0.03; 
            powerUpGroup.userData.initialY = 0.5; 
            
            return powerUpGroup;
        }

        function updateRocketPowerUps() {
            const powerUpSpawnDistance = camera.position.z - 150; 
            const powerUpRemovalDistance = camera.position.z + 20; 
            const minSpawnInterval = 7000; 
            const maxSpawnInterval = 15000; 

            for (let i = rocketPowerUps.length - 1; i >= 0; i--) {
                const powerUp = rocketPowerUps[i];
                if (!powerUp) continue; 

                powerUp.position.z += roadSpeed + (carSpeed / 100);

                powerUp.rotation.y += powerUp.userData.rotationSpeed;

                powerUp.position.y = powerUp.userData.initialY + Math.sin(Date.now() * powerUp.userData.bobbingSpeed * 0.005) * 0.2;

                if (powerUp.position.z > powerUpRemovalDistance) {
                    scene.remove(powerUp);
                    rocketPowerUps.splice(i, 1);
                }
            }

            const currentTime = Date.now();
            if (currentTime - lastRocketPowerUpSpawnTime > (minSpawnInterval + Math.random() * (maxSpawnInterval - minSpawnInterval))) {
                const lane = lanes[Math.floor(Math.random() * lanes.length)];
                const zPos = camera.position.z - 200; 

                let overlap = false;
                const minDistanceBetweenPowerUps = 20; 
                for (const existingPowerUp of rocketPowerUps) {
                    if (Math.abs(existingPowerUp.position.x - lane) < laneWidth / 2 &&
                        Math.abs(existingPowerUp.position.z - zPos) < minDistanceBetweenPowerUps) {
                        overlap = true;
                        break;
                    }
                }
                for (const existingTrafficCar of trafficCars) { 
                    if (Math.abs(existingTrafficCar.position.x - lane) < laneWidth / 2 &&
                        Math.abs(existingTrafficCar.position.z - zPos) < (existingTrafficCar.userData.length / 2 + 5)) {
                        overlap = true;
                        break;
                    }
                }

                if (!overlap) {
                    const newPowerUp = createRocketPowerUp(lane, zPos);
                    scene.add(newPowerUp);
                    rocketPowerUps.push(newPowerUp);
                    lastRocketPowerUpSpawnTime = currentTime;
                }
            }
        }

        function fireRocket() {
            if (rockets <= 0 || (Date.now() - lastRocketFireTime < rocketCooldown)) {
                return;
            }

            lastRocketFireTime = Date.now();
            rockets--; 
            document.getElementById('rocketsDisplay').textContent = rockets; 

            rocketsFiredCount++; 
            console.log(`Rocket fired: ${rocketsFiredCount}. Rockets remaining: ${rockets}`);

            if (rocketsFiredCount >= 3 && !activePoliceCar) { // Her 3 roket sonrası polis doğur
                const newPoliceCar = getPooledPoliceCar();
                if (newPoliceCar) {
                    const playerLaneIndex = lanes.findIndex(lane => Math.abs(car.position.x - lane) < laneWidth / 2);
                    let spawnLane = lanes[Math.floor(Math.random() * lanes.length)];
                    
                    if (playerLaneIndex !== -1) {
                        spawnLane = lanes[playerLaneIndex];
                    }

                    newPoliceCar.position.set(spawnLane, 0, car.position.z + 50); 
                    newPoliceCar.rotation.y = Math.PI;
                    newPoliceCar.userData.currentLane = spawnLane;
                    newPoliceCar.userData.targetLane = spawnLane;
                    newPoliceCar.userData.lastX = newPoliceCar.position.x;
                    newPoliceCar.userData.trafficCollisions = 0;
                    newPoliceCar.userData.initialHitOccurred = false;
                    
                    trafficCars.push(newPoliceCar);
                    activePoliceCar = newPoliceCar;
                    lastPoliceCarDespawnTime = Date.now();
                    currentPoliceChaseDamage = 0;

                    showScoreFeedback('POLİS PEŞİNİZDE!', '#FF4500');

                    if (policeSirenBuffer && audioContext) {
                        if (activePoliceCar.userData.sirenSource && activePoliceCar.userData.sirenSource.playState === 'playing') {
                            activePoliceCar.userData.sirenSource.stop();
                        }
                        const sirenSourceNode = audioContext.createBufferSource();
                        sirenSourceNode.buffer = policeSirenBuffer;
                        sirenSourceNode.loop = true;
                        const sirenGainNode = audioContext.createGain();
                        sirenGainNode.gain.setValueAtTime(1.0, audioContext.currentTime);
                        sirenSourceNode.connect(sirenGainNode);
                        sirenGainNode.connect(audioContext.destination);
                        sirenSourceNode.start(0);
                        newPoliceCar.userData.sirenSource = {
                            source: sirenSourceNode, 
                            gainNode: sirenGainNode, 
                            playState: 'playing', 
                            stop: function() { 
                                if (this.playState === 'playing') {
                                    this.source.stop(); 
                                    this.source.disconnect(); 
                                    this.gainNode.disconnect(); 
                                    this.playState = 'stopped'; 
                                    console.log("Police siren (from object) stopped.");
                                }
                            }
                        };
                        console.log("Police siren started playing.");
                    }
                    rocketsFiredCount = 0; // Polis doğduktan sonra sayacı sıfırla
                }
            }


            const rocketGeometry = new THREE.CylinderGeometry(0.2, 0.4, 2.0, 8);
            const rocketMaterial = new THREE.MeshStandardMaterial({
                color: 0x808080, 
                emissive: 0x808080,
                emissiveIntensity: 0.5,
                roughness: 0.5,
                metalness: 0.8
            });
            const rocketMesh = new THREE.Mesh(rocketGeometry, rocketMaterial);

            const flameMaterial = new THREE.PointsMaterial({
                size: 0.5,
                vertexColors: true,
                transparent: true,
                opacity: 0.8,
                blending: THREE.AdditiveBlending,
                sizeAttenuation: true
            });
            const flameGeometry = new THREE.BufferGeometry();
            const flamePositions = new Float32Array(50 * 3); 
            const flameColors = new Float32Array(50 * 3);
            const flameColor = new THREE.Color();
            for (let i = 0; i < 50; i++) {
                flamePositions[i * 3] = 0;
                flamePositions[i * 3 + 1] = 0;
                flamePositions[i * 3 + 2] = 0; 
                flameColor.setHSL(Math.random() * 0.1 + 0.05, 1.0, 0.5); 
                flameColors[i * 3] = flameColor.r;
                flameColors[i * 3 + 1] = flameColor.g;
                flameColors[i * 3 + 2] = flameColor.b;
            }
            flameGeometry.setAttribute('position', new THREE.BufferAttribute(flamePositions, 3));
            flameGeometry.setAttribute('color', new THREE.BufferAttribute(flameColors, 3));
            const flameParticles = new THREE.Points(flameGeometry, flameMaterial);
            flameParticles.position.z = -1.0; 
            rocketMesh.add(flameParticles); 


            rocketMesh.position.copy(car.position);
            rocketMesh.position.y += 0.5; 
            rocketMesh.position.z -= 5.0; 

            scene.add(rocketMesh);
            activeRocket = rocketMesh; 

            if (powerUpCollectBuffer) { 
                playSound(powerUpCollectBuffer, 0.8);
            }
        }

        function createRocketParticle(x, y, z) {
            // Şu an için kullanılmıyor, patlama efekti yeterli
        }

        function updateRocket() {
            if (!activeRocket) return;

            activeRocket.position.z -= rocketBaseSpeed * 2; 
            activeRocket.rotation.y += 0.2; 

            activeRocket.traverse(obj => {
                if (obj instanceof THREE.Points) {
                    const positions = obj.geometry.attributes.position.array;
                    const colors = obj.geometry.attributes.color.array;

                    for (let i = 0; i < positions.length / 3; i++) {
                        positions[i * 3 + 2] += (Math.random() - 0.5) * 0.1; 
                        positions[i * 3 + 1] += (Math.random() - 0.5) * 0.05; 
                        positions[i * 3] += (Math.random() - 0.5) * 0.05; 
                    }
                    obj.geometry.attributes.position.needsUpdate = true;
                    const time = Date.now() * 0.005; 
                    for (let i = 0; i < colors.length / 3; i++) {
                        const r = THREE.MathUtils.mapLinear(Math.sin(time + i), -1, 1, 0.5, 1.0); 
                        const g = THREE.MathUtils.mapLinear(Math.cos(time + i * 2), -1, 1, 0.2, 0.6); 
                        const b = 0; 
                        colors[i * 3] = r;
                        colors[i * 3 + 1] = g;
                        colors[i * 3 + 2] = b;
                    }
                    obj.geometry.attributes.color.needsUpdate = true;
                    obj.material.opacity = Math.max(0, obj.material.opacity - 0.02); 
                    obj.material.size = Math.max(0.1, obj.material.size - 0.01); 
                }
            });


            const rocketBox = new THREE.Box3().setFromObject(activeRocket);

            // Trafik araçlarını patlatma mantığı
            for (let i = trafficCars.length - 1; i >= 0; i--) {
                const trafficCar = trafficCars[i];
                // Polis arabalarını roketler patlatmasın
                if (!trafficCar || !trafficCar.visible || trafficCar.userData.isPolice) continue; 

                trafficBox.setFromObject(trafficCar);

                if (rocketBox.intersectsBox(trafficBox)) {
                    createExplosion(trafficCar.position.x, trafficCar.position.y + 1, trafficCar.position.z); 
                    
                    if (trafficCar.userData.isPooled) {
                        releasePooledTrafficCar(trafficCar);
                        const index = trafficCars.indexOf(trafficCar);
                        if (index > -1) trafficCars.splice(index, 1);
                    } else { 
                        scene.remove(trafficCar);
                        const index = trafficCars.indexOf(trafficCar);
                        if (index > -1) trafficCars.splice(index, 1);
                    }

                    trafficCarsDestroyedByRocket++;
                    addScore(500); 
                    showScoreFeedback('ROKET İSABETİ! +500', '#FF8C00'); 
                    
                    scene.remove(activeRocket); // Roket isabet edince kendini yok etsin
                    activeRocket = null;
                    return; // Bir araç patlatıldıysa bu karedeki kontrolü bitir
                }
            }

            // Roket ekranın dışına çıkarsa yok et
            if (activeRocket.position.z < camera.position.z - 300) { 
                scene.remove(activeRocket);
                activeRocket = null;
            }
        }

        function takeDamage(amount) {
            health -= amount;
            health = Math.max(0, health);
            updateHealthBar();
            if (health <= 0) {
                gameOver();
            }
        }

        function updateHealthBar() {
            const healthFillElement = document.getElementById('healthFill');
            const fillHeight = (health / maxHealth) * 100;
            const hue = (health / maxHealth) * 120;
            healthFillElement.style.height = `${fillHeight}%`;
            healthFillElement.style.background = `hsl(${hue}, 100%, 40%)`;
            // Can barının yukarıdan aşağıya azalması için justify-content: flex-start; yerine flex-end; kullanılır.
            // Bu zaten CSS'te tanımlandı, ancak ekranda bir bug varsa burası kontrol edilebilir.
            // Bu CSS'de doğru ayarlandığı için burada ek bir işlem yapmaya gerek kalmıyor.
        }

        function checkCollisions() {
            if (!car) return; 
            carBox.setFromObject(car);

            for (let i = trafficCars.length - 1; i >= 0; i--) {
                const trafficCar = trafficCars[i];
                if (!trafficCar || (trafficCar.userData.isPooled && !trafficCar.visible)) continue; 

                trafficBox.setFromObject(trafficCar);

                if (carBox.intersectsBox(trafficBox)) {
                    const intersection = new THREE.Box3();
                    intersection.copy(carBox).intersect(trafficBox);

                    const carSize = carBox.getSize(new THREE.Vector3());
                    const trafficCarSize = trafficBox.getSize(new THREE.Vector3());

                    const intersectionZDepth = intersection.max.z - intersection.min.z;
                    const intersectionXWidth = intersection.max.x - intersection.min.x;
                    const minCollisionOverlapX = 0.5;

                    if (trafficCar.userData.isPolice) {
                        if (activePoliceCar && currentPoliceChaseDamage < policeTotalDamageLimit && (Date.now() - lastPoliceIncrementalDamageTime >= policeDamageInterval)) {
                            takeDamage(1);
                            currentPoliceChaseDamage++;
                            lastPoliceIncrementalDamageTime = Date.now();
                            showScoreFeedback('POLİS TEMASI!', '#FF0000');
                        }

                        if (activePoliceCar && currentPoliceChaseDamage >= policeTotalDamageLimit) {
                            showScoreFeedback('POLİS ATLATILDI! +750', '#00BFFF');
                            if (activePoliceCar.userData.sirenSource && activePoliceCar.userData.sirenSource.source) {
                                activePoliceCar.userData.sirenSource.stop();
                                activePoliceCar.userData.sirenSource = null;
                                console.log("Police siren stopped (damage limit).");
                            }
                            releasePooledPoliceCar(trafficCar);
                            const index = trafficCars.indexOf(trafficCar);
                            if (index > -1) trafficCars.splice(index, 1);
                            activePoliceCar = null;
                            lastPoliceCarDespawnTime = Date.now();
                            currentPoliceChaseDamage = 0;
                            return; 
                        }

                        if (car.position.x < trafficCar.position.x) car.position.x -= 0.5;
                        else car.position.x += 0.5;
                        carSpeed = Math.max(0, carSpeed - 10);
                        return; 
                    }
                    else { 
                        if (intersectionZDepth > directCollisionZThreshold && Math.abs(car.position.z - trafficCar.position.z) < (carSize.z/2 + trafficCarSize.z/2) * 0.8 ) {
                            gameOver();
                            return;
                        } else if (intersectionXWidth > minCollisionOverlapX) { 
                            const damage = Math.floor(carSpeed * sideCollisionDamageMultiplier * (intersectionXWidth / carSize.x));
                            takeDamage(damage);
                            if (car.position.x < trafficCar.position.x) car.position.x -= 1.0;
                            else car.position.x += 1.0;
                            carSpeed = Math.max(0, carSpeed - 30);
                        }
                    }
                } 
            } 


            if (activePoliceCar) {
                const policeBox = new THREE.Box3().setFromObject(activePoliceCar);
                for (let i = trafficCars.length - 1; i >= 0; i--) {
                    const otherTrafficCar = trafficCars[i];
                    if (otherTrafficCar === activePoliceCar || (otherTrafficCar.userData.isPooled && !otherTrafficCar.visible) || otherTrafficCar.userData.isPolice) continue;
                    
                    trafficBox.setFromObject(otherTrafficCar);

                    if (policeBox.intersectsBox(trafficBox)) {
                        if (otherTrafficCar.userData.isPooled) {
                             releasePooledTrafficCar(otherTrafficCar);
                             const index = trafficCars.indexOf(otherTrafficCar);
                             if (index > -1) trafficCars.splice(index, 1);
                        } else { 
                            scene.remove(otherTrafficCar);
                            const index = trafficCars.indexOf(otherTrafficCar);
                            if (index > -1) trafficCars.splice(index, 1);
                        }
                        addScore(200);
                        showScoreFeedback('POLİS ÇARPIŞTI! +200', '#FF4500');
                        createExplosion(otherTrafficCar.position.x, otherTrafficCar.position.y, otherTrafficCar.position.z);
                        
                        activePoliceCar.userData.trafficCollisions++;
                        if (activePoliceCar.userData.trafficCollisions >= 3) {
                            showScoreFeedback('POLİS PES ETTİ! +1000', '#00FF00');
                            if (activePoliceCar.userData.sirenSource && activePoliceCar.userData.sirenSource.source) { 
                                activePoliceCar.userData.sirenSource.stop();
                                activePoliceCar.userData.sirenSource = null;
                                console.log("Police siren stopped (gave up).");
                            }
                            releasePooledPoliceCar(activePoliceCar);
                            const activePoliceIndex = trafficCars.indexOf(activePoliceCar);
                            if (activePoliceIndex > -1) trafficCars.splice(activePoliceIndex, 1);
                            activePoliceCar = null;
                            lastPoliceCarDespawnTime = Date.now();
                            currentPoliceChaseDamage = 0;
                        }
                    }
                }
            }

            for (let i = rocketPowerUps.length - 1; i >= 0; i--) {
                const powerUp = rocketPowerUps[i];
                if (!powerUp || !powerUp.userData.isPowerUp) continue; 

                powerUpBox.setFromObject(powerUp);

                if (carBox.intersectsBox(powerUpBox)) {
                    rockets++; 
                    document.getElementById('rocketsDisplay').textContent = rockets;
                    addScore(250, 1.0); 
                    showScoreFeedback('ROKET ALINDI! +250', '#FFD700'); 

                    if (powerUpCollectBuffer) {
                        playSound(powerUpCollectBuffer, 0.7); 
                    }

                    scene.remove(powerUp); 
                    rocketPowerUps.splice(i, 1); 
                }
            }

            for (let i = 0; i < barriers.length; i++) {
                const barrierMesh = barriers[i];
                if (!barrierMesh) continue; 
                const barrierBox = new THREE.Box3().setFromObject(barrierMesh);
                if (carBox.intersectsBox(barrierBox)) {
                    if (car.position.x < barrierMesh.position.x) car.position.x -= 0.5;
                    else car.position.x += 0.5;
                    carSpeed = Math.max(0, carSpeed - 50);
                    takeDamage(Math.floor(carSpeed * 0.2)); 
                }
            }
        } 


        function updateDayNightCycle() {
            const distancePassed = distance - previousDistanceForTime;
            timeOfDay = (timeOfDay + (distancePassed / dayDurationInGameMeters) * 24) % 24;
            previousDistanceForTime = distance;

            let ambientColor, directionalColor;
            let directionalIntensity, ambientIntensity;
            let fogColor, fogNear, fogFar;
            let timeOfDayText = '';
            let timeOfDayEmoji = '';
            let scoreMultiplier = 1.0;
            let roadLineEmissiveIntensity;
            let barrierStripeEmissiveIntensity;
            let playerHeadlightIntensityValue = 0; 
            let trafficLightEmissiveIntensity = 0;

            const currentHour = Math.floor(timeOfDay);
            const currentMinute = Math.floor((timeOfDay - currentHour) * 60);

            if (timeOfDay >= 6 && timeOfDay < 18) { 
                const progress = (timeOfDay - 6) / 12;
                ambientColor = new THREE.Color().lerpColors(new THREE.Color(0x6060A0), new THREE.Color(0xAAAAFF), progress);
                directionalColor = new THREE.Color().lerpColors(new THREE.Color(0xFFCC88), new THREE.Color(0xFFFFFF), progress);
                directionalIntensity = THREE.MathUtils.lerp(0.8, 1.2, progress);
                ambientIntensity = THREE.MathUtils.lerp(0.5, 0.8, progress);
                fogColor = new THREE.Color().lerpColors(new THREE.Color(0x87CEEB), new THREE.Color(0xADD8E6), progress);
                fogNear = 100; fogFar = 500;
                timeOfDayText = 'Gündüz'; timeOfDayEmoji = '☀️'; scoreMultiplier = 1.0;
                roadLineEmissiveIntensity = 0.2; barrierStripeEmissiveIntensity = 0.3;
                playerHeadlightIntensityValue = 0; trafficLightEmissiveIntensity = 0;
            } else if (timeOfDay >= 18 && timeOfDay < 20) { 
                const progress = (timeOfDay - 18) / 2;
                ambientColor = new THREE.Color().lerpColors(new THREE.Color(0xAAAAFF), new THREE.Color(0x303060), progress);
                directionalColor = new THREE.Color().lerpColors(new THREE.Color(0xFFFFFF), new THREE.Color(0xFF8C00), progress);
                directionalIntensity = THREE.MathUtils.lerp(1.2, 0.5, progress);
                ambientIntensity = THREE.MathUtils.lerp(0.8, 0.3, progress);
                fogColor = new THREE.Color().lerpColors(new THREE.Color(0xADD8E6), new THREE.Color(0x505080), progress);
                fogNear = 80; fogFar = 400;
                timeOfDayText = 'Akşam'; timeOfDayEmoji = '🌇'; scoreMultiplier = 1.2;
                roadLineEmissiveIntensity = THREE.MathUtils.lerp(0.2, 1.5, progress);
                barrierStripeEmissiveIntensity = THREE.MathUtils.lerp(0.3, 2.5, progress);
                playerHeadlightIntensityValue = THREE.MathUtils.lerp(0, 0.8, progress);
                trafficLightEmissiveIntensity = THREE.MathUtils.lerp(0, 1.5, progress);
            } else if (timeOfDay >= 20 || timeOfDay < 4) { 
                const progress = (timeOfDay >= 20 ? (timeOfDay - 20) : (timeOfDay + 4)) / 8; 
                ambientColor = new THREE.Color().lerpColors(new THREE.Color(0x303060), new THREE.Color(0x101030), progress);
                directionalColor = new THREE.Color().lerpColors(new THREE.Color(0xFF8C00), new THREE.Color(0x050505), progress);
                directionalIntensity = THREE.MathUtils.lerp(0.5, 0.1, progress);
                ambientIntensity = THREE.MathUtils.lerp(0.3, 0.1, progress);
                fogColor = new THREE.Color().lerpColors(new THREE.Color(0x505080), new THREE.Color(0x050510), progress);
                fogNear = 20; fogFar = 200;
                timeOfDayText = 'Gece'; timeOfDayEmoji = '🌙'; scoreMultiplier = 1.5;
                roadLineEmissiveIntensity = 1.8; barrierStripeEmissiveIntensity = 3.0;
                playerHeadlightIntensityValue = 1.0; trafficLightEmissiveIntensity = 1.5;
            } else { 
                const progress = (timeOfDay - 4) / 2;
                ambientColor = new THREE.Color().lerpColors(new THREE.Color(0x101030), new THREE.Color(0x6060A0), progress);
                directionalColor = new THREE.Color().lerpColors(new THREE.Color(0x050505), new THREE.Color(0xFFCC88), progress);
                directionalIntensity = THREE.MathUtils.lerp(0.1, 0.8, progress);
                ambientIntensity = THREE.MathUtils.lerp(0.1, 0.5, progress);
                fogColor = new THREE.Color().lerpColors(new THREE.Color(0x050510), new THREE.Color(0x87CEEB), progress);
                fogNear = 50; fogFar = 300;
                timeOfDayText = 'Şafak'; timeOfDayEmoji = '🌅'; scoreMultiplier = 1.2;
                roadLineEmissiveIntensity = THREE.MathUtils.lerp(1.8, 0.2, progress);
                barrierStripeEmissiveIntensity = THREE.MathUtils.lerp(3.0, 0.3, progress);
                playerHeadlightIntensityValue = THREE.MathUtils.lerp(1.0, 0, progress);
                trafficLightEmissiveIntensity = THREE.MathUtils.lerp(1.5, 0, progress);
            }

            scene.children.forEach(obj => {
                if (obj instanceof THREE.AmbientLight) {
                    obj.color.copy(ambientColor);
                    obj.intensity = ambientIntensity;
                }
                if (obj instanceof THREE.DirectionalLight) {
                    obj.color.copy(directionalColor);
                    obj.intensity = directionalIntensity;
                    const angle = (timeOfDay / 24) * Math.PI * 2 - Math.PI/2; 
                    obj.position.set(Math.cos(angle) * 30, Math.sin(angle) * 20 + 15, 10); 
                }
            });

            if (skyDome && skyDome.material) {
                skyDome.material.color.set(fogColor);
            }

            renderer.setClearColor(fogColor);
            scene.fog.color.set(fogColor);
            scene.fog.near = fogNear;
            scene.fog.far = fogFar;

            car.traverse((object) => {
                if (object.material && object.userData.isLight) {
                    if (object.material instanceof THREE.MeshStandardMaterial || object.material instanceof THREE.MeshPhongMaterial) {
                        if (object.material.color.getHexString() === 'ffff88') { 
                            object.material.emissive.set(0xAAAA00);
                            object.material.emissiveIntensity = playerHeadlightIntensityValue;
                        }
                        else if (object.material.color.getHexString() === '8b0000') { 
                            object.material.emissive.set(0xFF0000); 
                            object.material.emissiveIntensity = 5.0; 
                        }
                        object.material.needsUpdate = true;
                    }
                }
            });

             trafficCars.forEach(tc => { 
                if (tc.userData.isPolice) {
                } else {
                    tc.traverse((object) => {
                        if (object.material && object.userData.isLight) {
                            if (object.material instanceof THREE.MeshStandardMaterial || object.material instanceof THREE.MeshPhongMaterial) {
                                if (object.material.color.getHexString() === 'ffff88') { 
                                    object.material.emissive.set(0xCCCC00);
                                    object.material.emissiveIntensity = trafficLightEmissiveIntensity;
                                }
                                else if (object.material.color.getHexString() === 'ff0000') { 
                                    object.material.emissive.set(0xAA0000);
                                    object.material.emissiveIntensity = trafficLightEmissiveIntensity;
                                }
                                object.material.needsUpdate = true;
                            }
                        }
                    });
                }
            });


            road.forEach(obj => {
                if (obj.userData.isRoadLine && obj.material instanceof THREE.MeshPhongMaterial) {
                    obj.material.emissiveIntensity = roadLineEmissiveIntensity;
                    obj.material.needsUpdate = true;
                }
            });

            barriers.forEach(obj => {
                if (obj.userData.isBarrierStripe && obj.material instanceof THREE.MeshPhongMaterial) {
                    obj.material.emissiveIntensity = barrierStripeEmissiveIntensity;
                    obj.material.needsUpdate = true;
                }
            });

            if (playerHeadlight) { 
                    playerHeadlight.intensity = playerHeadlightIntensityValue;
            }

            document.getElementById('timeOfDayDisplay').textContent = `${String(currentHour).padStart(2, '0')}:${String(currentMinute).padStart(2, '0')}`;
            document.getElementById('timeOfDayInfo').innerHTML = `${timeOfDayEmoji} ${timeOfDayText}: <span id="timeOfDayDisplay">${String(currentHour).padStart(2, '0')}:${String(currentMinute).padStart(2, '0')}</span>`;

            return scoreMultiplier;
        }


        function updateScoreAndLevel() {
            distance += carSpeed / 100;

            const currentScoreMultiplier = updateDayNightCycle();

            addScore(Math.floor(carSpeed / 50), currentScoreMultiplier);

            const newLevel = Math.floor(distance / 1000) + 1;
            if (newLevel > level) {
                level = newLevel;
                document.getElementById('level').textContent = level;
                baseTrafficSpeed += 0.02;
                maxSpeed += 10;
                policeDifficultyMultiplier += 0.1;
                showScoreFeedback(`SEVİYE ${level}!`, '#FFA500');
            }

            document.getElementById('distance').textContent = Math.floor(distance);
            document.getElementById('scoreDisplay').textContent = score;
            document.getElementById('comboDisplay').textContent = combo;

            // Kokpit hız göstergesi güncellemesi ve renk kodlaması
            if (currentSpeedGauge) { 
                const speedValue = Math.floor(carSpeed);
                currentSpeedGauge.textContent = speedValue; 
                let color = '#00FF00'; 

                if (speedValue >= 0 && speedValue <= 90) {
                    color = '#00FF00'; 
                } else if (speedValue > 90 && speedValue <= 150) {
                    color = '#FFA500'; 
                } else { 
                    color = '#FF0000'; 
                }
                currentSpeedGauge.style.color = color; 
                
                if (gaugeRing) { 
                     gaugeRing.style.borderColor = color;
                }
            }

            if (combo > 0 && Date.now() - lastComboTime > 3000) combo = 0;
            if (combo > highCombo) highCombo = combo;

            trafficCars.forEach(trafficCar => {
                if (!trafficCar.userData.isPolice && trafficCar.visible) {
                    const distanceToTrafficCarZ = Math.abs(car.position.z - trafficCar.position.z);
                    const distanceToTrafficCarX = Math.abs(car.position.x - trafficCar.position.x);
                    const carHalfWidth = 1.3; 
                    const trafficCarHalfWidth = (trafficCar.userData.type === 'truck' || trafficCar.userData.type === 'bus' ? 1.4 : 1.0); 

                    if (distanceToTrafficCarZ < (5.0/2 + trafficCar.userData.length/2) && 
                        distanceToTrafficCarX < (carHalfWidth + trafficCarHalfWidth + 0.3) && 
                        distanceToTrafficCarX > (carHalfWidth + trafficCarHalfWidth - 0.5) && 
                        Math.sign(carSpeed) === Math.sign(baseTrafficSpeed) && carSpeed > 30) { 
                        
                        if (!trafficCar.userData.nearMissAwarded) { 
                            showCombo('YAKIN GEÇİŞ!', 100);
                            trafficCar.userData.nearMissAwarded = true; 
                            setTimeout(() => { 
                                if(trafficCar.userData) trafficCar.userData.nearMissAwarded = false;
                            }, 2000); 
                        }
                    }
                }
            });

        }

        function addScore(points, multiplier = 1.0) {
            const comboMultiplier = 1 + (combo * 0.1);
            const totalPoints = Math.floor(points * comboMultiplier * multiplier);
            score += totalPoints;

            if (totalPoints > 50) {
                showScoreFeedback(`+${totalPoints}`, '#00FF00');
            }

            if (points > 20 && totalPoints > 0) { 
                combo++;
                lastComboTime = Date.now();
                if (combo % 5 === 0 && combo > 0) { 
                    showCombo(`${combo}X KOMBO!`, 100 + (combo * 10));
                }
            }
        }

        function showCombo(text, bonus) {
            const comboText = document.getElementById('comboText');
            comboText.textContent = `💥 ${text} 💥`;
            comboText.style.display = 'block';
            comboText.style.animation = 'none';
            void comboText.offsetWidth;
            comboText.style.animation = 'comboAnim 1.5s cubic-bezier(0.25, 0.46, 0.45, 0.94) forwards';

            if (bonus) addScore(bonus, 1.0);
        }

        function showScoreFeedback(text, color) {
            const feedback = document.getElementById('scoreFeedback');
            let emoji = '';
            if (text.includes('+')) emoji = '✅'; 
            else if (text.includes('SEVİYE')) emoji = '🌟'; 
            else if (text.includes('POLİS')) emoji = '🚨';
            else if (text.includes('RADAR')) emoji = '📡';
            else if (text.includes('ROKET')) emoji = '🚀';

            feedback.textContent = `${emoji} ${text}`;
            feedback.style.color = color;
            feedback.style.textShadow = `0 0 5px ${color}80, 0 0 10px ${color}50`;
            feedback.style.animation = 'none';
            void feedback.offsetWidth;
            feedback.style.animation = 'scoreFeedbackAnim 1.0s ease-out forwards';
        }

        function checkRadar() {
            const radarDetectionRange = 10;
            const speedingThreshold = 120;

            radarPoles.forEach(radar => {
                if (!radar) return; 
                const distanceToRadar = car.position.z - radar.position.z;
                const radarX = radar.position.x;
                const carX = car.position.x;
                const currentSpeedKmH = Math.floor(carSpeed);

                if (distanceToRadar > -radarDetectionRange && distanceToRadar < radarDetectionRange &&
                    Math.abs(carX - radarX) < (roadsideWidth / 2 + 1) && 
                    currentSpeedKmH > speedingThreshold &&
                    (Date.now() - (radar.userData.lastHit || 0) > radar.userData.hitCooldown)) { 

                    const deductionAmount = Math.floor(score * 0.33); 
                    score = Math.max(0, score - deductionAmount);
                    document.getElementById('scoreDisplay').textContent = score;
                    showScoreFeedback(`RADAR CEZASI! -${deductionAmount}`, '#FF6347'); 
                    showSpeedingMessage(); 
                    
                    radar.userData.lastHit = Date.now();
                }
            });
        }


        function showSpeedingMessage() {
            const messageDiv = document.createElement('div');
            messageDiv.textContent = '🚨 RADARA YAKALANDIN! 🚨';
            messageDiv.style.cssText = `
                position: absolute;
                top: 25%;
                left: 50%;
                transform: translate(-50%, -50%);
                background: rgba(255, 0, 0, 0.8);
                color: white;
                padding: 20px 30px;
                border-radius: 10px;
                font-size: 32px;
                font-weight: bold;
                text-shadow: 2px 2px 5px rgba(0,0,0,0.7);
                z-index: 250;
                animation: fadeOut 2s forwards;
            `;
            document.body.appendChild(messageDiv);
            setTimeout(() => { messageDiv.remove(); }, 2000);
        }

        function createSkyDome() {
            const skyGeometry = new THREE.SphereGeometry(700, 32, 15); 
            const skyMaterial = new THREE.MeshBasicMaterial({
                color: 0x87CEEB, 
                side: THREE.BackSide,
                fog: false 
            });
            skyDome = new THREE.Mesh(skyGeometry, skyMaterial);
            scene.add(skyDome);
        }

        function createMountains() {
            const mountainMaterial = new THREE.MeshStandardMaterial({
                color: 0x6B8E23, 
                roughness: 0.9,
                metalness: 0.0
            });
            const peakMaterial = new THREE.MeshStandardMaterial({
                color: 0xA9A9A9, 
                roughness: 0.7,
                metalness: 0.1
            });

            const numMountains = 10; 
            const mountainBaseZ = -700; 
            const mountainSpacing = 200; 

            for (let i = 0; i < numMountains; i++) {
                const mountainGroup = new THREE.Group();
                const baseHeight = Math.random() * 50 + 70; 
                const baseWidth = Math.random() * 80 + 120; 

                const mountainGeometry = new THREE.ConeGeometry(baseWidth / 2, baseHeight, Math.floor(Math.random()*3)+5); 
                const mountainBody = new THREE.Mesh(mountainGeometry, mountainMaterial);
                mountainBody.position.y = baseHeight / 2 - 10; 
                mountainBody.castShadow = true;
                mountainGroup.add(mountainBody);

                const numPeaks = Math.floor(Math.random() * 2) + 1; 
                for (let j = 0; j < numPeaks; j++) {
                    if (Math.random() < 0.7) { 
                        const peakHeight = Math.random() * 20 + 20;
                        const peakWidth = Math.random() * 20 + 15;
                        const peakGeometry = new THREE.ConeGeometry(peakWidth / 2, peakHeight, 5);
                        const peak = new THREE.Mesh(peakGeometry, peakMaterial);
                        peak.position.set(
                            (Math.random() - 0.5) * (baseWidth * 0.3),
                            baseHeight + (peakHeight / 2) - 15, 
                            (Math.random() - 0.5) * (baseWidth * 0.15)
                        );
                        mountainBody.add(peak);
                    }
                }

                const xPos = (i % 2 === 0 ? -1 : 1) * (roadWidth / 2 + roadsideWidth + 80 + Math.random() * 100); 
                const zPos = camera.position.z + mountainBaseZ - (i * mountainSpacing) - (Math.random() * mountainSpacing / 2);

                mountainGroup.position.set(xPos, 0, zPos);
                scene.add(mountainGroup);
                mountains.push(mountainGroup);
            }
        }

        function updateMountains() {
            const mountainRemovalDistance = camera.position.z + 100; 
            const mountainSpawnBehindDistance = mountains.length * 200; 

            mountains.forEach(mountain => {
                if (!mountain) return; 
                mountain.position.z += roadSpeed + (carSpeed / 100); 

                if (mountain.position.z > mountainRemovalDistance) {
                    mountain.position.z -= mountainSpawnBehindDistance + Math.random() * 50;
                    mountain.position.x = (Math.random() < 0.5 ? -1 : 1) * (roadWidth / 2 + roadsideWidth + 80 + Math.random() * 100);
                }
            });
        }


        function update() {
            if (gameRunning) {
                updateCarPosition();
                updateTraffic();
                updateRoad();
                updateRoadsideElements();
                checkCollisions();
                updateScoreAndLevel(); 
                checkRadar();
                updateRocketPowerUps(); 
                updateRocket(); 

                if (engineGainNode && audioContext && engineBuffer) {
                    const minSpeed = 0; const maxSpeedForSound = maxSpeed;
                    const minVolume = 0.5; const maxVolume = 1.0;
                    const minPlaybackRate = 0.8; const maxPlaybackRate = 1.5;

                    engineGainNode.gain.setValueAtTime(THREE.MathUtils.mapLinear(carSpeed, minSpeed, maxSpeedForSound, minVolume, maxVolume), audioContext.currentTime);
                    if(engineSource.playbackRate) 
                       engineSource.playbackRate.setValueAtTime(THREE.MathUtils.mapLinear(carSpeed, minSpeed, maxSpeedForSound, minPlaybackRate, maxPlaybackRate), audioContext.currentTime);
                }

                const baseCameraFollowY = 9;  
                const baseCameraFollowZ = 14; 
                let dynamicFollowZOffset = 0;
                if (carSpeed > SPEED_EFFECT_THRESHOLD * 0.6) { 
                    dynamicFollowZOffset = THREE.MathUtils.mapLinear(carSpeed, SPEED_EFFECT_THRESHOLD * 0.6, maxSpeed, 0, 5); 
                }
                
                let dynamicFollowXOffset = 0;
                const maxTiltCameraShift = 2.5; 
                if (Math.abs(carTilt) > maxCarTilt * 0.2) { 
                    dynamicFollowXOffset = -carTilt * (maxTiltCameraShift / maxCarTilt) * 2; 
                }

                const cameraFollowX = (car.position.x * 0.15) + dynamicFollowXOffset; 
                
                const cameraFollowY = baseCameraFollowY; 
                const cameraFollowZ = baseCameraFollowZ + dynamicFollowZOffset;
                const lerpFactor = 0.04; 

                camera.position.x = THREE.MathUtils.lerp(camera.position.x, cameraFollowX, lerpFactor);
                camera.position.y = THREE.MathUtils.lerp(camera.position.y, cameraFollowY, lerpFactor);
                camera.position.z = THREE.MathUtils.lerp(camera.position.z, cameraFollowZ, lerpFactor);

                const targetLookAtX = car.position.x * 0.05; 
                
                const targetLookAtY = 2; 
                const targetLookAtZ = -5;  
                let currentLookAtTarget = new THREE.Vector3();
                camera.getWorldDirection(currentLookAtTarget); 
                currentLookAtTarget.multiplyScalar(10).add(camera.position); 
                let newLookAtTarget = new THREE.Vector3(targetLookAtX, targetLookAtY, targetLookAtZ);
                currentLookAtTarget.lerp(newLookAtTarget, lerpFactor * 1.5); 
                camera.lookAt(currentLookAtTarget.x, currentLookAtTarget.y, currentLookAtTarget.z);

                if (carSpeed > SPEED_EFFECT_THRESHOLD) {
                    cameraShakeIntensity = THREE.MathUtils.mapLinear(carSpeed, SPEED_EFFECT_THRESHOLD, maxSpeed, 0, maxCameraShakeIntensity * 0.6); 
                } else {
                    cameraShakeIntensity = THREE.MathUtils.lerp(cameraShakeIntensity, 0, 0.1);
                }
                camera.position.y += (Math.sin(Date.now() * 0.015) * cameraShakeIntensity * 0.8); 
                camera.position.x += (Math.cos(Date.now() * 0.018) * cameraShakeIntensity * 0.4); 
                const tiltShakeFactor = 0.005; 
                camera.position.y += Math.abs(carTilt) * tiltShakeFactor;
                
                if (skyDome) { 
                    skyDome.position.copy(camera.position); 
                }
                updateMountains();
            } 

            renderer.render(scene, camera);
            animationFrameId = requestAnimationFrame(update);
        }


        function render() { 
            renderer.render(scene, camera);
        }

        async function loadSound(urls) { 
            if (!audioContext) {
                console.warn("loadSound: AudioContext not yet initialized.");
                return null;
            }

            let audioBuffer = null;
            for (const url of urls) {
                try {
                    const response = await fetch(url);
                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status} for ${url}`);
                    }
                    const arrayBuffer = await response.arrayBuffer();
                    audioBuffer = await audioContext.decodeAudioData(arrayBuffer);
                    console.log(`Sound loaded: ${url}`);
                    return audioBuffer; 
                } catch (error) {
                    console.warn(`Error loading sound, trying next format: ${url}`, error);
                }
            }
            console.error(`Failed to load all sound formats. Sound will not play.`);
            return null; 
        }

        function playSound(buffer, volume = 1.0, loop = false) {
            if (!audioContext || !buffer) { 
                console.warn("playSound: AudioContext or sound buffer missing. Sound cannot be played.");
                return null;
            }

            const source = audioContext.createBufferSource();
            source.buffer = buffer;
            source.loop = loop;
            
            const gainNode = audioContext.createGain();
            gainNode.gain.setValueAtTime(volume, audioContext.currentTime);

            source.connect(gainNode);
            gainNode.connect(audioContext.destination);

            source.start(0);

            const soundControl = {
                source: source,
                gainNode: gainNode,
                playState: 'playing',
                stop: () => {
                    if (soundControl.playState === 'playing') {
                        source.stop();
                        source.disconnect(); 
                        gainNode.disconnect(); 
                        soundControl.playState = 'stopped';
                        console.log("Sound (from playSound) stopped.");
                    }
                },
                setVolume: (newVolume) => {
                    gainNode.gain.setValueAtTime(newVolume, audioContext.currentTime);
                }
            };
            return soundControl;
        }


        function initAudioAndLoadGame() {
            console.log("initAudioAndLoadGame function called.");

            if (!audioContext) {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
            }

            // Düzeltilmiş ses URL'leri ile Promise.all kullanılıyor.
            Promise.all([
                loadSound([ 
                    'https://raw.githubusercontent.com/atakancerrahoglu/Sounds/4a3997d17ffa66e70f7583006b687c979ace24af/engine_sound.mp3',
                    'https://raw.githubusercontent.com/atakancerrahoglu/Sounds/4a3997d17ffa66e70f7583006b687c979ace24af/engine_sound.ogg'
                ]),
                loadSound([ 
                    'https://raw.githubusercontent.com/atakancerrahoglu/Sounds/4a3997d17ffa66e70f7583006b687c979ace24af/brake_sound.mp3',
                    'https://raw.githubusercontent.com/atakancerrahoglu/Sounds/4a3997d17ffa66e70f7583006b687c979ace24af/brake_sound.ogg'
                ]),
                loadSound([ 
                    'https://raw.githubusercontent.com/atakancerrahoglu/Sounds/4a3997d17ffa66e70f7583006b687c979ace24af/police_sound.mp3',
                    'https://raw.githubusercontent.com/atakancerrahoglu/Sounds/4a3997d17ffa66e70f7583006b687c979ace24af/police_sound.ogg'
                ]),
                loadSound([ 
                    'https://raw.githubusercontent.com/atakancerrahoglu/Sounds/4a3997d17ffa66e70f7583006b687c979ace24af/intro.mp3',
                    'https://raw.githubusercontent.com/atakancerrahoglu/Sounds/4a3997d17ffa66e70f7583006b687c979ace24af/intro.ogg'
                ]),
                // Power-up sesi URL'si verilmediği için şimdilik null olarak kalacak
                Promise.resolve(null) 
            ]).then(buffers => {
                engineBuffer = buffers[0];
                brakeBuffer = buffers[1];
                policeSirenBuffer = buffers[2];
                introBuffer = buffers[3];
                powerUpCollectBuffer = buffers[4]; 

                if (introBuffer) {
                    console.log("Intro sound buffer loaded.");
                } else {
                    console.warn("Intro sound buffer not loaded or empty.");
                }
                if (engineBuffer) console.log("Engine sound buffer loaded."); else console.warn("Engine sound buffer not loaded.");
                if (brakeBuffer) console.log("Brake sound buffer loaded."); else console.warn("Brake sound buffer not loaded.");
                if (policeSirenBuffer) console.log("Police siren buffer loaded."); else console.warn("Police siren buffer not loaded.");
                if (powerUpCollectBuffer) console.log("Power-Up sound buffer loaded."); else console.warn("Power-Up sound buffer not loaded (URL not provided).");

            }).catch(error => {
                console.error("A serious error occurred while loading some sounds:", error);
            }).finally(() => { 
                console.log("Sound loading process complete, showing first screen.");
                showFirstScreen(); 
            });
        }

        function startEngineSound() {
            if (engineSource) { 
                engineSource.stop();
                engineSource.disconnect();
                engineSource = null;
                engineGainNode = null;
            }

            if (!engineBuffer || !audioContext) {
                console.warn("Engine sound could not be started: Buffer or AudioContext missing.");
                return;
            }

            engineSource = audioContext.createBufferSource();
            engineSource.buffer = engineBuffer;
            engineSource.loop = true;

            engineGainNode = audioContext.createGain();
            engineGainNode.gain.setValueAtTime(0.0, audioContext.currentTime); // Start with 0 volume
            engineGainNode.gain.linearRampToValueAtTime(0.5, audioContext.currentTime + 1); // Fade in engine sound over 1 second

            engineSource.connect(engineGainNode);
            engineGainNode.connect(audioContext.destination);

            engineSource.start(0); 
            console.log("Engine sound started with Web Audio API.");
        }

        init();
    </script>
</body>
</html>
