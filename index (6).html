<!DOCTYPE html>
<html lang="tr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Enhanced 3D Traffic Racer</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: linear-gradient(to bottom, #1e3c72, #2a5298); /* Koyu mavi arka plan */
            font-family: 'Arial', sans-serif;
            overflow: hidden;
            user-select: none;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            width: 100vw;
        }

        canvas {
            display: block;
            cursor: crosshair;
            position: absolute; /* Canvas'Ä±n diÄŸer UI elemanlarÄ±nÄ±n arkasÄ±nda olmasÄ±nÄ± saÄŸlar */
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }

        /* TÃ¼m UI elemanlarÄ± iÃ§in genel stil */
        .ui-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 100; /* UI elemanlarÄ±nÄ±n canvas'Ä±n Ã¶nÃ¼nde olmasÄ±nÄ± saÄŸlar */
            pointer-events: none; /* VarsayÄ±lan olarak olaylarÄ± geÃ§irme */
        }

        /* GiriÅŸ ekranlarÄ± iÃ§in genel stil */
        .screen {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: linear-gradient(135deg, rgba(0,0,0,0.8), rgba(20,20,20,0.8));
            color: white;
            padding: 30px;
            border-radius: 15px;
            text-align: center;
            z-index: 200;
            border: 2px solid rgba(255,255,255,0.2);
            backdrop-filter: blur(10px);
            max-width: 90%;
            pointer-events: all; /* Ekranlar aktifken olaylarÄ± yakala */
            display: none; /* VarsayÄ±lan olarak gizli */
        }

        /* Yeni Ä°lk GiriÅŸ EkranÄ± (Pre-Intro) Stilleri */
        #preIntroScreen {
            display: flex; /* BaÅŸlangÄ±Ã§ta gÃ¶rÃ¼nÃ¼r olacak */
            flex-direction: column;
            justify-content: center;
            align-items: center;
            padding: 40px 30px;
            background: black; /* Siyah arka plan */
        }

        #preIntroScreen h1.company-logo {
            font-family: 'Arial Black', sans-serif;
            font-size: 64px; /* Daha bÃ¼yÃ¼k */
            font-weight: bold;
            color: #FF8C00; /* Koyu turuncu */
            text-shadow:
                0 0 15px rgba(255,140,0,0.9), /* ParlaklÄ±k */
                0 0 30px rgba(255,140,0,0.7), /* Daha fazla parlaklÄ±k */
                5px 5px 15px rgba(0,0,0,0.9); /* Derinlik */
            margin-bottom: 40px;
            -webkit-text-stroke: 3px #A0522D; /* Daha koyu turuncu-kahverengi kenarlÄ±k */
            letter-spacing: 5px; /* Harf aralÄ±ÄŸÄ± */
        }

        #preIntroScreen .credits {
            margin-top: 40px;
            text-align: center;
        }

        #preIntroScreen .credits p {
            font-size: 18px;
            margin: 5px 0;
            color: #FF8C00; /* Turuncu */
            text-shadow:
                0 0 8px rgba(255,140,0,0.8),
                0 0 15px rgba(255,140,0,0.5);
            font-weight: bold;
        }

        /* YÃ¼kleme EkranÄ± Stilleri (ÅŸimdi ikinci ekran olacak) */
        #loadingScreen {
            flex-direction: column;
            justify-content: center;
            align-items: center;
            padding: 40px 30px;
        }

        /* Ä°lk GiriÅŸ EkranÄ± (ÅŸimdi Ã¼Ã§Ã¼ncÃ¼ ekran olacak) */
        #firstEntryScreen {
            flex-direction: column;
            justify-content: center;
            align-items: center;
            padding: 40px 30px;
        }

        #firstEntryScreen h1.company-logo {
            font-family: 'Arial Black', sans-serif;
            font-size: 56px; /* Daha bÃ¼yÃ¼k */
            font-weight: bold;
            color: #FF8C00; /* Koyu turuncu */
            text-shadow:
                0 0 10px rgba(255,140,0,0.7), /* ParlaklÄ±k */
                0 0 20px rgba(255,140,0,0.5), /* Daha fazla parlaklÄ±k */
                5px 5px 10px rgba(0,0,0,0.8); /* Derinlik */
            margin-bottom: 25px; /* AltÄ±ndaki baÅŸlÄ±ktan daha fazla boÅŸluk */
            -webkit-text-stroke: 2px #A0522D; /* Daha koyu turuncu-kahverengi kenarlÄ±k */
            letter-spacing: 3px; /* Harf aralÄ±ÄŸÄ± */
        }

        #firstEntryScreen h2.game-title {
            font-family: 'Arial', sans-serif;
            font-size: 38px; /* BÃ¼yÃ¼k */
            font-weight: bold;
            color: #C0C0C0; /* Metalik gri */
            text-shadow:
                0 0 5px rgba(192,192,192,0.5), /* Hafif parlaklÄ±k */
                0 0 10px rgba(192,192,192,0.3), /* Daha da hafif parlaklÄ±k */
                3px 3px 6px rgba(0,0,0,0.7); /* Derinlik */
            margin-bottom: 30px; /* Ä°sim giriÅŸinden Ã¶nce boÅŸluk */
            -webkit-text-stroke: 1px #808080; /* Koyu gri kenarlÄ±k */
            letter-spacing: 2px;
        }

        #firstEntryScreen .input-group {
            margin-bottom: 20px;
        }

        #firstEntryScreen label {
            display: block;
            margin-bottom: 10px;
            font-size: 20px;
            color: #E0E0E0;
            text-shadow: 1px 1px 3px rgba(0,0,0,0.6);
        }

        #firstEntryScreen input[type="text"] {
            padding: 12px 15px;
            border-radius: 8px;
            border: 2px solid #555;
            background-color: rgba(255,255,255,0.1);
            color: white;
            font-size: 18px;
            width: 250px;
            max-width: 80%;
            text-align: center;
            box-shadow: inset 0 0 8px rgba(0,0,0,0.5);
            transition: border-color 0.3s ease;
        }

        #firstEntryScreen input[type="text"]:focus {
            outline: none;
            border-color: #007bff;
            box-shadow: inset 0 0 8px rgba(0,123,255,0.5), 0 0 10px rgba(0,123,255,0.3);
        }

        /* Ä°kinci GiriÅŸ EkranÄ± Stilleri */
        #secondStartScreen {
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            padding: 50px 30px;
        }

        #secondStartScreen .welcome-message {
            font-size: 28px;
            color: #E0E0E0;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.7);
            margin-bottom: 40px; /* Butondan Ã¶nce boÅŸluk */
        }

        /* Ortak Buton Stilleri */
        button {
            background: linear-gradient(45deg, #66BB6A, #4CAF50); /* Daha aÃ§Ä±k yeÅŸil */
            color: white;
            border: 2px solid rgba(255,255,255,0.3); /* Belirgin Ã§erÃ§eve */
            padding: 15px 30px; /* Daha bÃ¼yÃ¼k butonlar */
            font-size: 20px; /* Daha bÃ¼yÃ¼k font */
            border-radius: 10px; /* Daha yuvarlak kÃ¶ÅŸeler */
            cursor: pointer;
            margin-top: 20px; /* Butonlar arasÄ± boÅŸluk */
            transition: all 0.2s ease; /* Daha hÄ±zlÄ± geÃ§iÅŸ */
            box-shadow: 0 6px 15px rgba(0,0,0,0.4); /* Hafif gÃ¶lge */
            font-weight: bold;
            letter-spacing: 1px;
        }

        button:hover {
            transform: translateY(-3px);
            box-shadow: 0 8px 20px rgba(0,0,0,0.6);
            background: linear-gradient(45deg, #76C77C, #5CBF60); /* Hover rengi */
        }

        button:active {
            background: linear-gradient(45deg, #388E3C, #4CAF50); /* Daha koyu yeÅŸil */
            transform: translateY(0px);
            box-shadow: 0 2px 8px rgba(0,0,0,0.5);
        }

        /* GAZLA Butonu iÃ§in Ã¶zel stil */
        #gasButton {
            padding: 25px 50px;
            font-size: 36px;
            border-radius: 20px;
            background: linear-gradient(45deg, #FF4500, #FF6347); /* Turuncu tonlarÄ± */
            border: 3px solid rgba(255,255,255,0.5);
            box-shadow: 0 10px 25px rgba(255,69,0,0.6);
            text-shadow: 0 0 10px rgba(0,0,0,0.8);
        }

        #gasButton:hover {
            background: linear-gradient(45deg, #FF6347, #FF7F50);
            box-shadow: 0 12px 30px rgba(255,69,0,0.8);
            transform: translateY(-5px);
        }

        #gasButton:active {
            background: linear-gradient(45deg, #CC3300, #DD4400);
            box-shadow: 0 5px 15px rgba(255,69,0,0.5);
            transform: translateY(0px);
        }


        /* Oyun Ä°Ã§i UI ElemanlarÄ± */
        .ui, .top-info, .health-bar-container, .combo, .score-feedback,
        .instructions, .speed-controls, .rocket-btn, .mobile-controls, .speed-display, .game-over {
            display: none; /* BaÅŸlangÄ±Ã§ta hepsi gizli */
            pointer-events: none; /* VarsayÄ±lan olarak olaylarÄ± geÃ§irme */
        }

        /* Oyun baÅŸladÄ±ÄŸÄ±nda gÃ¶rÃ¼nÃ¼r olacak UI elemanlarÄ± */
        body.game-active .ui,
        body.game-active .top-info,
        body.game-active .health-bar-container,
        /* body.game-active .instructions, */ /* Konsol ile deÄŸiÅŸtirildiÄŸi iÃ§in kaldÄ±rÄ±ldÄ± */
        body.game-active .speed-controls,
        body.game-active .rocket-btn, /* Roket tuÅŸu eklendi */
        body.game-active .mobile-controls,
        /* body.game-active .speed-display, */ /* HÄ±z gÃ¶stergesi kokpite taÅŸÄ±ndÄ±ÄŸÄ± iÃ§in kaldÄ±rÄ±ldÄ± */
        body.game-active .cockpit-console, /* Kokpit konsolu gÃ¶rÃ¼nÃ¼r olacak */
        body.game-active .speed-display-new {
            display: block; /* Veya flex, duruma gÃ¶re */
            pointer-events: auto; /* Oyun baÅŸladÄ±ÄŸÄ±nda olaylarÄ± yakala */
        }

        /* Ã–zel flexbox dÃ¼zenlemeleri */
        body.game-active .top-info {
            display: flex;
            flex-direction: column;
            align-items: flex-end;
            gap: 8px;
            position: absolute;
            top: 10px;
            right: 10px;
            z-index: 100;
        }

        body.game-active .speed-controls,
        body.game-active .mobile-controls,
        body.game-active .speed-display-new {
            display: flex;
        }

        /* Roket tuÅŸu stil baÅŸlangÄ±cÄ± */
        .rocket-btn {
            position: absolute;
            bottom: 50px; /* HÄ±z kontrol butonlarÄ±nÄ±n alt hizasÄ±na getirildi */
            left: 100px; /* HÄ±zlan/YavaÅŸla butonlarÄ±nÄ±n saÄŸÄ±na kaydÄ±rÄ±ldÄ± (varsayÄ±lan hÄ±zlan/yavaÅŸla butonu geniÅŸliÄŸi 80px + biraz boÅŸluk) */
            width: 100px;
            height: 60px;
            background: linear-gradient(45deg, #FF4500, #FF0000);
            border: 2px solid rgba(255,255,255,0.4);
            border-radius: 10px;
            color: white;
            font-size: 18px;
            font-weight: bold;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            user-select: none;
            backdrop-filter: blur(5px);
            transition: all 0.2s ease;
            box-shadow: 0 4px 10px rgba(0,0,0,0.4);
            z-index: 100;
        }

        .rocket-btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 6px 15px rgba(0,0,0,0.6);
            background: linear-gradient(45deg, #FF6347, #FF3333); /* Hover rengi */
        }

        .rocket-btn:active {
            transform: translateY(0px);
            box-shadow: 0 2px 5px rgba(0,0,0,0.5);
            background: linear-gradient(45deg, #CC3300, #CC0000); /* Active rengi */
        }
        /* Roket tuÅŸu stil sonu */

        /* Mevcut UI stilleri (sadece oyun aktifken gÃ¶rÃ¼nÃ¼r) */
        .ui {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            font-size: 16px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
            z-index: 100;
            background: rgba(0,0,0,0.3);
            padding: 10px;
            border-radius: 8px;
            backdrop-filter: blur(5px);
        }

        .info-box {
            background: rgba(0,0,0,0.4);
            color: white;
            padding: 8px 15px;
            border-radius: 8px;
            font-size: 20px;
            font-weight: bold;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
            backdrop-filter: blur(5px);
            min-width: 120px;
            text-align: right;
        }

        /* NEW: Health Bar Styles */
        .health-bar-container {
            position: absolute;
            top: 50%; /* Center vertically */
            right: 50px; /* Position on the far right, adjust as needed */
            transform: translateY(-50%); /* Adjust for perfect vertical centering */
            width: 20px; /* Daha ince yapÄ±ldÄ± */
            height: 150px; /* Height of the bar */
            background: rgba(255,255,255,0.2);
            border-radius: 5px;
            overflow: hidden;
            border: 2px solid rgba(255,255,255,0.3);
            z-index: 100;
            display: flex;
            align-items: flex-start; /* Dolum yukarÄ±dan baÅŸlasÄ±n diye deÄŸiÅŸtirildi */
        }

        .health-label {
            position: absolute;
            top: -25px; /* Above the bar */
            right: 0;
            width: 100%;
            text-align: center;
            color: white;
            font-size: 16px;
            font-weight: bold;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.8);
            z-index: 101;
        }

        .health-fill {
            height: 100%; /* BaÅŸlangÄ±Ã§ta tam dolu olsun */
            background: hsl(120, 100%, 40%); /* BaÅŸlangÄ±Ã§ rengi yeÅŸil */
            transition: height 0.3s ease-out, background-color 0.3s ease-out; /* Hem yÃ¼kseklik hem renk geÃ§iÅŸi ekle */
            width: 100%; /* GeniÅŸliÄŸi de tam olsun */
        }

        .game-over {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: linear-gradient(135deg, rgba(0,0,0,0.9), rgba(20,20,20,0.9));
            color: white;
            padding: 30px;
            border-radius: 15px;
            text-align: center;
            z-index: 200;
            border: 2px solid rgba(255,255,255,0.2);
            backdrop-filter: blur(10px);
            box-shadow: 0 20px 40px rgba(0,0,0,0.5);
            max-width: 90%;
            pointer-events: all;
        }

        .instructions {
            /* Bu kÄ±sÄ±m artÄ±k kullanÄ±lmÄ±yor, cockpit-console ile deÄŸiÅŸtirildi */
            display: none !important;
        }

        .combo {
            position: absolute;
            top: 3%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #FFFF00;
            font-size: 38px;
            font-weight: bolder;
            text-shadow:
                0 0 8px rgba(255,255,0,0.7),
                0 0 15px rgba(255,165,0,0.7),
                0 0 20px rgba(255,0,0,0.7),
                3px 3px 5px rgba(0,0,0,0.9);
            z-index: 150;
            animation: comboAnim 1.5s cubic-bezier(0.25, 0.46, 0.45, 0.94) forwards;
            letter-spacing: 1px;
            -webkit-text-stroke: 1px black;
        }

        @keyframes comboAnim {
            0% { opacity: 0; transform: translate(-50%, -50%) scale(0.5); letter-spacing: -3px; }
            30% { opacity: 1; transform: translate(-50%, -50%) scale(1.1); letter-spacing: 3px; }
            70% { opacity: 1; transform: translate(-50%, -50%) scale(1.0); letter-spacing: 1px; }
            100% { opacity: 0; transform: translate(-50%, -50%) scale(0.9); }
        }

        .score-feedback {
            position: absolute;
            top: 8%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #00FF00;
            font-size: 28px;
            font-weight: bold;
            text-shadow: 0 0 4px rgba(0,255,0,0.8), 0 0 8px rgba(0,255,0,0.5);
            z-index: 160;
            opacity: 0;
            animation: scoreFeedbackAnim 1.0s ease-out forwards;
            pointer-events: none;
        }

        @keyframes scoreFeedbackAnim {
            0% { opacity: 0; transform: translate(-50%, -30%) scale(0.7); }
            20% { opacity: 1; transform: translate(-50%, -50%) scale(1.0); }
            80% { opacity: 1; transform: translate(-50%, -70%) scale(0.9); }
            100% { opacity: 0; transform: translate(-50%, -80%) scale(0.8); }
        }

        .speed-controls {
            position: absolute;
            bottom: 30px; /* YavaÅŸla tuÅŸuyla aynÄ± hizada kalmasÄ± iÃ§in ayarlandÄ± */
            left: 10px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            z-index: 100;
        }

        .speed-btn {
            width: 80px;
            height: 50px;
            background: linear-gradient(45deg, rgba(255,255,255,0.3), rgba(200,200,200,0.3));
            border: 2px solid rgba(255,255,255,0.4);
            border-radius: 8px;
            color: white;
            font-size: 18px;
            font-weight: bold;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            user-select: none;
            backdrop-filter: blur(5px);
            transition: all 0.2s ease;
            box-shadow: 0 4px 10px rgba(0,0,0,0.4);
        }

        .speed-btn.accelerate { background: linear-gradient(45deg, rgba(0,200,0,0.5), rgba(0,150,0,0.5)); }
        .speed-btn.brake { background: linear-gradient(45deg, rgba(200,0,0,0.5), rgba(150,0,0,0.5)); }

        .speed-btn:active {
            transform: scale(0.95);
            box-shadow: 0 2px 5px rgba(0,0,0,0.5);
            background: linear-gradient(45deg, rgba(255,255,255,0.5), rgba(200,200,200,0.5));
        }

        .speed-btn.accelerate:active { background: linear-gradient(45deg, rgba(0,150,0,0.7), rgba(0,100,0,0.7)); }
        .speed-btn.brake:active { background: linear-gradient(45deg, rgba(150,0,0,0.7), rgba(100,0,0,0.7)); }


        .mobile-controls {
            position: absolute;
            bottom: 50px;
            right: 10px;
            display: flex;
            gap: 10px;
            z-index: 100;
        }

        .control-btn {
            width: 60px;
            height: 60px;
            background: linear-gradient(45deg, rgba(255,255,255,0.3), rgba(200,200,200,0.3));
            border: 2px solid rgba(255,255,255,0.4);
            border-radius: 50%;
            color: white;
            font-size: 24px;
            font-weight: bold;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            user-select: none;
            backdrop-filter: blur(5px);
            transition: all 0.2s ease;
            box-shadow: 0 4px 10px rgba(0,0,0,0.4);
        }

        .control-btn:active {
            background: linear-gradient(45deg, rgba(255,255,255,0.5), rgba(200,200,200,0.5));
            transform: scale(0.95);
            box-shadow: 0 2px 5px rgba(0,0,0,0.5);
        }

        .time-of-day-info {
            color: white;
            font-size: 16px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
            margin-top: 5px;
            display: block;
        }

        @keyframes fadeOut {
            0% { opacity: 1; transform: translate(-50%, -50%) scale(1); }
            100% { opacity: 0; transform: translate(-50%, -100%) scale(0.8); }
        }

        /* HÄ±z GÃ¶stergesi Div'ini gizle, Ã§Ã¼nkÃ¼ artÄ±k kokpit iÃ§inde gÃ¶sterilecek */
        .speed-display {
            display: none !important;
        }

        .speed-bar-container, .speed-bar-fill {
            display: none;
        }

        /* NEW: Kokpit Konsolu Stilleri */
        .cockpit-console {
            position: absolute;
            bottom: -50px; /* BaÅŸlangÄ±Ã§ta ekranÄ±n biraz altÄ±nda */
            left: 50%;
            transform: translateX(-50%);
            width: 300px; /* GeniÅŸlik ayarlandÄ± */
            max-width: 90%;
            height: 250px; /* Konsolun yÃ¼ksekliÄŸi ayarlandÄ± */
            background: linear-gradient(to bottom, #3a3a3a, #1a1a1a); /* Koyu gri gradient */
            border-radius: 20px 20px 0 0; /* Ãœst kÃ¶ÅŸeler yuvarlak */
            box-shadow: 0 -10px 20px rgba(0,0,0,0.7);
            padding: 15px;
            box-sizing: border-box;
            display: flex;
            flex-direction: column;
            align-items: center;
            opacity: 0; /* BaÅŸlangÄ±Ã§ta gÃ¶rÃ¼nmez */
            transition: bottom 0.8s ease-out, opacity 0.8s ease-out; /* Animasyon iÃ§in */
            z-index: 90; /* DiÄŸer UI elemanlarÄ±nÄ±n altÄ±nda */
            pointer-events: none; /* Konsol baÅŸlangÄ±Ã§ta etkileÅŸim kabul etmez */
        }

        /* Oyun baÅŸÄ±nda konsolun gÃ¶rÃ¼nÃ¼r olmasÄ± iÃ§in */
        body.game-active .cockpit-console {
            bottom: 10px; /* Oyun baÅŸladÄ±ÄŸÄ±nda ekranÄ±n altÄ±na gelsin */
            opacity: 1; /* GÃ¶rÃ¼nÃ¼r olsun */
            pointer-events: all; /* EtkileÅŸim kabul etsin */
        }

        /* Konsolun Ã¼st ve alt kenarlÄ±klarÄ± */
        .console-border-top {
            width: 100%;
            height: 10px;
            background: #555;
            border-radius: 10px 10px 0 0;
            margin-bottom: 5px;
        }
        .console-border-bottom {
            width: 100%;
            height: 10px;
            background: #555;
            border-radius: 0 0 10px 10px;
            margin-top: 5px;
        }

        .console-screen {
            width: 100%;
            background-color: #0d0d0d; /* EkranÄ±n koyu arka planÄ± */
            border: 2px solid #222;
            border-radius: 8px;
            padding: 10px;
            box-sizing: border-box;
            text-align: center;
            color: #00FF00; /* YeÅŸil metin */
            font-family: 'Consolas', monospace;
            font-size: 16px;
            text-shadow: 0 0 5px rgba(0,255,0,0.5); /* YeÅŸil parlaklÄ±k */
            display: flex; /* Ä°Ã§eriklerini flexbox ile yÃ¶netmek iÃ§in */
            flex-direction: column; /* Kontroller baÅŸlÄ±ÄŸÄ± Ã¼ste, iÃ§erik alta */
            align-items: center; /* Ortalamak iÃ§in */
        }

        .console-screen p {
            margin-top: 0;
            margin-bottom: 10px;
            font-weight: bold;
        }

        .cockpit-content {
            display: flex;
            justify-content: space-around; /* Elemanlar arasÄ±nda eÅŸit boÅŸluk bÄ±rak */
            align-items: center; /* Dikeyde ortala */
            width: 100%;
            flex-grow: 1; /* Kalan alanÄ± kapla */
            padding-bottom: 10px; /* Alt boÅŸluk */
        }

        .key-display-group {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .key-group-left {
            align-items: flex-end; /* Sol gruptaki tuÅŸlarÄ± saÄŸa hizala */
            padding-right: 15px; /* Kadranla arasÄ±na boÅŸluk */
        }

        .key-group-right {
            align-items: flex-start; /* SaÄŸ gruptaki tuÅŸlarÄ± sola hizala */
            padding-left: 15px; /* Kadranla arasÄ±na boÅŸluk */
        }

        .key-row {
            display: flex;
            gap: 5px;
            justify-content: center; /* TuÅŸlarÄ± ortala */
        }
        .key-row-left {
             /* TuÅŸlarÄ± kendi grubunda saÄŸa hizala */
            justify-content: flex-end;
        }
        .key-row-right {
            /* TuÅŸlarÄ± kendi grubunda sola hizala */
            justify-content: flex-start;
        }
        .key-row-single {
            margin-top: 10px;
        }


        .key-button {
            width: 40px;
            height: 40px;
            background: rgba(50,50,50,0.8); /* Koyu gri tuÅŸ arka planÄ± */
            border: 2px solid #666;
            border-radius: 5px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 18px;
            font-weight: bold;
            color: #C0C0C0; /* Gri tuÅŸ metni */
            text-shadow: 1px 1px 2px rgba(0,0,0,0.6);
            box-shadow: inset 0 0 5px rgba(0,0,0,0.5);
            transition: background-color 0.1s ease, box-shadow 0.1s ease, color 0.1s ease;
        }

        .key-button-large {
            width: 80px; /* Daha geniÅŸ tuÅŸlar iÃ§in */
        }

        /* TuÅŸa basÄ±ldÄ±ÄŸÄ±nda vurgu */
        .key-button.active {
            background-color: #00FF00; /* YeÅŸil vurgu */
            color: black; /* Siyah metin */
            box-shadow: inset 0 0 8px rgba(0,255,0,0.8), 0 0 10px rgba(0,255,0,0.5); /* YeÅŸil parlaklÄ±k */
        }

        /* NEW: HÄ±z KadranÄ± Stilleri */
        .speed-gauge {
            position: relative;
            width: 120px; /* Kadran geniÅŸliÄŸi */
            height: 120px; /* Kadran yÃ¼ksekliÄŸi */
            border-radius: 50%;
            background: radial-gradient(circle at center, #111 0%, #333 70%, #555 100%); /* Hafif iÃ§bÃ¼key efekt */
            box-shadow: inset 0 0 10px rgba(0,0,0,0.8), 0 0 15px rgba(0,0,0,0.5);
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 28px;
            font-weight: bolder;
            text-shadow: 0 0 8px rgba(255,255,255,0.7);
            border: 3px solid #666; /* DÄ±ÅŸ Ã§erÃ§eve */
        }

        .gauge-ring {
            position: absolute;
            width: 100%;
            height: 100%;
            border-radius: 50%;
            border: 8px solid transparent; /* KalÄ±n halka */
            border-top-color: #4CAF50; /* BaÅŸlangÄ±Ã§ rengi yeÅŸil */
            border-right-color: #4CAF50;
            border-bottom-color: #4CAF50;
            border-left-color: #4CAF50;
            transform: rotate(-45deg); /* HalkanÄ±n baÅŸlangÄ±Ã§ aÃ§Ä±sÄ±nÄ± ayarla */
            box-sizing: border-box;
            transition: border-color 0.3s ease; /* Renk geÃ§iÅŸi iÃ§in */
        }

        .gauge-center {
            position: relative; /* Ä°Ã§erik iÃ§in */
            z-index: 2; /* HalkanÄ±n Ã¼zerinde olsun */
            text-align: center;
        }

        #currentSpeedGauge {
            display: block; /* SayÄ± ve etiket alt alta gelsin */
            font-size: 32px; /* SayÄ± boyutu */
            line-height: 1;
            /* Renk JavaScript ile yÃ¶netilecek */
        }

        .gauge-label {
            font-size: 12px;
            color: #DDD;
            margin-top: 5px;
        }

        /* Mobil ekranlar iÃ§in uyarlama */
        @media (max-width: 768px) {
            .cockpit-console {
                width: 280px; /* Daha geniÅŸ mobil konsol */
                height: 200px; /* Mobil konsol yÃ¼ksekliÄŸi */
                padding: 10px;
                bottom: 5px; 
            }
            .console-screen {
                font-size: 14px;
            }
            .key-button {
                width: 30px;
                height: 30px;
                font-size: 14px;
            }
            .key-button-large {
                width: 60px;
            }
            body.game-active .cockpit-console {
                bottom: 5px; 
            }
            .speed-gauge {
                width: 100px;
                height: 100px;
            }
            #currentSpeedGauge {
                font-size: 28px;
            }
            .speed-display-new {
                top: 130px; /* .ui kutusunun altÄ±na yerleÅŸtirildi */
                left: 10px;
                bottom: auto;
                right: auto;
                width: auto;
                height: auto;
                background: transparent;
                border: none;
                backdrop-filter: none;
                box-shadow: none;
                padding: 0;
            }

            #newSpeedValue {
                font-size: 32px; /* Daha gÃ¶rÃ¼nÃ¼r olmasÄ± iÃ§in bÃ¼yÃ¼tÃ¼ldÃ¼ */
                font-weight: bold;
            }

            .speed-display-new .speed-label {
                display: none;
            }
        }

        /* Yeni HÄ±z GÃ¶stergesi */
        .speed-display-new {
            position: absolute;
            bottom: 50px;
            left: 210px; /* Roket tuÅŸunun saÄŸÄ±na */
            width: 120px;
            height: 60px;
            background: rgba(0,0,0,0.5);
            border-radius: 10px;
            border: 2px solid rgba(255,255,255,0.2);
            flex-direction: column;
            align-items: center;
            justify-content: center;
            font-family: 'Arial Black', sans-serif;
            color: white;
            text-shadow: 0 0 8px rgba(255,255,255,0.7);
            z-index: 100;
            backdrop-filter: blur(5px);
            display: none; /* BaÅŸlangÄ±Ã§ta gizli */
        }

        #newSpeedValue {
            font-size: 32px;
            font-weight: bold;
            line-height: 1;
            transition: color 0.3s ease;
        }

        .speed-display-new .speed-label {
            font-size: 14px;
            font-weight: normal;
            letter-spacing: 1px;
        }

        /* Rekorlar Listesi Stili */
        #highScores {
            margin-top: 25px;
            padding-top: 15px;
            border-top: 1px solid rgba(255,255,255,0.2);
            width: 80%;
            max-width: 300px;
            margin-left: auto;
            margin-right: auto;
        }

        #highScores h3 {
            font-size: 22px;
            color: #FFD700;
            margin-bottom: 10px;
        }

        #highScoreList {
            list-style-type: none;
            padding: 0;
            margin: 0;
            text-align: left;
        }

        #highScoreList li {
            background: rgba(255,255,255,0.05);
            padding: 8px 12px;
            margin-bottom: 5px;
            border-radius: 5px;
            font-size: 18px;
            display: flex;
            justify-content: space-between;
        }

        #highScoreList li .score {
            font-weight: bold;
            color: #4CAF50;
        }

        #sirenStarsContainer {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 101;
            display: flex;
            gap: 10px;
            pointer-events: none;
        }

        .siren-star {
            font-size: 40px; /* Biraz daha bÃ¼yÃ¼k */
            color: transparent; /* Ä°Ã§ini boÅŸalt */
            -webkit-text-stroke: 2px rgba(255, 215, 0, 0.5); /* BoÅŸ yÄ±ldÄ±z Ã§erÃ§evesi (soluk sarÄ±) */
            text-stroke: 2px rgba(255, 215, 0, 0.5);
            text-shadow: 0 0 8px rgba(0,0,0,1); /* OkunabilirliÄŸi artÄ±r */
            transition: all 0.4s cubic-bezier(0.25, 0.46, 0.45, 0.94);
        }

        .siren-star.filled {
            color: #FFD700; /* Dolu yÄ±ldÄ±z rengi (parlak sarÄ±) */
            -webkit-text-stroke: 2px #FFA500; /* Dolu yÄ±ldÄ±z Ã§erÃ§evesi (turuncu-sarÄ±) */
            text-stroke: 2px #FFA500;
            text-shadow:
                0 0 5px #FFD700,
                0 0 10px #FF8C00,
                0 0 15px #FF0000; /* Parlama efekti */
        }

        /* ... DiÄŸer CSS stilleriniz burada ... */

        /* HÄ±z GÃ¶stergesi Stili */
        .speed-display {
            position: absolute;
            top: 70px; /* GÃ¼ndÃ¼z/Gece dÃ¶ngÃ¼sÃ¼nÃ¼n altÄ±na yerleÅŸtir */
            left: 20px;
            background-color: rgba(0, 0, 0, 0.6);
            color: #00ff00; /* Klasik dijital yeÅŸil */
            padding: 8px 15px;
            border-radius: 8px;
            border: 2px solid #00ff00;
            box-shadow: 0 0 10px #00ff00;
            font-family: 'Courier New', Courier, monospace;
            font-size: 28px;
            font-weight: bold;
            z-index: 101; /* DiÄŸer UI elemanlarÄ±nÄ±n Ã¼zerinde */
            display: none; /* Oyun baÅŸlayÄ±nca JS ile gÃ¶rÃ¼nÃ¼r yapÄ±lacak */
        }

        /* GÃ¼ndÃ¼z/Gece DÃ¶ngÃ¼sÃ¼ Bilgisi (Referans iÃ§in) */
        .day-cycle-info {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.5);
            color: white;
            padding: 10px;
            border-radius: 5px;
            font-family: Arial, sans-serif;
            font-size: 16px;
            z-index: 101;
            display: none;
        }

        /* Mobil Kontrollerin KapsayÄ±cÄ±sÄ± */
        .mobile-controls {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 35%; /* EkranÄ±n alt %35'lik kÄ±smÄ±nÄ± kaplasÄ±n */
            z-index: 150; /* Her ÅŸeyin Ã¼stÃ¼nde */
            display: none; /* Sadece mobil cihazlarda JS ile gÃ¶rÃ¼nÃ¼r yapÄ±lacak */
            pointer-events: none; /* KapsayÄ±cÄ±nÄ±n kendisi tÄ±klanmasÄ±n */
        }

        /* Mobil Kontrol ButonlarÄ± (Ortak Stil) */
        .mobile-btn {
            position: absolute;
            width: 80px;
            height: 80px;
            background-color: rgba(255, 255, 255, 0.2);
            border: 2px solid rgba(255, 255, 255, 0.5);
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 30px;
            color: white;
            pointer-events: all; /* Butonlar tÄ±klanabilsin */
            user-select: none; /* Metin seÃ§ilmesini engelle */
        }
        .mobile-btn.active {
            background-color: rgba(255, 255, 255, 0.5);
        }

        /* ButonlarÄ±n KonumlarÄ± */
        #left-btn {
            bottom: 20px;
            left: 20px;
        }
        #right-btn {
            bottom: 20px;
            left: 120px; /* Sol butonun yanÄ±nda */
        }
        #accelerate-btn {
            bottom: 120px; /* Frenin Ã¼stÃ¼nde */
            right: 20px;
        }
        #brake-btn {
            bottom: 20px;
            right: 20px;
        }

        /* ... DiÄŸer CSS stilleriniz burada devam ediyor ... */
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>

    <div class="ui-overlay">
        <!-- Yeni ilk giriÅŸ ekranÄ± (pre-intro) -->
        <div class="screen" id="preIntroScreen">
            <h1 class="company-logo">KuAtAmA Games</h1>
            <button id="gasButton">GAZLA!!!</button>
            <div class="credits">
                <p>Create By Atakan CerrahoÄŸlu</p>
                <p>MÃ¼zik: KÄ±rÄ±lmÄ±ÅŸ Kolum / Atakan CerrahoÄŸlu</p>
            </div>
        </div>

        <!-- YÃ¼kleme EkranÄ± (ÅŸimdi ikinci sÄ±rada) -->
        <div class="screen" id="loadingScreen">
            <h1 class="company-logo">KuAtAmA Games</h1>
            <p style="font-size: 24px; margin-top: 20px; color: #E0E0E0;">YÃ¼kleniyor...</p>
            <p id="loadingTip" style="font-size: 18px; margin-top: 20px; color: #ADD8E6; text-shadow: 1px 1px 3px rgba(0,0,0,0.5); opacity: 0; transition: opacity 0.5s ease-in-out; min-height: 40px;"></p>
            <div style="width: 200px; height: 4px; background: rgba(255,255,255,0.2); border-radius: 2px; overflow: hidden; margin-top: 30px;">
                <div id="progressBar" style="width: 0%; height: 100%; background: #4CAF50; transition: width 0.1s linear;"></div>
            </div>
        </div>

        <!-- Ä°sim GiriÅŸ EkranÄ± (ÅŸimdi Ã¼Ã§Ã¼ncÃ¼ sÄ±rada) -->
        <div class="screen" id="firstEntryScreen">
            <h1 class="company-logo">KuAtAmA Games</h1>
            <h2 class="game-title">Traffic Racer 3D</h2>
            <div class="input-group">
                <label for="playerNameInput">Ä°sim giriniz:</label>
                <input type="text" id="playerNameInput" placeholder="AdÄ±nÄ±z" maxlength="10">
            </div>
            <button id="playButton">Oyna</button>
        </div>

        <!-- BaÅŸlat EkranÄ± (ÅŸimdi dÃ¶rdÃ¼ncÃ¼ sÄ±rada) -->
        <div class="screen" id="secondStartScreen">
            <p class="welcome-message">Ä°yi oyunlar!</p>
            <button id="startButton">BAÅLA</button>
        </div>

        <div class="ui">
            <div>ğŸ“ Mesafe: <span id="distance">0</span>m</div>
            <div>â­ Seviye: <span id="level">1</span></div>
            <div>ğŸš€ Roketler: <span id="rocketsDisplay">0</span></div>
            <div class="time-of-day-info" id="timeOfDayInfo">
                â˜€ï¸ GÃ¼ndÃ¼z: <span id="timeOfDayDisplay">00:00</span>
            </div>
        </div>

        <div class="top-info">
            <div class="info-box">ğŸ’° Skor: <span id="scoreDisplay">0</span></div>
            <div class="info-box">ğŸ”¥ Kombo: <span id="comboDisplay">0</span></div>
        </div>

        <div class="health-bar-container">
            <div class="health-label">Can</div>
            <div class="health-fill" id="healthFill"></div>
        </div>

        <div class="combo" id="comboText">SÃœPER!</div>

        <div id="scoreFeedback" class="score-feedback"></div>

        <div class="cockpit-console" id="cockpitConsole">
            <div class="console-border-top"></div>
            <div class="console-screen">
                <p>KONTROLLER</p>
                <div class="cockpit-content">
                    <div class="key-display-group key-group-left">
                        <div class="key-row key-row-left">
                            <div class="key-button" id="keyW">W</div>
                            <div class="key-button" id="keyUp">â†‘</div>
                        </div>
                        <div class="key-row key-row-left">
                            <div class="key-button" id="keyA">A</div>
                            <div class="key-button" id="keyS">S</div>
                            <div class="key-button" id="keyD">D</div>
                        </div>
                        <div class="key-row key-row-left">
                            <div class="key-button" id="keyLeft">â†</div>
                            <div class="key-button" id="keyDown">â†“</div>
                            <div class="key-button" id="keyRight">â†’</div>
                        </div>
                    </div>

                    <div class="speed-gauge">
                        <div class="gauge-ring"></div>
                        <div class="gauge-center">
                            <span id="currentSpeedGauge">0</span>
                            <div class="gauge-label">KM/S</div>
                        </div>
                    </div>

                    <div class="key-display-group key-group-right">
                        <div class="key-row key-row-single key-row-right">
                            <div class="key-button key-button-large" id="keyR">R</div>
                        </div>
                    </div>
                </div>
            </div>
            <div class="console-border-bottom"></div>
        </div>


        <div class="rocket-btn" id="rocketBtn">
            ğŸ”¥ ROKET
        </div>

        <div class="speed-controls" id="speedControls">
            <div class="speed-btn accelerate" id="accelerateBtn">HÄ±zlan</div>
            <div class="speed-btn brake" id="brakeBtn">YavaÅŸla</div>
        </div>

        <div class="mobile-controls" id="mobileControls">
            <div class="control-btn" id="leftBtn">â†</div>
            <div class="control-btn" id="rightBtn">â†’</div>
        </div>

        <div class="speed-display-new" id="newSpeedometer">
            <span id="newSpeedValue">0</span>
            <span class="speed-label">KM/S</span>
        </div>

        <div class="speed-display" id="speedDisplay">
            <span id="currentSpeed">0</span>
        </div>

        <div class="game-over" id="gameOver">
            <h2>ğŸ’¥ KAZA!</h2>
            <p>Toplam Skor: <span id="finalScore">0</span></p>
            <p>Mesafe: <span id="finalDistance">0</span>m</p>
            <p>En YÃ¼ksek Kombo: <span id="maxCombo">0</span></p>
            <div id="highScores">
                <h3>ğŸ† Rekorlar ğŸ†</h3>
                <ol id="highScoreList"></ol>
            </div>
        </div>

        <div id="sirenStarsContainer">
            <span class="siren-star">â˜…</span>
            <span class="siren-star">â˜…</span>
            <span class="siren-star">â˜…</span>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Oyun deÄŸiÅŸkenleri
        let scene, camera, renderer, car, road = [], trafficCars = [], barriers = [];
        let roadsideElements = [];
        let gameRunning = false;
        let score = 0, distance = 0, level = 1;
        let carSpeed = 0, maxSpeed = 250;
        let roadSpeed = 0.5;
        let baseTrafficSpeed = 0.3;
        let keys = {};
        let gameStarted = false;
        let combo = 0;
        let highCombo = 0;
        let lastComboTime = 0;
        let mobileControls = { left: false, right: false, accelerate: false, brake: false };
        let animationFrameId;
        let carTilt = 0;
        const maxCarTilt = Math.PI / 24; 

        let audioContext;
        let engineGainNode; 
        let engineSource; 
        let engineBuffer; 

        let brakeBuffer; 
        let policeSirenBuffer; 
        let introBuffer; 
        let introSource; 
        let introGainNode; 
        let powerUpRocketSoundBuffer; // Formerly powerUpCollectBuffer
        let explosionSoundBuffer;
        let crashSoundBuffer;
        let powerUpHealthSoundBuffer;
        let powerUpShieldSoundBuffer;
        let menuSelectSoundBuffer;
        let menuConfirmSoundBuffer;

        let brakeLightMesh = null;
        let spoilerTaillights = [];
        let pooledTrafficCars = [];
        const MAX_POOLED_TRAFFIC_CARS = 20;

        let health = 100;
        const maxHealth = 100;
        const sideCollisionDamageMultiplier = 0.1; 
        const directCollisionZThreshold = 2.0;

        let playerHeadlight;

        const carBox = new THREE.Box3();
        const trafficBox = new THREE.Box3();
        const powerUpBox = new THREE.Box3(); 

        const roadWidth = 20;
        const lanes = [-7, 0, 7];
        const laneWidth = 7;
        const roadsideWidth = 15;

        let rocketParticles = [];

        let rockets = 0; 
        let activeRocket = null;
        const rocketBaseSpeed = 1.5;
        const rocketCooldown = 1000;
        let lastRocketFireTime = 0;
        let trafficCarsDestroyedByRocket = 0;
        let rocketsFiredCount = 0; 

        // GÃ¼Ã§lendirmeler iÃ§in genel deÄŸiÅŸkenler
        let powerUps = [];
        const powerUpSpawnInterval = 10000; // ArtÄ±k genel bir aralÄ±k
        let lastPowerUpSpawnTime = 0;
        let shieldActive = false;
        let shieldTimeout;
        let shieldMesh = null;

        // HÄ±z Koridoru DeÄŸiÅŸkenleri
        let isSpeedCorridorActive = false;
        let speedCorridorStartDistance = 0;
        let nextSpeedCorridorSpawnDistance = 25000; // Ä°lk koridor 25km'de baÅŸlasÄ±n
        let rampTruck = null;
        let isJumping = false;
        let jumpVelocityY = 0;
        const jumpGravity = 0.05;

        let skyDome;
        let mountains = [];
        let sun, moon, starField, sunLight; // Yeni gÃ¶k cisimleri

        let activePoliceCar = null;
        const policeChaseDistance = 5; 

        const policeSpawnCooldownTime = 30000; 
        let lastPoliceCarDespawnTime = 0;
        let policeDifficultyMultiplier = 1.0;

        let policeDamageStartTime = 0;
        const policeTotalDamageLimit = 10;
        const policeDamageInterval = 1000;
        let lastPoliceIncrementalDamageTime = 0;
        let currentPoliceChaseDamage = 0;

        // Yeni Siren UyarÄ± Sistemi DeÄŸiÅŸkenleri
        let sirenWarningCount = 0;
        let lastSirenWarningTime = 0;
        const sirenWarningInterval = 20000; // 20 saniyede bir uyarÄ± denemesi
        let shortSirenSound; // KÄ±sa siren sesi iÃ§in kontrol objesi

        const MAX_POOLED_POLICE_CARS = 2;
        let policeCarsPool = [];

        let playerName = "Oyuncu";

        let timeOfDay = 6;
        const dayDurationInGameMeters = 5000;
        let previousDistanceForTime = 0;

        let radarPoles = [];
        let lastRadarHitTime = {};
        let nextRadarSpawnDistance = 0;

        const SPEED_EFFECT_THRESHOLD = 200;
        let cameraShakeIntensity = 0;
        const maxCameraShakeIntensity = 0.08;
        const speedEffectScaleFactor = 0.0005;

        // Yeni kamera sarsÄ±ntÄ±sÄ± deÄŸiÅŸkenleri
        let collisionShakeMagnitude = 0;
        let collisionShakeDuration = 0;

        let newSpeedValueElement;

        // JSONBlob URL'si
        const HIGH_SCORES_URL = 'https://jsonblob.com/api/jsonBlob/1380700706369101824';

        // LoadingManager ve Ä°lerleme Ã‡ubuÄŸu DeÄŸiÅŸkenleri
        let loadingManager;
        let progressBar = document.getElementById('progressBar');
        let loadingScreen = document.getElementById('loadingScreen');
        let loadingTip = document.getElementById('loadingTip'); 

        // Kokpit elemanlarÄ± iÃ§in referanslar
        let cockpitConsole = document.getElementById('cockpitConsole');
        let currentSpeedGauge = document.getElementById('currentSpeedGauge');
        let gaugeRing = document.querySelector('.gauge-ring');

        const loadingTips = [ 
            "HÄ±z ve ÅŸiddet iÃ§erir.",
            "HÄ±z kadar, yavaÅŸlamak da Ã¶nemlidir.",
            "Roketle ve polisden kaÃ§!",
            "Trafik araÃ§larÄ±na yakÄ±n geÃ§erek bonus puanlar kazan!",
            "Radar cezalarÄ±na dikkat et, hÄ±z limitini aÅŸma!",
            "GÃ¼ndÃ¼z-gece dÃ¶ngÃ¼sÃ¼ oyun deneyimini etkiler.",
            "SaÄŸlÄ±k barÄ±na gÃ¶z kulak ol, Ã§arpÄ±ÅŸmalardan kaÃ§!",
            "Polis arabalarÄ± peÅŸini bÄ±rakmaz, onlarÄ± atlat!"
        ];
        let currentTipIndex = 0;
        let lastTipChangeProgress = -1; 

        // TuÅŸ elementleri iÃ§in referanslar
        const keyMap = {
            'w': document.getElementById('keyW'),
            'a': document.getElementById('keyA'),
            's': document.getElementById('keyS'),
            'd': document.getElementById('keyD'),
            'arrowup': document.getElementById('keyUp'),
            'arrowleft': document.getElementById('keyLeft'),
            'arrowdown': document.getElementById('keyDown'),
            'arrowright': document.getElementById('keyRight'),
            'r': document.getElementById('keyR')
        };

        // Bu deÄŸiÅŸkeni global scope'a taÅŸÄ±dÄ±k.
        const minDistanceBetweenCars = 30;

        // Yeni Ã‡arpÄ±ÅŸma Koruma Sistemi
        let lastCollisionTime = 0;
        const collisionCooldown = 1500; // 1.5 saniye dokunulmazlÄ±k

        // YÄ±ldÄ±z UI elementleri
        let sirenStarElements = [];

        const playerCarWidth = 1.9;
        const playerCarLength = 4.5;

        function init() {
            // LoadingManager oluÅŸtur
            loadingManager = new THREE.LoadingManager();

            loadingManager.onProgress = function (url, itemsLoaded, itemsTotal) {
                console.log('YÃ¼kleniyor: ' + url + '.  YÃ¼klenen Ã¶ÄŸe: ' + itemsLoaded + '/' + itemsTotal);
                const progress = (itemsLoaded / itemsTotal) * 100;
                if (progressBar) { 
                    progressBar.style.width = progress + '%';
                }

                // Ä°lerleme Ã§ubuÄŸuna gÃ¶re ipuÃ§larÄ±nÄ± gÃ¼ncelle
                if (loadingTip) {
                    const totalTips = loadingTips.length;
                    const tipInterval = 100 / totalTips; 

                    const newTipIndex = Math.floor(progress / tipInterval);

                    if (newTipIndex !== currentTipIndex && newTipIndex < totalTips) {
                        currentTipIndex = newTipIndex;
                        loadingTip.style.opacity = 0; 
                        setTimeout(() => {
                            loadingTip.textContent = loadingTips[currentTipIndex];
                            loadingTip.style.opacity = 1; 
                        }, 500); 
                    } else if (progress >= 99 && currentTipIndex < totalTips -1 && lastTipChangeProgress < 99) {
                        currentTipIndex = totalTips - 1;
                        loadingTip.style.opacity = 0;
                        setTimeout(() => {
                            loadingTip.textContent = loadingTips[currentTipIndex];
                            loadingTip.style.opacity = 1;
                        }, 500);
                    }
                    lastTipChangeProgress = progress; 
                }
            };

            loadingManager.onLoad = function () {
                console.log('TÃ¼m varlÄ±klar yÃ¼klendi!');
                // Sesler yÃ¼klendikten sonra ilk ekranÄ± gÃ¶ster
                // initAudioAndLoadGame(); // Bu fonksiyon ÅŸimdi 'GAZLA!!!' butonu ile Ã§aÄŸrÄ±lacak
            };

            loadingManager.onError = function (url) {
                console.error('YÃ¼klenirken hata oluÅŸtu: ' + url);
                // initAudioAndLoadGame(); // Bu fonksiyon ÅŸimdi 'GAZLA!!!' butonu ile Ã§aÄŸrÄ±lacak
            };

            scene = new THREE.Scene();
            scene.fog = new THREE.Fog(0x87CEEB, 100, 500);

            camera = new THREE.PerspectiveCamera(80, window.innerWidth / window.innerHeight, 0.1, 1000); 
            camera.position.set(0, 9, 14); 
            camera.lookAt(0, 2, -5); 


            renderer = new THREE.WebGLRenderer({
                canvas: document.getElementById('gameCanvas'),
                antialias: true
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.setClearColor(0x87CEEB);

            const ambientLight = new THREE.AmbientLight(0x404080, 0.8);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 1.2);
            directionalLight.position.set(20, 30, 10);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 1024;
            directionalLight.shadow.mapSize.height = 1024;
            directionalLight.shadow.camera.near = 0.5;
            directionalLight.shadow.camera.far = 100;
            directionalLight.shadow.camera.left = -50;
            directionalLight.shadow.camera.right = 50;
            directionalLight.shadow.camera.top = 50;
            directionalLight.shadow.camera.bottom = -50;
            scene.add(directionalLight);

            createPlayerCar();
            createPlayerHeadlight();
            createRoad();
            createRoadside();
            createBarriers();
            createInitialTrafficCars(5);
            createInitialRoadsideElements(10);
            createSkyDome();
            createMountains();
            createCelestialBodies();

            for (let i = 0; i < MAX_POOLED_POLICE_CARS; i++) {
                const { car: policeCar, length } = createTrafficCar(0x0000FF, 'sport', true);
                policeCar.visible = false;
                policeCar.userData.isPooled = true;
                policeCar.userData.length = length;
                policeCar.userData.type = 'sport';
                policeCar.userData.isPolice = true;
                policeCar.userData.currentLane = 0;
                policeCar.userData.targetLane = 0;
                policeCar.userData.isChangingLane = false;
                policeCar.userData.wander = 0;
                policeCar.userData.wanderTarget = 0;
                policeCar.userData.lastX = 0;
                policeCar.userData.trafficCollisions = 0;
                scene.add(policeCar);
                policeCarsPool.push(policeCar);
            }

            for (let i = 0; i < MAX_POOLED_TRAFFIC_CARS; i++) {
                const colors = [0x00FF00, 0x0000FF, 0xFFFF00, 0xFF00FF, 0x00FFFF, 0xFF8C00, 0x8A2BE2, 0x00CED1, 0xFF69B4, 0x4B0082, 0xADFF2F, 0xFFD700];
                const types = ['sedan', 'truck', 'minivan', 'bus'];
                const color = colors[Math.floor(Math.random() * colors.length)];
                const type = types[Math.floor(Math.random() * types.length)];
                const { car: trafficCar, length } = createTrafficCar(color, type);
                trafficCar.visible = false;
                trafficCar.userData.isPooled = true;
                trafficCar.userData.length = length;
                trafficCar.userData.type = type;
                trafficCar.userData.isPolice = false;
                trafficCar.userData.currentLane = 0;
                trafficCar.userData.targetLane = 0;
                trafficCar.userData.isChangingLane = false;
                trafficCar.userData.wander = 0;
                trafficCar.userData.wanderTarget = 0;
                trafficCar.userData.lastX = 0;
                trafficCar.userData.trafficCollisions = 0;
                scene.add(trafficCar);
                pooledTrafficCars.push(trafficCar);
            }


            window.addEventListener('resize', onWindowResize);
            document.addEventListener('keydown', onKeyDown);
            document.addEventListener('keyup', onKeyUp);

            setupMobileControls();
            newSpeedValueElement = document.getElementById('newSpeedValue');

            render();
            showPreIntroScreen(); /* Yeni eklenen ilk ekranÄ± gÃ¶ster */
        }

        /* Yeni ekran gÃ¶sterme fonksiyonlarÄ± */
        function showPreIntroScreen() {
            document.getElementById('preIntroScreen').style.display = 'flex';
            document.getElementById('loadingScreen').style.display = 'none';
            document.getElementById('firstEntryScreen').style.display = 'none';
            document.getElementById('secondStartScreen').style.display = 'none';
            document.getElementById('gameOver').style.display = 'none';
            document.body.classList.remove('game-active');

            if (cockpitConsole) {
                cockpitConsole.style.bottom = '-50px'; 
                cockpitConsole.style.opacity = '0'; 
                cockpitConsole.style.pointerEvents = 'none'; 
            }
        }

        function showLoadingScreen() {
            document.getElementById('preIntroScreen').style.display = 'none';
            document.getElementById('loadingScreen').style.display = 'flex';
            document.getElementById('firstEntryScreen').style.display = 'none';
            document.getElementById('secondStartScreen').style.display = 'none';
            document.getElementById('gameOver').style.display = 'none';
            document.body.classList.remove('game-active');

            if (cockpitConsole) {
                cockpitConsole.style.bottom = '-50px'; 
                cockpitConsole.style.opacity = '0'; 
                cockpitConsole.style.pointerEvents = 'none'; 
            }
        }

        function showFirstEntryScreen() { /* Eski showFirstScreen, ÅŸimdi isim giriÅŸi ekranÄ± */
            document.getElementById('preIntroScreen').style.display = 'none';
            document.getElementById('loadingScreen').style.display = 'none';
            document.getElementById('firstEntryScreen').style.display = 'flex';
            document.getElementById('secondStartScreen').style.display = 'none';
            document.getElementById('gameOver').style.display = 'none';
            document.body.classList.remove('game-active');

            if (cockpitConsole) {
                cockpitConsole.style.bottom = '-50px'; 
                cockpitConsole.style.opacity = '0'; 
                cockpitConsole.style.pointerEvents = 'none'; 
            }
        }

        function showSecondStartScreen() { /* Eski showSecondScreen, ÅŸimdi baÅŸlat dÃ¼ÄŸmesi ekranÄ± */
            document.getElementById('preIntroScreen').style.display = 'none';
            document.getElementById('loadingScreen').style.display = 'none';
            document.getElementById('firstEntryScreen').style.display = 'none';
            document.getElementById('secondStartScreen').style.display = 'flex';
            document.getElementById('gameOver').style.display = 'none';
            document.body.classList.remove('game-active');

            if (introGainNode) {
                introGainNode.gain.setValueAtTime(0.25, audioContext.currentTime); 
            }
        }

        function hideAllScreensForGame() {
            document.getElementById('preIntroScreen').style.display = 'none';
            document.getElementById('loadingScreen').style.display = 'none';
            document.getElementById('firstEntryScreen').style.display = 'none';
            document.getElementById('secondStartScreen').style.display = 'none';
            document.getElementById('gameOver').style.display = 'none';
            document.body.classList.add('game-active'); 

            if (cockpitConsole) {
                cockpitConsole.style.bottom = '10px'; 
                cockpitConsole.style.opacity = '1'; 
                cockpitConsole.style.pointerEvents = 'all'; 
            }
        }

        /* Yeni GAZLA butonu olayÄ± */
        document.getElementById('gasButton').addEventListener('click', () => {
            showLoadingScreen(); /* YÃ¼kleme ekranÄ±na geÃ§iÅŸ */
            initAudioAndLoadGame(); /* Sesleri ve oyunu yÃ¼kleme iÅŸlemini baÅŸlat */
        });

        document.getElementById('playButton').addEventListener('click', () => {
            const inputName = document.getElementById('playerNameInput').value.trim();
            if (inputName) {
                playerName = inputName;
            } else {
                playerName = "Misafir";
            }
            if (audioContext && audioContext.state === 'suspended') {
                audioContext.resume().then(() => {
                    console.log('AudioContext devam ettirildi (ilk etkileÅŸim).');
                    /* Intro sesi zaten initAudioAndLoadGame iÃ§inde baÅŸlatÄ±lmÄ±ÅŸ olmalÄ± */
                }).catch(error => {
                    console.error("AudioContext devam ettirilemedi:", error);
                });
            }
            /* intro sesi zaten calisiyor olmali */
            showSecondStartScreen();
        });

        document.getElementById('startButton').addEventListener('click', startActuallyGame);
        document.getElementById('playerNameInput').addEventListener('keydown', (e) => {
            if (e.key === 'Enter') {
                document.getElementById('playButton').click(); 
            }
        });


        function isMobileDevice() {
            return (typeof window.orientation !== "undefined") || (navigator.userAgent.indexOf('Mobi') !== -1);
        }

        function setupMobileControls() {
            const leftBtn = document.getElementById('leftBtn');
            const rightBtn = document.getElementById('rightBtn');
            const accelerateBtn = document.getElementById('accelerateBtn');
            const brakeBtn = document.getElementById('brakeBtn');
            const rocketBtn = document.getElementById('rocketBtn'); 

            const mobileControlsDiv = document.getElementById('mobileControls');
            const speedControlsDiv = document.getElementById('speedControls');
            const rocketBtnDiv = document.getElementById('rocketBtn'); 

            if (isMobileDevice()) {
                mobileControlsDiv.style.display = 'flex';
                speedControlsDiv.style.display = 'flex';
                rocketBtnDiv.style.display = 'flex'; 

                leftBtn.addEventListener('touchstart', (e) => { e.preventDefault(); mobileControls.left = true; if(keyMap['arrowleft']) keyMap['arrowleft'].classList.add('active'); }, { passive: false });
                leftBtn.addEventListener('touchend', (e) => { e.preventDefault(); mobileControls.left = false; if(keyMap['arrowleft']) keyMap['arrowleft'].classList.remove('active'); });

                rightBtn.addEventListener('touchstart', (e) => { e.preventDefault(); mobileControls.right = true; if(keyMap['arrowright']) keyMap['arrowright'].classList.add('active'); }, { passive: false });
                rightBtn.addEventListener('touchend', (e) => { e.preventDefault(); mobileControls.right = false; if(keyMap['arrowright']) keyMap['arrowright'].classList.remove('active'); });

                accelerateBtn.addEventListener('touchstart', (e) => { e.preventDefault(); mobileControls.accelerate = true; if(keyMap['arrowup']) keyMap['arrowup'].classList.add('active'); }, { passive: false });
                accelerateBtn.addEventListener('touchend', (e) => { e.preventDefault(); mobileControls.accelerate = false; if(keyMap['arrowup']) keyMap['arrowup'].classList.remove('active'); });

                brakeBtn.addEventListener('touchstart', (e) => { e.preventDefault(); mobileControls.brake = true; if(keyMap['arrowdown']) keyMap['arrowdown'].classList.add('active'); }, { passive: false });
                brakeBtn.addEventListener('touchend', (e) => { e.preventDefault(); mobileControls.brake = false; if(keyMap['arrowdown']) keyMap['arrowdown'].classList.remove('active'); });

                rocketBtn.addEventListener('touchstart', (e) => { e.preventDefault(); fireRocket(); if(keyMap['r']) keyMap['r'].classList.add('active'); }, { passive: false });
                rocketBtn.addEventListener('touchend', (e) => { e.preventDefault(); if(keyMap['r']) keyMap['r'].classList.remove('active'); });
            } else {
                mobileControlsDiv.style.display = 'none';
                speedControlsDiv.style.display = 'none';
                rocketBtnDiv.style.display = 'none'; 
            }
        }

        function createPlayerCar() {
            const carGroup = new THREE.Group();

            const bodyMaterial = new THREE.MeshStandardMaterial({
                color: 0xFF0000, 
                roughness: 0.5, 
                metalness: 0.1, 
            });
            const windowMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x000000, 
                transparent: true,
                opacity: 0.85, 
                roughness: 0.05, 
                metalness: 0.95, 
                envMapIntensity: 1.5, 
            });
            const wheelMaterial = new THREE.MeshStandardMaterial({
                color: 0x1A1A1A,
                roughness: 0.8,
                metalness: 0.5,
            });
            const playerHeadlightMaterial = new THREE.MeshStandardMaterial({
                color: 0xFFFF88,
                emissive: 0xAAAA00,
                emissiveIntensity: 0.8,
                roughness: 0.1,
                metalness: 0.0,
            });
            const playerTaillightMaterial = new THREE.MeshStandardMaterial({
                color: 0x8B0000, 
                emissive: 0xFF0000, 
                emissiveIntensity: 5.0, 
                roughness: 0.1,
                metalness: 0.0,
            });
            const frontBumperMaterial = new THREE.MeshStandardMaterial({
                color: 0x333333, 
                roughness: 0.6,
                metalness: 0.7,
            });
            const airIntakeMaterial = new THREE.MeshStandardMaterial({
                color: 0x000000, 
                roughness: 0.4,
                metalness: 0.9
            });
            const diffuserMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x111111, 
                roughness: 0.6,
                metalness: 0.8, 
            });
            const finMaterial = new THREE.MeshStandardMaterial({
                color: 0x000000,
                roughness: 0.5,
                metalness: 0.7
            });


            const bodyGeometry = new THREE.BoxGeometry(2.6, 0.5, 5.0); 
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            body.position.y = 0.25; 
            body.castShadow = true;
            carGroup.add(body);


            const carBodyTopY = 0.5; 
            const roofThickness = 0.1; 
            const roofWidth = 2.2;     

            const metalRoofDepth = 2.5; 
            const metalRoofGeometry = new THREE.BoxGeometry(roofWidth, roofThickness, metalRoofDepth);
            const metalRoof = new THREE.Mesh(metalRoofGeometry, bodyMaterial);
            metalRoof.position.set(
                0,
                carBodyTopY + (roofThickness / 2), 
                -metalRoofDepth / 2 
            );
            metalRoof.castShadow = true;
            carGroup.add(metalRoof);

            const windshieldRearY = carBodyTopY + roofThickness; 
            const windshieldRearZ = 0;                          
            const windshieldFrontY = carBodyTopY - 0.1; 
            const windshieldFrontZ = 1.8;              

            const deltaZ_ws = windshieldFrontZ - windshieldRearZ; 
            const deltaY_ws = windshieldRearY - windshieldFrontY; 

            const windshieldLengthOnSlant = Math.sqrt(deltaZ_ws * deltaZ_ws + deltaY_ws * deltaY_ws);
            const windshieldRotationX = Math.atan2(deltaY_ws, deltaZ_ws); 

            const glassThickness = 0.05; 
            const frontWindshieldGeometry = new THREE.BoxGeometry(roofWidth, glassThickness, windshieldLengthOnSlant);
            const frontWindshield = new THREE.Mesh(frontWindshieldGeometry, windowMaterial);

            frontWindshield.position.set(
                0,
                (windshieldRearY + windshieldFrontY) / 2, 
                (windshieldRearZ + windshieldFrontZ) / 2  
            );
            frontWindshield.rotation.x = windshieldRotationX;
            frontWindshield.castShadow = true; 
            carGroup.add(frontWindshield);

            const carBodyWidth = 2.6;
            const sidePanelThickness = 0.1; 
            const sideWindowThickness = 0.05; 

            const rearSidePanelDepth = 2.5; 
            const rearSidePanelHeight = carBodyTopY + roofThickness; 
            const rearSidePanelGeometry = new THREE.BoxGeometry(sidePanelThickness, rearSidePanelHeight, rearSidePanelDepth);

            const leftRearSidePanel = new THREE.Mesh(rearSidePanelGeometry, diffuserMaterial);
            leftRearSidePanel.position.set(
                -carBodyWidth / 2 - sidePanelThickness / 2, 
                rearSidePanelHeight / 2,                    
                -rearSidePanelDepth / 2                      
            );
            leftRearSidePanel.castShadow = true;
            carGroup.add(leftRearSidePanel);

            const rightRearSidePanel = new THREE.Mesh(rearSidePanelGeometry, diffuserMaterial);
            rightRearSidePanel.position.set(
                carBodyWidth / 2 + sidePanelThickness / 2,
                rearSidePanelHeight / 2,
                -rearSidePanelDepth / 2
            );
            rightRearSidePanel.castShadow = true;
            carGroup.add(rightRearSidePanel);

            const sideWindowBottomY = 0.2; 
            const frontSideLowerPanelDepth = windshieldFrontZ; 
            const frontSideLowerPanelHeight = sideWindowBottomY; 
            const frontSideLowerPanelGeometry = new THREE.BoxGeometry(sidePanelThickness, frontSideLowerPanelHeight, frontSideLowerPanelDepth);

            const leftFrontLowerPanel = new THREE.Mesh(frontSideLowerPanelGeometry, bodyMaterial);
            leftFrontLowerPanel.position.set(
                -carBodyWidth / 2 - sidePanelThickness / 2,
                frontSideLowerPanelHeight / 2, 
                frontSideLowerPanelDepth / 2   
            );
            leftFrontLowerPanel.castShadow = true;
            carGroup.add(leftFrontLowerPanel);

            const rightFrontLowerPanel = new THREE.Mesh(frontSideLowerPanelGeometry, bodyMaterial);
            rightFrontLowerPanel.position.set(
                carBodyWidth / 2 + sidePanelThickness / 2,
                frontSideLowerPanelHeight / 2,
                frontSideLowerPanelDepth / 2
            );
            rightFrontLowerPanel.castShadow = true;
            carGroup.add(rightFrontLowerPanel);

            const sideWindowShapeXY = new THREE.Shape();
            sideWindowShapeXY.moveTo(windshieldRearZ, sideWindowBottomY);    
            sideWindowShapeXY.lineTo(windshieldRearZ, windshieldRearY);      
            sideWindowShapeXY.lineTo(windshieldFrontZ, windshieldFrontY);    
            sideWindowShapeXY.lineTo(windshieldFrontZ, sideWindowBottomY);   
            sideWindowShapeXY.closePath();

            const sideWindowExtrudeSettings = { depth: sideWindowThickness, bevelEnabled: false };
            const sideWindowGeomXY = new THREE.ExtrudeGeometry(sideWindowShapeXY, sideWindowExtrudeSettings);

            const lsw = new THREE.Mesh(sideWindowGeomXY, windowMaterial);
            lsw.rotation.y = Math.PI / 2; 
            lsw.position.set(
                -carBodyWidth / 2, 
                0,                 
                sideWindowThickness / 2 
            );
            lsw.castShadow = true;
            carGroup.add(lsw);

            const rsw = new THREE.Mesh(sideWindowGeomXY, windowMaterial);
            rsw.rotation.y = -Math.PI / 2; 
            rsw.position.set(
                carBodyWidth / 2,  
                0,
                -sideWindowThickness / 2 
            );
            rsw.castShadow = true;
            carGroup.add(rsw);

            const wheelGeometry = new THREE.CylinderGeometry(0.5, 0.5, 0.5, 16); 
            const wheelPositions = [
                { x: -1.2, y: 0.25, z: 2.0 }, 
                { x: 1.2, y: 0.25, z: 2.0 },  
                { x: -1.2, y: 0.25, z: -2.0 },
                { x: 1.2, y: 0.25, z: -2.0 } 
            ];

            const wheelGroup = new THREE.Group();
            wheelPositions.forEach(pos => {
                const wheel = new THREE.Mesh(wheelGeometry, wheelMaterial);
                wheel.position.set(pos.x, pos.y, pos.z);
                wheel.rotation.z = Math.PI / 2;
                wheel.castShadow = true;
                wheelGroup.add(wheel);
            });
            carGroup.add(wheelGroup); 


            const headlightStripGeometry = new THREE.BoxGeometry(0.4, 0.1, 0.05);
            [-0.8, 0.8].forEach(x => {
                const headlight = new THREE.Mesh(headlightStripGeometry, playerHeadlightMaterial);
                headlight.position.set(x, 0.4, 2.4); 
                headlight.userData.isLight = true;
                carGroup.add(headlight);
            });

            const rearBumperMaterial = new THREE.MeshStandardMaterial({
                color: 0x333333, 
                roughness: 0.6,
                metalness: 0.7,
            });
            const rearBumperGeometry = new THREE.BoxGeometry(2.6, 0.25, 0.7);
            const rearBumper = new THREE.Mesh(rearBumperGeometry, rearBumperMaterial);
            rearBumper.position.set(0, 0.125, -2.6); 
            carGroup.add(rearBumper);


            const newSpoilerTaillightMaterial = new THREE.MeshStandardMaterial({
                color: 0x8B0000, 
                emissive: 0xFF0000, 
                emissiveIntensity: 5.0, 
                roughness: 0.1,
                metalness: 0.0,
            });
            const spoilerTaillightWidth = 0.15; 
            const spoilerTaillightHeight = 0.6; 
            const spoilerTaillightDepth = 0.1; 
            const spoilerTaillightSpacing = 0.1; 
            const spoilerTaillightXOffset = 1.0; 

            for (let i = 0; i < 3; i++) { 
                const taillightGeometry = new THREE.BoxGeometry(spoilerTaillightWidth, spoilerTaillightHeight, spoilerTaillightDepth);
                const taillight = new THREE.Mesh(taillightGeometry, newSpoilerTaillightMaterial); 
                taillight.position.set(
                    -(spoilerTaillightXOffset), 
                    1.15 + (0.2 - i * spoilerTaillightSpacing), 
                    -2.8 
                );
                taillight.userData.isLight = true;
                spoilerTaillights.push(taillight); 
                carGroup.add(taillight);
            }
            for (let i = 0; i < 3; i++) { 
                const taillightGeometry = new THREE.BoxGeometry(spoilerTaillightWidth, spoilerTaillightHeight, spoilerTaillightDepth);
                const taillight = new THREE.Mesh(taillightGeometry, newSpoilerTaillightMaterial);
                taillight.position.set(
                    (spoilerTaillightXOffset), 
                    1.15 + (0.2 - i * spoilerTaillightSpacing), 
                    -2.8 
                );
                taillight.userData.isLight = true;
                spoilerTaillights.push(taillight); 
                carGroup.add(taillight);
            }

            const f1BrakeLightGeometry = new THREE.BoxGeometry(0.5, 0.2, 0.1); 
            const f1BrakeLightMaterial = new THREE.MeshStandardMaterial({
                color: 0xFF0000, 
                emissive: 0xFF0000,
                emissiveIntensity: 0.0, 
                roughness: 0.1,
                metalness: 0.0,
            });
            brakeLightMesh = new THREE.Mesh(f1BrakeLightGeometry, f1BrakeLightMaterial);
            brakeLightMesh.position.set(0, 0.05, -2.6); 
            brakeLightMesh.userData.isBrakeLight = true;
            carGroup.add(brakeLightMesh);

            const frontBumperGeometry = new THREE.BoxGeometry(2.6, 0.25, 0.7);
            const frontBumper = new THREE.Mesh(frontBumperGeometry, frontBumperMaterial);
            frontBumper.position.set(0, 0.125, 2.6); 
            carGroup.add(frontBumper);

            const airIntakeGeometry = new THREE.BoxGeometry(0.9, 0.15, 0.1);
            const airIntakeLeft = new THREE.Mesh(airIntakeGeometry, airIntakeMaterial);
            airIntakeLeft.position.set(-0.8, 0.125, 2.65); 
            carGroup.add(airIntakeLeft);
            const airIntakeRight = new THREE.Mesh(airIntakeGeometry, airIntakeMaterial);
            airIntakeRight.position.set(0.8, 0.125, 2.65); 
            carGroup.add(airIntakeRight);
            const centerAirIntakeGeometry = new THREE.BoxGeometry(0.7, 0.12, 0.1);
            const centerAirIntake = new THREE.Mesh(centerAirIntakeGeometry, airIntakeMaterial);
            centerAirIntake.position.set(0, 0.125, 2.65); 
            carGroup.add(centerAirIntake);


            const diffuserMainGeometry = new THREE.BoxGeometry(2.0, 0.3, 1.2);
            const diffuserMain = new THREE.Mesh(diffuserMainGeometry, diffuserMaterial);
            diffuserMain.position.set(0, -0.05, -2.6); 
            carGroup.add(diffuserMain);

            const grilleStripMaterial = new THREE.MeshStandardMaterial({ color: 0x000000, roughness: 0.5, metalness: 0.9 });
            const numStrips = 5;
            const stripWidth = 0.1;
            const stripSpacing = (2.0 - (numStrips * stripWidth)) / (numStrips + 1);
            for (let i = 0; i < numStrips; i++) {
                const strip = new THREE.Mesh(new THREE.BoxGeometry(stripWidth, 0.25, 1.0), grilleStripMaterial);
                strip.position.set(
                    -1.0 + (i * (stripWidth + stripSpacing)) + stripWidth / 2 + stripSpacing,
                    -0.05, 
                    -2.6 
                );
                carGroup.add(strip);
            }

            const finGeometry = new THREE.BoxGeometry(0.18, 0.6, 0.7);
            const fin1 = new THREE.Mesh(finGeometry, finMaterial);
            fin1.position.set(-0.7, 0.1, -2.5); 
            fin1.rotation.y = Math.PI / 6;
            carGroup.add(fin1);
            const fin2 = new THREE.Mesh(finGeometry, finMaterial);
            fin2.position.set(0.7, 0.1, -2.5); 
            fin2.rotation.y = -Math.PI / 6;
            carGroup.add(fin2);

            const exhaustGeometry = new THREE.CylinderGeometry(0.2, 0.2, 0.4, 8);
            const exhaustMaterial = new THREE.MeshStandardMaterial({ color: 0x333333, roughness: 0.3, metalness: 0.9 });
            const exhaust1 = new THREE.Mesh(exhaustGeometry, exhaustMaterial);
            exhaust1.position.set(-0.9, -0.05, -2.6); 
            exhaust1.rotation.x = Math.PI / 2;
            carGroup.add(exhaust1);
            const exhaust2 = new THREE.Mesh(exhaustGeometry, exhaustMaterial);
            exhaust2.position.set(0.9, -0.05, -2.6); 
            exhaust2.rotation.x = Math.PI / 2;
            carGroup.add(exhaust2);

            const spoilerSupportGeometry = new THREE.BoxGeometry(0.15, 0.8, 0.15); 
            const spoilerSupportMaterial = new THREE.MeshStandardMaterial({ color: 0x222222, roughness: 0.6, metalness: 0.7 });
            const leftSupport = new THREE.Mesh(spoilerSupportGeometry, spoilerSupportMaterial);
            leftSupport.position.set(-1.1, 0.8, -2.5); 
            carGroup.add(leftSupport);
            const rightSupport = new THREE.Mesh(spoilerSupportGeometry, spoilerSupportMaterial);
            rightSupport.position.set(1.1, 0.8, -2.5); 
            carGroup.add(rightSupport);

            const spoilerWingMaterial = new THREE.MeshStandardMaterial({
                color: 0x000000, 
                roughness: 0.4,
                metalness: 0.8
            });
            const spoilerWingGeometry = new THREE.BoxGeometry(2.6, 0.15, 0.6); 
            const spoilerWing = new THREE.Mesh(spoilerWingGeometry, spoilerWingMaterial);
            spoilerWing.position.set(0, 1.25, -2.7); 
            spoilerWing.rotation.x = -Math.PI / 10;
            carGroup.add(spoilerWing);

            const cutGeometry = new THREE.BoxGeometry(2.0, 0.05, 0.05); 
            const cutMaterial = new THREE.MeshBasicMaterial({ color: 0x111111 }); 
            for (let i = 0; i < 3; i++) {
                const cut = new THREE.Mesh(cutGeometry, cutMaterial);
                cut.position.set(
                    0,
                    1.25 + (0.1 - i * 0.07), 
                    -2.7 
                );
                carGroup.add(cut);
            }

            car = carGroup;
            car.rotation.y = Math.PI; 
            scene.add(car);
            car.position.z = -5; 

            // Kalkan Meshi (baÅŸlangÄ±Ã§ta gÃ¶rÃ¼nmez)
            const shieldGeometry = new THREE.SphereGeometry(4, 32, 16);
            const shieldMaterial = new THREE.MeshBasicMaterial({
                color: 0xADD8E6,
                transparent: true,
                opacity: 0.3,
                blending: THREE.AdditiveBlending
            });
            shieldMesh = new THREE.Mesh(shieldGeometry, shieldMaterial);
            shieldMesh.visible = false;
            car.add(shieldMesh);

            carGroup.userData.originalLength = playerCarLength; // DÃ¼zeltme: global sabiti kullan
            carGroup.userData.originalWidth = playerCarWidth; // DÃ¼zeltme: global sabiti kullan

            return { car: carGroup, length: playerCarLength, width: playerCarWidth }; // DÃ¼zeltme: global sabiti kullan
        }


        function createPlayerHeadlight() {
            playerHeadlight = new THREE.SpotLight(0xFFFFFF, 0, 100, Math.PI / 8, 0.5, 2);
            playerHeadlight.position.set(0, 1.0, 2.5); 
            playerHeadlight.target = new THREE.Object3D();
            playerHeadlight.target.position.set(0, 0.5, 50); 

            car.add(playerHeadlight); 
            car.add(playerHeadlight.target); 

            playerHeadlight.castShadow = true;
            playerHeadlight.shadow.mapSize.width = 512;
            playerHeadlight.shadow.mapSize.height = 512;
            playerHeadlight.shadow.camera.near = 0.1;
            playerHeadlight.shadow.camera.far = 100;
        }

        function createRoad() {
            const roadMaterial = new THREE.MeshStandardMaterial({
                color: 0xBBBBBB,
                roughness: 0.8,
                metalness: 0.1,
            });

            for (let i = 0; i < 30; i++) {
                const roadGeometry = new THREE.PlaneGeometry(roadWidth, 20);
                const roadSegment = new THREE.Mesh(roadGeometry, roadMaterial);
                roadSegment.rotation.x = -Math.PI / 2;
                roadSegment.position.z = i * 20 - 200;
                roadSegment.receiveShadow = true;
                scene.add(roadSegment);
                road.push(roadSegment);

                const dashedLineGeometry = new THREE.PlaneGeometry(0.4, 8);
                const lineMaterial = new THREE.MeshPhongMaterial({ color: 0xAAAAAA, emissive: 0x444444, emissiveIntensity: 1.5 });

                const laneDivider1X = -laneWidth / 2;
                const laneDivider2X = laneWidth / 2;

                [laneDivider1X, laneDivider2X].forEach(xOffset => {
                    for (let j = 0; j < 3; j++) {
                        const dashedLine = new THREE.Mesh(dashedLineGeometry, lineMaterial);
                        dashedLine.rotation.x = -Math.PI / 2;
                        dashedLine.position.set(xOffset, 0.01, (i * 20 - 200) + (j * 8 - 8));
                        dashedLine.userData.isRoadLine = true;
                        scene.add(dashedLine);
                        road.push(dashedLine);
                    }
                });
            }
        }

        function createRoadside() {
            const grassMaterial = new THREE.MeshStandardMaterial({
                color: 0x4CAF50,
                roughness: 0.9,
                metalness: 0.0
            });

            for (let i = 0; i < 30; i++) {
                const zPos = i * 20 - 200;

                const leftRoadsideGeometry = new THREE.PlaneGeometry(roadsideWidth, 20);
                const leftRoadside = new THREE.Mesh(leftRoadsideGeometry, grassMaterial);
                leftRoadside.rotation.x = -Math.PI / 2;
                leftRoadside.position.set(-(roadWidth / 2) - (roadsideWidth / 2), -0.01, zPos);
                leftRoadside.receiveShadow = true;
                scene.add(leftRoadside);
                road.push(leftRoadside);

                const rightRoadsideGeometry = new THREE.PlaneGeometry(roadsideWidth, 20);
                const rightRoadside = new THREE.Mesh(rightRoadsideGeometry, grassMaterial);
                rightRoadside.rotation.x = -Math.PI / 2;
                rightRoadside.position.set((roadWidth / 2) + (roadsideWidth / 2), -0.01, zPos);
                rightRoadside.receiveShadow = true;
                scene.add(rightRoadside);
                road.push(rightRoadside);
            }
        }

        function createBarriers() {
            const barrierHeight = 1;
            const barrierWidth = 0.5;
            const barrierMaterial = new THREE.MeshStandardMaterial({
                color: 0x555555,
                roughness: 0.7,
                metalness: 0.3
            });
            const barrierStripeMaterial = new THREE.MeshPhongMaterial({ color: 0xFF6600, emissive: 0xFF8800, emissiveIntensity: 2.0 });

            const barrierLeftX = -(roadWidth / 2) - (barrierWidth / 2);
            const barrierRightX = (roadWidth / 2) + (barrierWidth / 2);

            for (let i = 0; i < 30; i++) {
                const zPos = i * 20 - 200;

                const leftBarrier = new THREE.Mesh(new THREE.BoxGeometry(barrierWidth, barrierHeight, 20), barrierMaterial);
                leftBarrier.position.set(barrierLeftX, barrierHeight / 2, zPos);
                leftBarrier.castShadow = true;
                leftBarrier.receiveShadow = true;
                scene.add(leftBarrier);
                barriers.push(leftBarrier);

                for (let k = 0; k < 5; k++) {
                    const stripe = new THREE.Mesh(new THREE.BoxGeometry(barrierWidth + 0.01, barrierHeight + 0.01, 2), barrierStripeMaterial);
                    stripe.position.set(barrierLeftX, barrierHeight / 2, zPos - 10 + k * 4);
                    stripe.userData.isBarrierStripe = true;
                    scene.add(stripe);
                    barriers.push(stripe);
                }

                const rightBarrier = new THREE.Mesh(new THREE.BoxGeometry(barrierWidth, barrierHeight, 20), barrierMaterial);
                rightBarrier.position.set(barrierRightX, barrierHeight / 2, zPos);
                rightBarrier.castShadow = true;
                rightBarrier.receiveShadow = true;
                scene.add(rightBarrier);
                barriers.push(rightBarrier);

                for (let k = 0; k < 5; k++) {
                    const stripe = new THREE.Mesh(new THREE.BoxGeometry(barrierWidth + 0.01, barrierHeight + 0.01, 2), barrierStripeMaterial);
                    stripe.position.set(barrierRightX, barrierHeight / 2, zPos - 10 + k * 4);
                    stripe.userData.isBarrierStripe = true;
                    scene.add(stripe);
                    barriers.push(stripe);
                }
            }
        }

        function createTrafficCar(color, type = 'sedan', isPolice = false) {
            const carGroup = new THREE.Group();
            let bodyGeometry, roofGeometry, cabGeometry;
            let wheelPositions;
            let carLength, carWidth;
            let bodyYPosition;

            const bodyMaterial = new THREE.MeshStandardMaterial({
                color: color,
                roughness: 0.6,
                metalness: 0.1
            });
            const windowMaterial = new THREE.MeshStandardMaterial({
                color: 0x99DDFf,
                transparent: true,
                opacity: 0.7,
                roughness: 0.3,
                metalness: 0.0
            });
            const wheelMaterial = new THREE.MeshStandardMaterial({
                color: 0x1A1A1A,
                roughness: 0.8,
                metalness: 0.6
            });
            const trafficHeadlightMaterial = new THREE.MeshStandardMaterial({
                color: 0xFFFF88,
                emissive: 0xCCCC00,
                emissiveIntensity: 1.0,
                roughness: 0.1
            });
            const trafficTaillightMaterial = new THREE.MeshStandardMaterial({
                color: 0xFF0000,
                emissive: 0xAA0000,
                emissiveIntensity: 1.0,
                roughness: 0.1
            });

            switch (type) {
                case 'sedan':
                    bodyGeometry = new THREE.BoxGeometry(1.9, 0.9, 4.0);
                    roofGeometry = new THREE.BoxGeometry(1.7, 0.7, 2.2);
                    wheelPositions = [
                        { x: -1.05, y: 0.35, z: 1.6 },
                        { x: 1.05, y: 0.35, z: 1.6 },
                        { x: -1.05, y: 0.35, z: -1.6 },
                        { x: 1.05, y: 0.35, z: -1.6 }
                    ];
                    carLength = 4.0;
                    carWidth = 1.9;
                    bodyYPosition = 0.45;
                    break;
                case 'truck':
                    bodyGeometry = new THREE.BoxGeometry(2.2, 1.2, 6.5);
                    cabGeometry = new THREE.BoxGeometry(2.0, 1.5, 2.5);
                    wheelPositions = [
                        { x: -1.0, y: 0.6, z: 2.8 },
                        { x: 1.0, y: 0.6, z: 2.8 },
                        { x: -1.0, y: 0.6, z: -2.8 },
                        { x: 1.0, y: 0.6, z: -2.8 }
                    ];
                    carLength = 6.5;
                    carWidth = 2.2;
                    bodyYPosition = 0.6;
                    break;
                case 'sport': 
                    bodyGeometry = new THREE.BoxGeometry(1.8, 0.6, 3.8);
                    roofGeometry = new THREE.BoxGeometry(1.6, 0.4, 1.5);
                    wheelPositions = [
                        { x: -1.1, y: 0.2, z: 1.4 },
                        { x: 1.1, y: 0.2, z: 1.4 },
                        { x: -1.1, y: 0.2, z: -1.4 },
                        { x: 1.1, y: 0.2, z: -1.4 }
                    ];
                    carLength = 3.8;
                    carWidth = 1.8;
                    bodyYPosition = 0.3;

                    if (isPolice) {
                        bodyMaterial.color.set(0x000000);
                        
                        const policeLightGroup = new THREE.Group();
                        const lightBarGeometry = new THREE.BoxGeometry(1.2, 0.2, 0.3); 
                        const lightBarMesh = new THREE.Mesh(lightBarGeometry, new THREE.MeshStandardMaterial({color: 0x333333, roughness: 0.5, metalness: 0.8}));
                        lightBarMesh.position.y = 0.6; 
                        policeLightGroup.add(lightBarMesh);

                        const redLightBulb = new THREE.Mesh(new THREE.SphereGeometry(0.1, 8, 8), new THREE.MeshBasicMaterial({ color: 0xFF0000 }));
                        redLightBulb.position.set(-0.3, 0.6, 0.1); 
                        policeLightGroup.add(redLightBulb);

                        const blueLightBulb = new THREE.Mesh(new THREE.SphereGeometry(0.1, 8, 8), new THREE.MeshBasicMaterial({ color: 0x0000FF }));
                        blueLightBulb.position.set(0.3, 0.6, 0.1); 
                        policeLightGroup.add(blueLightBulb);
                        
                        const polisTextGeometry = new THREE.PlaneGeometry(1.2, 0.4); 
                        const polisTextMaterial = new THREE.MeshBasicMaterial({ color: 0xFFFFFF, side: THREE.DoubleSide }); 
                        const polisTextPlane = new THREE.Mesh(polisTextGeometry, polisTextMaterial);
                        polisTextPlane.position.set(0, 0.8, 2.0); 
                        polisTextPlane.rotation.x = Math.PI / 2; 
                        carGroup.add(polisTextPlane);

                        policeLightGroup.userData.redLightBulb = redLightBulb;
                        policeLightGroup.userData.blueLightBulb = blueLightBulb;
                        policeLightGroup.userData.lightState = 0; 

                        policeLightGroup.position.set(0, bodyYPosition + 0.5, 0); 
                        carGroup.add(policeLightGroup);

                        carGroup.userData.policeLightGroup = policeLightGroup; 
                    }
                    break;
                case 'minivan':
                    bodyGeometry = new THREE.BoxGeometry(2.1, 1.4, 4.5);
                    roofGeometry = new THREE.BoxGeometry(1.9, 1.1, 2.8);
                    wheelPositions = [
                        { x: -1.15, y: 0.6, z: 1.8 },
                        { x: 1.15, y: 0.6, z: 1.8 },
                        { x: -1.15, y: 0.6, z: -1.8 },
                        { x: 1.15, y: 0.6, z: -1.8 }
                    ];
                    carLength = 4.5;
                    carWidth = 2.1;
                    bodyYPosition = 0.7;
                    break;
                case 'bus':
                    bodyGeometry = new THREE.BoxGeometry(2.8, 2.2, 9.0);
                    wheelPositions = [
                        { x: -1.2, y: 1.0, z: 3.5 },
                        { x: 1.2, y: 1.0, z: 3.5 },
                        { x: -1.2, y: 1.0, z: -3.5 },
                        { x: 1.2, y: 1.0, z: -3.5 }
                    ];
                    carLength = 9.0;
                    carWidth = 2.8;
                    bodyYPosition = 1.1;
                    break;
                default: /* sedan as default */
                    bodyGeometry = new THREE.BoxGeometry(1.9, 0.9, 4.0);
                    roofGeometry = new THREE.BoxGeometry(1.7, 0.7, 2.2);
                    wheelPositions = [
                        { x: -1.05, y: 0.35, z: 1.6 },
                        { x: 1.05, y: 0.35, z: 1.6 },
                        { x: -1.05, y: 0.35, z: -1.6 },
                        { x: 1.05, y: 0.35, z: -1.6 }
                    ];
                    carLength = 4.0;
                    carWidth = 1.9;
                    bodyYPosition = 0.45;
                    break;
            }

            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            body.position.y = bodyYPosition;
            body.castShadow = true;
            carGroup.add(body);

            if (type === 'sedan' || type === 'minivan') {
                const roof = new THREE.Mesh(roofGeometry, bodyMaterial);
                roof.position.y = bodyYPosition + (bodyGeometry.parameters.height / 2) + (roofGeometry.parameters.height / 2) - 0.2;
                roof.position.z = bodyGeometry.parameters.depth / 2 - roofGeometry.parameters.depth / 2 - (type === 'minivan' ? 0.3 : 0.5);
                roof.castShadow = true;
                carGroup.add(roof);

                const windowGeom = new THREE.BoxGeometry(roofGeometry.parameters.width * 0.9, roofGeometry.parameters.height * 0.8, roofGeometry.parameters.depth * 0.9);
                const frontWindow = new THREE.Mesh(windowGeom, windowMaterial);
                frontWindow.position.set(0, roof.position.y, roof.position.z + roofGeometry.parameters.depth / 4);
                carGroup.add(frontWindow);

                const rearWindow = new THREE.Mesh(windowGeom, windowMaterial);
                rearWindow.position.set(0, roof.position.y, roof.position.z - roofGeometry.parameters.depth / 4);
                carGroup.add(rearWindow);

            } else if (type === 'sport' && !isPolice) { 
                const sportCabGeometry = new THREE.BoxGeometry(1.6, 0.5, 2.0);
                const sportCab = new THREE.Mesh(sportCabGeometry, bodyMaterial);
                sportCab.position.y = bodyYPosition + 0.5;
                sportCab.position.z = 0;
                sportCab.castShadow = true;
                carGroup.add(sportCab);

                const spoilerGeometry = new THREE.BoxGeometry(1.5, 0.1, 0.3);
                const spoiler = new THREE.Mesh(spoilerGeometry, bodyMaterial);
                spoiler.position.set(0, bodyYPosition + 0.8, -bodyGeometry.parameters.depth / 2 - 0.1);
                spoiler.castShadow = true;
                carGroup.add(spoiler);

            } else if (type === 'truck') {
                const cab = new THREE.Mesh(cabGeometry, bodyMaterial);
                cab.position.y = bodyYPosition + (bodyGeometry.parameters.height / 2) + (cabGeometry.parameters.height / 2) - 0.6;
                cab.position.z = bodyGeometry.parameters.depth / 2 - cabGeometry.parameters.depth / 2 + 1;
                cab.castShadow = true;
                carGroup.add(cab);
            }

            const wheelGeometry = new THREE.CylinderGeometry(0.4, 0.4, 0.35, 16);
            wheelPositions.forEach(pos => {
                const wheel = new THREE.Mesh(wheelGeometry, wheelMaterial);
                wheel.position.set(pos.x, pos.y, pos.z);
                wheel.rotation.z = Math.PI / 2;
                wheel.castShadow = true;
                carGroup.add(wheel);
            });

            const generalHeadlightMaterial = trafficHeadlightMaterial;
            const generalTaillightMaterial = trafficTaillightMaterial;

            if (type === 'sedan' || type === 'sport' || type === 'minivan') {
                const headlightStripGeometry = new THREE.BoxGeometry(0.3, 0.1, 0.05);
                [-0.7, 0.7].forEach(x => {
                    const headlight = new THREE.Mesh(headlightStripGeometry, generalHeadlightMaterial);
                    headlight.position.set(x, bodyYPosition + 0.2, bodyGeometry.parameters.depth / 2 - 0.05);
                    headlight.userData.isLight = true;
                    carGroup.add(headlight);
                });

                const taillightStripGeometry = new THREE.BoxGeometry(0.3, 0.1, 0.05);
                [-0.7, 0.7].forEach(x => {
                    const taillight = new THREE.Mesh(taillightStripGeometry, generalTaillightMaterial);
                    taillight.position.set(x, bodyYPosition + 0.2, -bodyGeometry.parameters.depth / 2 + 0.05);
                    taillight.userData.isLight = true;
                    carGroup.add(taillight);
                });
            } else if (type === 'truck') {
                const headlightGeometry = new THREE.BoxGeometry(0.3, 0.2, 0.1);
                [-0.7, 0.7].forEach(x => {
                    const headlight = new THREE.Mesh(headlightGeometry, generalHeadlightMaterial);
                    headlight.position.set(x, bodyYPosition + 1.0, (bodyGeometry.parameters.depth / 2) + 0.5);
                    headlight.userData.isLight = true;
                    carGroup.add(headlight);
                });
                const taillightGeometry = new THREE.BoxGeometry(0.5, 0.2, 0.1);
                [-0.7, 0.7].forEach(x => {
                    const taillight = new THREE.Mesh(taillightGeometry, generalTaillightMaterial);
                    taillight.position.set(x, bodyYPosition + 0.2, -(bodyGeometry.parameters.depth / 2) - 0.05);
                    taillight.userData.isLight = true;
                    carGroup.add(taillight);
                });
            } else if (type === 'bus') {
                const headlightGeometry = new THREE.BoxGeometry(0.6, 0.3, 0.1);
                [-0.9, 0.9].forEach(x => {
                    const headlight = new THREE.Mesh(headlightGeometry, generalHeadlightMaterial);
                    headlight.position.set(x, bodyYPosition + 1.2, bodyGeometry.parameters.depth / 2 - 0.1);
                    headlight.userData.isLight = true;
                    carGroup.add(headlight);
                });
                 const taillightGeometry = new THREE.BoxGeometry(0.8, 0.4, 0.1);
                [-0.9, 0.9].forEach(x => {
                    const taillight = new THREE.Mesh(taillightGeometry, generalTaillightMaterial);
                    taillight.position.set(x, bodyYPosition + 0.4, -(bodyGeometry.parameters.depth / 2) + 0.05);
                    taillight.userData.isLight = true;
                    carGroup.add(taillight);
                });
            }

            // Ã–NEMLÄ° DÃœZELTME: Boyut verilerini arabanÄ±n kendisine kaydet
            carGroup.userData.originalLength = carLength;
            carGroup.userData.originalWidth = carWidth;
            carGroup.userData.length = carLength;
            carGroup.userData.width = carWidth;

            return { car: carGroup, length: carLength, width: carWidth };
        }

        function createInitialTrafficCars(count) {
            for (let i = 0; i < count; i++) {
                let newCar = getPooledTrafficCar();
                if (newCar) {
                    const lane = lanes[Math.floor(Math.random() * lanes.length)];
                    let zSpawnPosition = -150 - (i * (Math.random() * 40 + 40));

                    let overlap = true;
                    let attempts = 0;
                    while (overlap && attempts < 20) {
                        overlap = false;
                        for (const existingCar of trafficCars) {
                            if (Math.abs(existingCar.position.x - lane) < laneWidth / 2 &&
                                Math.abs(existingCar.position.z - zSpawnPosition) < (existingCar.userData.length / 2 + newCar.userData.length / 2 + minDistanceBetweenCars)) {
                                overlap = true;
                                zSpawnPosition -= (existingCar.userData.length + newCar.userData.length + minDistanceBetweenCars);
                                break;
                            }
                        }
                        attempts++;
                    }
                    if (overlap) { 
                        zSpawnPosition = camera.position.z - 500 - (Math.random() * 200);
                    }

                    newCar.position.set(lane, 0, zSpawnPosition);
                    newCar.rotation.y = Math.PI; 
                    newCar.userData.currentLane = lane;
                    newCar.userData.targetLane = lane;
                    newCar.userData.isChangingLane = false;
                    newCar.userData.wander = (Math.random() - 0.5) * 0.5;
                    newCar.userData.wanderTarget = (Math.random() - 0.5) * 0.5;
                    newCar.visible = true;
                    trafficCars.push(newCar);
                }
            }
        }

        function getPooledTrafficCar() {
            const car = pooledTrafficCars.find(c => !c.visible);
            if (car) {
                car.visible = true;
                // Ã–NEMLÄ° DÃœZELTME: Havuzdan alÄ±nan arabanÄ±n boyutlarÄ±nÄ± geri yÃ¼kle
                car.userData.length = car.userData.originalLength;
                car.userData.width = car.userData.originalWidth;
                return car;
            }
            return null;
        }

        function releasePooledTrafficCar(car) {
            car.visible = false;
            car.position.set(0, 0, -1000); 
        }


        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function onKeyDown(e) {
            if (e.key) {
                const lowerKey = e.key.toLowerCase();
                keys[lowerKey] = true;

                if (keyMap[lowerKey]) {
                    keyMap[lowerKey].classList.add('active');
                } else if (lowerKey === 'arrowup' && keyMap['arrowup']) {
                    keyMap['arrowup'].classList.add('active');
                } else if (lowerKey === 'arrowdown' && keyMap['arrowdown']) {
                    keyMap['arrowdown'].classList.add('active');
                } else if (lowerKey === 'arrowleft' && keyMap['arrowleft']) {
                    keyMap['arrowleft'].classList.add('active');
                } else if (lowerKey === 'arrowright' && keyMap['arrowright']) {
                    keyMap['arrowright'].classList.add('active');
                }
            }
            if ((e.key === 'arrowdown' || e.key === 's') && gameRunning) {
                if (brakeLightMesh) {
                    brakeLightMesh.material.emissiveIntensity = 5.0; 
                    brakeLightMesh.material.needsUpdate = true;
                }
                if (carSpeed > 5 && (!window.currentBrakeSound || window.currentBrakeSound.playState !== 'playing')) {
                    window.currentBrakeSound = playSound(brakeBuffer, THREE.MathUtils.mapLinear(carSpeed, 0, maxSpeed, 0.2, 0.8), true);
                } else if (window.currentBrakeSound) {
                    window.currentBrakeSound.gainNode.gain.setValueAtTime(THREE.MathUtils.mapLinear(carSpeed, 0, maxSpeed, 0.2, 0.8), audioContext.currentTime);
                }
            }
            if ((e.key === 'r' || e.key === 'R') && gameRunning) {
                fireRocket();
            }
        }

        function onKeyUp(e) {
            if (e.key) {
                const lowerKey = e.key.toLowerCase();
                keys[lowerKey] = false;

                if (keyMap[lowerKey]) {
                    keyMap[lowerKey].classList.remove('active');
                } else if (lowerKey === 'arrowup' && keyMap['arrowup']) {
                    keyMap['arrowup'].classList.remove('active');
                } else if (lowerKey === 'arrowdown' && keyMap['arrowdown']) {
                    keyMap['arrowdown'].classList.remove('active');
                } else if (lowerKey === 'arrowleft' && keyMap['arrowleft']) {
                    keyMap['arrowleft'].classList.remove('active');
                } else if (lowerKey === 'arrowright' && keyMap['arrowright']) {
                    keyMap['arrowright'].classList.remove('active');
                }
            }
            if (window.currentBrakeSound) {
                window.currentBrakeSound.stop();
                window.currentBrakeSound = null;
            }
            if (brakeLightMesh) {
                brakeLightMesh.material.emissiveIntensity = 0.0;
                brakeLightMesh.material.needsUpdate = true;
            }
        }

        function startActuallyGame() {
            console.log("startActuallyGame Ã§aÄŸrÄ±ldÄ±.");
            hideAllScreensForGame(); 
            
            if (introGainNode) {
                introGainNode.gain.setValueAtTime(0.25, audioContext.currentTime); 
            }

            startEngineSound();
            startGame(); 
        }


        function startGame() {
            console.log("startGame Ã§aÄŸrÄ±ldÄ±.");
            gameRunning = true;
            gameStarted = true;
            score = 0;
            distance = 0;
            level = 1;
            combo = 0;
            highCombo = 0;
            carSpeed = 0;
            roadSpeed = 0.5;
            carTilt = 0;
            rockets = 0; 
            trafficCarsDestroyedByRocket = 0;
            rocketsFiredCount = 0; 
            health = 100;
            updateHealthBar();
            document.getElementById('rocketsDisplay').textContent = rockets;
            lastPoliceCarDespawnTime = 0;
            policeDifficultyMultiplier = 1.0;
            nextRadarSpawnDistance = 0;

            policeDamageStartTime = 0;
            currentPoliceChaseDamage = 0;
            lastPoliceIncrementalDamageTime = 0;

            car.position.set(0, 0, -5);
            car.rotation.y = Math.PI; 
            car.rotation.z = 0; 

            car.children.forEach(child => {
                if (child.isGroup && child.children.some(grandchild => grandchild.geometry instanceof THREE.CylinderGeometry)) {
                    child.rotation.z = 0; 
                }
            });

            if (brakeLightMesh) {
                brakeLightMesh.material.emissiveIntensity = 0.0;
                brakeLightMesh.material.needsUpdate = true;
            }
            spoilerTaillights.forEach(light => {
                if (light && light.material) {
                    light.material.emissiveIntensity = 5.0; 
                    light.material.needsUpdate = true;
                }
            });


            if (window.currentBrakeSound) {
                window.currentBrakeSound.stop();
                window.currentBrakeSound = null;
            }
            if (activePoliceCar && activePoliceCar.userData.sirenSource) {
                activePoliceCar.userData.sirenSource.stop();
                activePoliceCar.userData.sirenSource.disconnect();
                activePoliceCar.userData.sirenSource = null;
                activePoliceCar.userData.sirenGainNode = null;
            }

            trafficCars.forEach(car => releasePooledTrafficCar(car));
            trafficCars = [];
            policeCarsPool.forEach(pCar => pCar.visible = false); 

            createInitialTrafficCars(15); 


            roadsideElements.forEach(obj => scene.remove(obj));
            roadsideElements = [];
            radarPoles.forEach(obj => scene.remove(obj));
            radarPoles = [];
            createInitialRoadsideElements(10);

            powerUps.forEach(powerUp => scene.remove(powerUp)); 
            powerUps = []; 
            lastPowerUpSpawnTime = Date.now(); 

            if (activeRocket) {
                scene.remove(activeRocket);
                activeRocket = null;
            }
            rocketParticles.forEach(p => scene.remove(p));
            rocketParticles = [];

            /* Konsolu belirli bir sÃ¼re sonra gizle */
            if (cockpitConsole) {
                setTimeout(() => {
                    cockpitConsole.style.bottom = '-200px'; 
                    cockpitConsole.style.opacity = '0'; 
                    cockpitConsole.style.pointerEvents = 'none'; 
                }, 5000); 
            }

            if (!animationFrameId) {
                animationFrameId = requestAnimationFrame(update);
            }

            // Yeni eklemeler
            sirenWarningCount = 0;
            lastSirenWarningTime = Date.now(); // ZamanlayÄ±cÄ±yÄ± baÅŸlat
            sirenStarElements = Array.from(document.querySelectorAll('.siren-star'));
            updateSirenStars(); // YÄ±ldÄ±zlarÄ± baÅŸlangÄ±Ã§ta boÅŸalt
        }

        function getPooledPoliceCar() {
            let policeCar = policeCarsPool.find(car => !car.visible);
            if (policeCar) {
                policeCar.visible = true;
            } else {
                const { car: newPoliceCar, length, width } = createTrafficCar(0x000000, 'sport', true);
                newPoliceCar.userData.isPooled = true;
                newPoliceCar.userData.length = length;
                newPoliceCar.userData.width = width;
                newPoliceCar.userData.type = 'sport';
                newPoliceCar.userData.isPolice = true;
                newPoliceCar.userData.currentLane = 0;
                newPoliceCar.userData.targetLane = 0;
                newPoliceCar.userData.isChangingLane = false;
                newPoliceCar.userData.wander = 0;
                newPoliceCar.userData.wanderTarget = 0;
                newPoliceCar.userData.lastX = 0;
                newPoliceCar.userData.trafficCollisions = 0;
                scene.add(newPoliceCar);
                policeCarsPool.push(newPoliceCar);
                policeCar = newPoliceCar;
            }
            policeCar.userData.policeStartTime = Date.now();
            policeCar.userData.isChangingLane = false;
            policeCar.userData.wander = 0;
            policeCar.userData.wanderTarget = 0;
            policeCar.userData.lastSpeedSample = carSpeed;
            policeCar.userData.trafficCollisions = 0;
            return policeCar;
        }

        function releasePooledPoliceCar(policeCar) {
            policeCar.visible = false;
            policeCar.position.set(0, 0, -1000);
            if (policeCar.userData.policeLightGroup) {
                 policeCar.userData.policeLightGroup.userData.redLightBulb.material.emissiveIntensity = 0;
                 policeCar.userData.policeLightGroup.userData.blueLightBulb.material.emissiveIntensity = 0;
                 policeCar.userData.policeLightGroup.userData.lightState = 0;
            }
            if (policeCar.userData.sirenSource) {
                policeCar.userData.sirenSource.stop();
                policeCar.userData.sirenSource.disconnect();
                policeCar.userData.sirenSource = null;
                policeCar.userData.sirenGainNode = null;
            }
        }

        function gameOver() {
            gameRunning = false;
            cancelAnimationFrame(animationFrameId);
            animationFrameId = null;

            if (engineSource) {
                engineSource.stop();
                engineSource.disconnect();
                engineSource = null;
                engineGainNode = null;
            }
            if (activePoliceCar && activePoliceCar.userData.sirenSource) {
                activePoliceCar.userData.sirenSource.stop();
                activePoliceCar.userData.sirenSource = null;
            }
            if (window.currentBrakeSound) {
                window.currentBrakeSound.stop();
                window.currentBrakeSound = null;
            }
            if (brakeLightMesh) {
                brakeLightMesh.material.emissiveIntensity = 0.0;
                brakeLightMesh.material.needsUpdate = true;
            }
            spoilerTaillights.forEach(light => {
                if (light && light.material) {
                    light.material.emissiveIntensity = 0.0; 
                    light.material.needsUpdate = true;
                }
            });
            
            /* Intro sesini tekrar Ã§al */
            if (introBuffer && introGainNode) {
                introGainNode.gain.setValueAtTime(0.9, audioContext.currentTime); 
                if (introSource && introSource.playState !== 'playing') {
                    introSource.start(0);
                    introSource.playState = 'playing';
                }
                console.log("Intro sesi oyun bittikten sonra baÅŸlatÄ±ldÄ±.");
            } else if (introBuffer && audioContext) { 
                introSource = audioContext.createBufferSource();
                introSource.buffer = introBuffer;
                introSource.loop = true;
                introGainNode = audioContext.createGain();
                introGainNode.gain.setValueAtTime(0.9, audioContext.currentTime);
                introSource.connect(introGainNode);
                introGainNode.connect(audioContext.destination);
                introSource.start(0);
                introSource.playState = 'playing';
                console.log("Intro sesi oyun bittikten sonra baÅŸlatÄ±ldÄ± (yeni kaynak).");
            } else {
                console.error("Intro sesi buffer'Ä± yÃ¼klenemedi.");
            }


            document.getElementById('finalScore').textContent = score;
            document.getElementById('finalDistance').textContent = Math.floor(distance);
            document.getElementById('maxCombo').textContent = highCombo;
            document.getElementById('gameOver').style.display = 'block';

            saveHighScore(score, playerName);
            displayHighScores();

            setTimeout(() => {
                document.getElementById('gameOver').style.display = 'none';
                showPreIntroScreen(); /* Oyun bittikten sonra ilk ekranÄ± gÃ¶ster */
            }, 10000); // RekorlarÄ±n gÃ¶rÃ¼nmesi iÃ§in sÃ¼re artÄ±rÄ±ldÄ±
        }

        function createExplosion(x, y, z) {
            const fireCount = 60;
            const fireVelocities = [];
            const fireGeometry = new THREE.BufferGeometry();
            const firePositions = new Float32Array(fireCount * 3);

            for (let i = 0; i < fireCount; i++) {
                firePositions[i * 3] = x;
                firePositions[i * 3 + 1] = y;
                firePositions[i * 3 + 2] = z;
                fireVelocities.push(new THREE.Vector3((Math.random() - 0.5) * 1.2, (Math.random() - 0.5) * 1.2, (Math.random() - 0.5) * 1.2));
            }
            fireGeometry.setAttribute('position', new THREE.BufferAttribute(firePositions, 3));

            const fireMaterial = new THREE.PointsMaterial({
                color: 0xFF4500,
                size: 2.5,
                transparent: true,
                opacity: 0.9,
                blending: THREE.AdditiveBlending,
                sizeAttenuation: true,
            });
            const fireSystem = new THREE.Points(fireGeometry, fireMaterial);
            scene.add(fireSystem);

            // Siyah ve KÄ±rmÄ±zÄ± Duman PartikÃ¼lleri
            const smokeCount = 80;
            const smokeVelocities = [];
            const smokeGeometry = new THREE.BufferGeometry();
            const smokePositions = new Float32Array(smokeCount * 3);
            const smokeColors = new Float32Array(smokeCount * 3);
            const smokeColor = new THREE.Color();

            for (let i = 0; i < smokeCount; i++) {
                smokePositions[i * 3] = x + (Math.random() - 0.5) * 0.5;
                smokePositions[i * 3 + 1] = y + (Math.random() - 0.5) * 0.5;
                smokePositions[i * 3 + 2] = z + (Math.random() - 0.5) * 0.5;
                smokeVelocities.push(new THREE.Vector3((Math.random() - 0.5) * 0.4, Math.random() * 0.6, (Math.random() - 0.5) * 0.4));

                if (Math.random() < 0.4) { // %40 KÄ±rmÄ±zÄ±/Turuncu duman
                    smokeColor.set(Math.random() < 0.5 ? 0xFF4500 : 0xDC143C);
                } else { // %60 Siyah/Gri duman
                    const shade = Math.random() * 0.3;
                    smokeColor.setRGB(shade, shade, shade);
                }
                smokeColors[i * 3] = smokeColor.r;
                smokeColors[i * 3 + 1] = smokeColor.g;
                smokeColors[i * 3 + 2] = smokeColor.b;
            }
            smokeGeometry.setAttribute('position', new THREE.BufferAttribute(smokePositions, 3));
            smokeGeometry.setAttribute('color', new THREE.BufferAttribute(smokeColors, 3));

            const smokeMaterial = new THREE.PointsMaterial({
                size: 3.5,
                vertexColors: true,
                transparent: true,
                opacity: 0.6,
                blending: THREE.NormalBlending,
                sizeAttenuation: true,
            });
            const smokeSystem = new THREE.Points(smokeGeometry, smokeMaterial);
            scene.add(smokeSystem);


            let frame = 0;
            const maxFrames = 90;

            const animateParticles = () => {
                if (!gameRunning && frame > 0) { // Oyun bittiyse temizle
                    scene.remove(fireSystem);
                    scene.remove(smokeSystem);
                    return;
                }

                const firePos = fireSystem.geometry.attributes.position.array;
                for (let i = 0; i < fireCount; i++) {
                    firePos[i * 3] += fireVelocities[i].x;
                    firePos[i * 3 + 1] += fireVelocities[i].y;
                    firePos[i * 3 + 2] += fireVelocities[i].z;
                    fireVelocities[i].multiplyScalar(0.95);
                }
                fireSystem.geometry.attributes.position.needsUpdate = true;
                fireMaterial.opacity = 0.9 * (1 - (frame / maxFrames));
                fireMaterial.size *= 0.97;

                const smokePos = smokeSystem.geometry.attributes.position.array;
                for (let i = 0; i < smokeCount; i++) {
                    smokePos[i * 3] += smokeVelocities[i].x;
                    smokePos[i * 3 + 1] += smokeVelocities[i].y;
                    smokePos[i * 3 + 2] += smokeVelocities[i].z;
                    smokeVelocities[i].y += 0.008; // Duman yÃ¼kselir
                    smokeVelocities[i].multiplyScalar(0.97);
                }
                smokeSystem.geometry.attributes.position.needsUpdate = true;
                smokeMaterial.opacity = 0.6 * (1 - (frame / maxFrames));
                smokeMaterial.size *= 1.015; // Duman geniÅŸler

                frame++;

                if (frame < maxFrames) {
                    requestAnimationFrame(animateParticles);
                } else {
                    scene.remove(fireSystem);
                    scene.remove(smokeSystem);
                }
            };
            animateParticles();
        }

        function updateCarPosition() {
            const baseTurningSensitivity = 0.15;
            const speedAdjustedTurningSensitivity = baseTurningSensitivity * (1 + (carSpeed / maxSpeed) * 1.0); 

            let targetTilt = 0; 
            let currentYaw = 0; 
            const maxYaw = Math.PI / 16; 
            const yawResponsiveness = 0.08; 

            let wheelGroup = null;
            car.children.forEach(child => {
                if (child.isGroup && child.children.some(grandchild => grandchild.geometry instanceof THREE.CylinderGeometry)) {
                    wheelGroup = child;
                }
            });

            if (wheelGroup) {
                wheelGroup.position.set(0, 0, 0); 
                wheelGroup.rotation.z = 0; 
            }

            if (keys['arrowleft'] || keys['a'] || mobileControls.left) {
                car.position.x = Math.max(-roadWidth / 2 + 1.5, car.position.x - speedAdjustedTurningSensitivity);
                targetTilt = -maxCarTilt; 
                currentYaw = THREE.MathUtils.lerp(currentYaw, maxYaw, yawResponsiveness); 
            } else if (keys['arrowright'] || keys['d'] || mobileControls.right) {
                car.position.x = Math.min(roadWidth / 2 - 1.5, car.position.x + speedAdjustedTurningSensitivity);
                targetTilt = maxCarTilt; 
                currentYaw = THREE.MathUtils.lerp(currentYaw, -maxYaw, yawResponsiveness); 
            } else {
                currentYaw = THREE.MathUtils.lerp(currentYaw, 0, yawResponsiveness * 2); 
            }

            const tiltResponsiveness = 0.1;
            carTilt += (targetTilt - carTilt) * tiltResponsiveness;
            car.rotation.z = carTilt; 
            car.rotation.y = Math.PI + currentYaw; 
            
            if (keys['arrowup'] || keys['w'] || mobileControls.accelerate) {
                carSpeed = Math.min(carSpeed + 0.8, maxSpeed);
            } else if (keys['arrowdown'] || keys['s'] || mobileControls.brake) {
                carSpeed = Math.max(carSpeed - 2.5, 0); // Daha keskin frenleme eklendi
                if (brakeLightMesh) {
                    brakeLightMesh.material.emissiveIntensity = 5.0; 
                    brakeLightMesh.material.needsUpdate = true;
                }
                if (carSpeed > 5 && (!window.currentBrakeSound || window.currentBrakeSound.playState !== 'playing')) {
                    window.currentBrakeSound = playSound(brakeBuffer, THREE.MathUtils.mapLinear(carSpeed, 0, maxSpeed, 0.2, 0.8), true);
                } else if (window.currentBrakeSound) {
                    window.currentBrakeSound.gainNode.gain.setValueAtTime(THREE.MathUtils.mapLinear(carSpeed, 0, maxSpeed, 0.2, 0.8), audioContext.currentTime);
                }
            } else {
                if (brakeLightMesh) {
                    brakeLightMesh.material.emissiveIntensity = 0.0; 
                    brakeLightMesh.material.needsUpdate = true;
                }
                carSpeed = Math.max(carSpeed - 0.1, 0);
                if (window.currentBrakeSound) {
                    window.currentBrakeSound.stop();
                    window.currentBrakeSound = null;
                }
            }

            const roadBoundary = roadWidth / 2 - 1.5;
            car.position.x = Math.max(-roadBoundary, Math.min(roadBoundary, car.position.x));

            // ZÄ±plama FiziÄŸi
            if (isJumping) {
                car.position.y += jumpVelocityY;
                jumpVelocityY -= jumpGravity;

                // Yere dÃ¶nÃ¼ÅŸ
                if (car.position.y <= 0) {
                    car.position.y = 0;
                    isJumping = false;
                    jumpVelocityY = 0;
                    triggerCollisionShake(0.5, 30); // Yere sert iniÅŸ efekti
                    showScoreFeedback("Ä°NÄ°Å BAÅARILI! +1000", "#4CAF50");
                    addScore(1000);
                }
            }
        }

        function updateTraffic() {
            const laneChangeProbability = 0.005;
            const laneChangeSpeed = 0.05;

            for (let i = trafficCars.length - 1; i >= 0; i--) {
                const trafficCar = trafficCars[i];
                if (!trafficCar || !trafficCar.visible) continue;

                let carCurrentSpeed = roadSpeed + (carSpeed / 100);

                // AGRESÄ°F POLÄ°S MANTIÄI
                if (trafficCar.userData.isAggressiveRammer) {
                    const rammingDuration = 10000;
                    const lifeTime = Date.now() - trafficCar.userData.rammingStartTime;
                    const targetX = trafficCar.userData.target.position.x;
                    
                    trafficCar.position.x += (targetX - trafficCar.position.x) * 0.08;
                    carCurrentSpeed *= 1.2;

                    if (lifeTime > rammingDuration || trafficCar.position.z > car.position.z + 100) {
                        createExplosion(trafficCar.position.x, trafficCar.position.y, trafficCar.position.z);
                        if (activePoliceCar && activePoliceCar.userData.sirenSound) {
                            activePoliceCar.userData.sirenSound.stop();
                            activePoliceCar.userData.sirenSound = null;
                        }
                        releasePooledPoliceCar(trafficCar);
                        activePoliceCar = null;
                        trafficCars.splice(i, 1);
                        continue;
                    }
                }
                // NORMAL TRAFÄ°K MANTIÄI
                else if (!trafficCar.userData.isPolice) {
                    if (!trafficCar.userData.isChangingLane && Math.random() < laneChangeProbability) {
                        const currentLaneIndex = lanes.findIndex(lane => Math.abs(trafficCar.position.x - lane) < laneWidth / 2);
                        const possibleDirections = [];
                        if (currentLaneIndex > 0) possibleDirections.push(-1);
                        if (currentLaneIndex < lanes.length - 1) possibleDirections.push(1);

                        if (possibleDirections.length > 0) {
                            const direction = possibleDirections[Math.floor(Math.random() * possibleDirections.length)];
                            trafficCar.userData.targetLane = lanes[currentLaneIndex + direction];
                            trafficCar.userData.isChangingLane = true;
                        }
                    }
                    if (trafficCar.userData.isChangingLane) {
                        trafficCar.position.x += (trafficCar.userData.targetLane - trafficCar.position.x) * laneChangeSpeed;
                        if (Math.abs(trafficCar.position.x - trafficCar.userData.targetLane) < 0.2) {
                            trafficCar.position.x = trafficCar.userData.targetLane;
                            trafficCar.userData.isChangingLane = false;
                        }
                    }
                }

                trafficCar.position.z += carCurrentSpeed;
                trafficCar.userData.speed = carCurrentSpeed; // HÄ±z verisini kaydet

                if (trafficCar.position.z > camera.position.z + 50) {
                    releasePooledTrafficCar(trafficCar);
                    trafficCars.splice(i, 1);
                    if (trafficCar === activePoliceCar) {
                        activePoliceCar = null;
                    }
                }
            }

            // Yeni trafik aracÄ± ekleme
            if (trafficCars.filter(tc => !tc.userData.isPolice).length < (5 + level * 2)) {
                let newCar = getPooledTrafficCar();
                if (newCar) {
                    const lane = lanes[Math.floor(Math.random() * lanes.length)];
                    let zSpawnPosition = camera.position.z - 250 - (Math.random() * 50);
                    newCar.position.set(lane, 0, zSpawnPosition);
                    Object.assign(newCar.userData, { currentLane: lane, targetLane: lane, isChangingLane: false });
                    trafficCars.push(newCar);
                }
            }
        }


        function updateRoad() {
            road.forEach(segment => {
                segment.position.z += roadSpeed + (carSpeed / 100);

                if (segment.position.z > camera.position.z + 20) {
                    segment.position.z -= 600;
                }
            });

            barriers.forEach(barrier => {
                barrier.position.z += roadSpeed + (carSpeed / 100);

                if (barrier.position.z > camera.position.z + 20) {
                    barrier.position.z -= 600;
                }
            });
        }

        function createTree(x, z) {
            const treeGroup = new THREE.Group();

            const trunkGeometry = new THREE.CylinderGeometry(0.5, 0.7, 5, 8);
            const trunkMaterial = new THREE.MeshStandardMaterial({
                color: 0x8B4513,
                roughness: 0.9,
                metalness: 0.0
            });
            const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
            trunk.position.y = 2.5;
            trunk.castShadow = true;
            treeGroup.add(trunk);

            const leavesMaterial = new THREE.MeshStandardMaterial({
                color: 0x228B22,
                roughness: 0.7,
                metalness: 0.0
            });

            const topLeaves = new THREE.Mesh(new THREE.ConeGeometry(2, 4, 8), leavesMaterial);
            topLeaves.position.y = 6;
            topLeaves.castShadow = true;
            treeGroup.add(topLeaves);

            const middleLeaves = new THREE.Mesh(new THREE.ConeGeometry(2.5, 3, 8), leavesMaterial);
            middleLeaves.position.y = 4;
            middleLeaves.castShadow = true;
            treeGroup.add(middleLeaves);

            treeGroup.position.set(x, 0, z);
            return treeGroup;
        }

        function createSign(x, z) {
            const signGroup = new THREE.Group();

            const poleGeometry = new THREE.CylinderGeometry(0.2, 0.2, 4, 6);
            const poleMaterial = new THREE.MeshStandardMaterial({
                color: 0xAAAAAA,
                roughness: 0.6,
                metalness: 0.4
            });
            const pole = new THREE.Mesh(poleGeometry, poleMaterial);
            pole.position.y = 2;
            pole.castShadow = true;
            signGroup.add(pole);

            const boardGeometry = new THREE.BoxGeometry(3, 1.5, 0.1);
            const boardMaterial = new THREE.MeshStandardMaterial({
                color: 0xFFFFFF,
                roughness: 0.7,
                metalness: 0.0
            });
            const board = new THREE.Mesh(boardGeometry, boardMaterial);
            board.position.set(0, 3.5, 0);
            board.castShadow = true;
            signGroup.add(board);

            signGroup.position.set(x, 0, z);
            return signGroup;
        }

        function createDeer(x, z) {
            const deerGroup = new THREE.Group();

            const bodyMaterial = new THREE.MeshStandardMaterial({ color: 0x8B4513, roughness: 0.8, metalness: 0.0 });
            const antlerMaterial = new THREE.MeshStandardMaterial({ color: 0xD2B48C, roughness: 0.8, metalness: 0.0 });

            const bodyGeometry = new THREE.BoxGeometry(0.8, 1.0, 1.5);
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            body.position.y = 0.5;
            body.castShadow = true;
            deerGroup.add(body);

            const headGeometry = new THREE.BoxGeometry(0.5, 0.5, 0.5);
            const head = new THREE.Mesh(headGeometry, bodyMaterial);
            head.position.set(0, 1.2, 0.6);
            head.castShadow = true;
            deerGroup.add(head);

            const legGeometry = new THREE.BoxGeometry(0.2, 0.8, 0.2);
            const legPositions = [
                { x: -0.3, z: 0.5 },
                { x: 0.3, z: 0.5 },
                { x: -0.3, z: -0.5 },
                { x: 0.3, z: -0.5 }
            ];
            legPositions.forEach(pos => {
                const leg = new THREE.Mesh(legGeometry, bodyMaterial);
                leg.position.set(pos.x, 0.4, pos.z);
                leg.castShadow = true;
                deerGroup.add(leg);
            });

            const antler1Geometry = new THREE.CylinderGeometry(0.1, 0.1, 0.8, 4);
            const antler1 = new THREE.Mesh(antler1Geometry, antlerMaterial);
            antler1.position.set(-0.15, 1.6, 0.7);
            antler1.rotation.z = Math.PI / 8;
            antler1.castShadow = true;
            deerGroup.add(antler1);

            const antler2Geometry = new THREE.CylinderGeometry(0.1, 0.1, 0.8, 4);
            const antler2 = new THREE.Mesh(antler2Geometry, antlerMaterial);
            antler2.position.set(0.15, 1.6, 0.7);
            antler2.rotation.z = -Math.PI / 8;
            antler2.castShadow = true;
            deerGroup.add(antler2);

            deerGroup.position.set(x, 0, z);
            return deerGroup;
        }

        function createRadarPoleOnce(zPos) {
            const radarSide = (Math.random() < 0.5 ? -1 : 1);
            const xPos = radarSide * (roadWidth / 2 + roadsideWidth / 2 + (Math.random() * 5));

            const radarGroup = new THREE.Group();

            const poleGeometry = new THREE.CylinderGeometry(0.2, 0.2, 5, 8);
            const poleMaterial = new THREE.MeshStandardMaterial({
                color: 0x888888,
                roughness: 0.6,
                metalness: 0.4
            });
            const pole = new THREE.Mesh(poleGeometry, poleMaterial);
            pole.position.y = 2.5;
            pole.castShadow = true;
            radarGroup.add(pole);

            const boxGeometry = new THREE.BoxGeometry(1.2, 0.8, 0.8);
            const boxMaterial = new THREE.MeshStandardMaterial({
                color: 0x000000,
                roughness: 0.5,
                metalness: 0.8
            });
            const box = new THREE.Mesh(boxGeometry, boxMaterial);
            box.position.set(0, 4.5, 0);
            box.castShadow = true;
            radarGroup.add(box);

            const lightMaterial = new THREE.MeshStandardMaterial({
                color: 0xFF0000,
                emissive: 0xFF0000,
                emissiveIntensity: 2.0,
                roughness: 0.1
            });
            const light1 = new THREE.Mesh(new THREE.SphereGeometry(0.15, 8, 8), lightMaterial);
            light1.position.set(-0.3, 4.8, 0.4);
            radarGroup.add(light1);
            const light2 = new THREE.Mesh(new THREE.SphereGeometry(0.15, 8, 8), lightMaterial);
            light2.position.set(0.3, 4.8, 0.4);
            radarGroup.add(light2);

            radarGroup.position.set(xPos, 0, zPos);
            radarGroup.userData.isRadar = true;
            radarGroup.userData.hitCooldown = 5000;
            radarGroup.userData.lastHit = 0;
            radarGroup.userData.spawnDistance = distance;

            scene.add(radarGroup);
            radarPoles.push(radarGroup);

            nextRadarSpawnDistance = distance + 5000;
        }

        function spawnPoliceCar() {
            const newPoliceCar = getPooledPoliceCar();
            if (newPoliceCar) {
                const playerLaneIndex = lanes.findIndex(lane => Math.abs(car.position.x - lane) < laneWidth / 2);
                let spawnLane;
                if (playerLaneIndex !== -1) {
                    spawnLane = lanes[playerLaneIndex];
                } else {
                    spawnLane = lanes[Math.floor(Math.random() * lanes.length)];
                }

                newPoliceCar.position.set(spawnLane, 0, car.position.z - 60); 
                newPoliceCar.rotation.y = Math.PI;
                newPoliceCar.userData.currentLane = spawnLane;
                newPoliceCar.userData.targetLane = spawnLane;
                newPoliceCar.userData.lastX = newPoliceCar.position.x;
                newPoliceCar.userData.trafficCollisions = 0;
                newPoliceCar.userData.initialHitOccurred = false;
                
                trafficCars.push(newPoliceCar);
                activePoliceCar = newPoliceCar;
                lastPoliceCarDespawnTime = Date.now();
                currentPoliceChaseDamage = 0;

                showScoreFeedback('POLÄ°S PEÅÄ°NÄ°ZDE!', '#FF4500');

                if (policeSirenBuffer && audioContext) {
                    if (activePoliceCar.userData.sirenSource && activePoliceCar.userData.sirenSource.playState === 'playing') {
                        activePoliceCar.userData.sirenSource.stop();
                    }
                    const sirenSourceNode = audioContext.createBufferSource(); 
                    sirenSourceNode.buffer = policeSirenBuffer;
                    sirenSourceNode.loop = true;
                    const sirenGainNode = audioContext.createGain();
                    sirenGainNode.gain.setValueAtTime(2.5, audioContext.currentTime);
                    sirenSourceNode.connect(sirenGainNode);
                    sirenGainNode.connect(audioContext.destination);
                    sirenSourceNode.start(0);
                    newPoliceCar.userData.sirenSource = {
                        source: sirenSourceNode, 
                        gainNode: sirenGainNode, 
                        playState: 'playing', 
                        stop: function() { 
                            if (this.playState === 'playing') {
                                this.source.stop(); 
                                this.source.disconnect(); 
                                this.gainNode.disconnect(); 
                                this.playState = 'stopped'; 
                                console.log("Polis sireni (nesne iÃ§inden) durduruldu.");
                            }
                        }
                    };
                    console.log("Polis sireni Ã§almaya baÅŸladÄ±.");
                }

                policeDamageStartTime = Date.now();
                currentPoliceChaseDamage = 0; /* BaÅŸlangÄ±Ã§ hasarÄ±nÄ± 0 yap */
                lastPoliceIncrementalDamageTime = Date.now();
            }
        }

        function createInitialRoadsideElements(count) {
            for (let i = 0; i < count; i++) {
                const zPos = camera.position.z - 200 - (i * (Math.random() * 50 + 30));

                let roadsideElement;
                let xPos;

                if (Math.random() < 0.5) {
                    xPos = -(roadWidth / 2 + roadsideWidth / 2 + (Math.random() * 5));
                    if (Math.random() < 0.8) {
                        roadsideElement = createTree(xPos, zPos);
                    } else {
                        roadsideElement = createDeer(xPos, zPos);
                    }
                } else {
                    xPos = (roadWidth / 2 + roadsideWidth / 2 + (Math.random() * 5));
                    if (Math.random() < 0.8) {
                        roadsideElement = createSign(xPos, zPos);
                    } else {
                        roadsideElement = createTree(xPos, zPos);
                    }
                }

                roadsideElements.push(roadsideElement);
                scene.add(roadsideElement);
            }

            if (radarPoles.length === 0) {
                createRadarPoleOnce(camera.position.z - 200);
            }
        }

        function updateRoadsideElements() {
            const roadsideSpawnDistance = camera.position.z - 250;
            const roadsideRemovalDistance = camera.position.z + 50;

            let currentSpeedEffectScale = 1.0;
            if (carSpeed > SPEED_EFFECT_THRESHOLD) {
                currentSpeedEffectScale = 1.0 + (carSpeed - SPEED_EFFECT_THRESHOLD) * speedEffectScaleFactor;
            } else {
                currentSpeedEffectScale = 1.0;
            }

            for (let i = roadsideElements.length - 1; i >= 0; i--) {
                const element = roadsideElements[i];
                element.position.z += roadSpeed + (carSpeed / 100);

                element.scale.z = currentSpeedEffectScale;

                if (element.position.z > roadsideRemovalDistance) {
                    let newZPos = roadsideSpawnDistance - (Math.random() * 100);

                    let overlap = true;
                    let attempts = 0;
                    while (overlap && attempts < 10) {
                        overlap = false;
                        for (const otherElement of roadsideElements.concat(radarPoles)) {
                            if (otherElement !== element &&
                                Math.abs(otherElement.position.x - element.position.x) < 5 && 
                                Math.abs(otherElement.position.z - newZPos) < 20) { 
                                overlap = true;
                                newZPos -= 30; 
                                break;
                            }
                        }
                        attempts++;
                    }

                    let newXPos;
                    scene.remove(element); 
                    if (element.position.x < 0) { 
                        newXPos = -(roadWidth / 2 + roadsideWidth / 2 + (Math.random() * 5));
                        if (Math.random() < 0.8) {
                            roadsideElements[i] = createTree(newXPos, newZPos);
                        } else {
                            roadsideElements[i] = createDeer(newXPos, newZPos);
                        }
                    } else { 
                        newXPos = (roadWidth / 2 + roadsideWidth / 2 + (Math.random() * 5));
                        if (Math.random() < 0.8) {
                            roadsideElements[i] = createSign(newXPos, newZPos);
                        } else {
                            roadsideElements[i] = createTree(newXPos, newZPos);
                        }
                    }
                    scene.add(roadsideElements[i]); 
                    roadsideElements[i].scale.set(1,1,1); 
                }
            }

            for (let i = radarPoles.length - 1; i >= 0; i--) {
                const radar = radarPoles[i];
                radar.position.z += roadSpeed + (carSpeed / 100);
                radar.scale.z = currentSpeedEffectScale;

                if (radar.position.z > roadsideRemovalDistance) {
                    scene.remove(radar);
                    radarPoles.splice(i, 1);
                    nextRadarSpawnDistance = distance + 5000; 
                }
            }
            
            if (distance >= nextRadarSpawnDistance && radarPoles.length === 0) {
                 createRadarPoleOnce(camera.position.z - 250);
            }
        }


        function updatePowerUps() {
            const powerUpSpawnDistance = camera.position.z - 150; 
            const powerUpRemovalDistance = camera.position.z + 20; 
            const minSpawnInterval = 7000; 
            const maxSpawnInterval = 15000; 

            for (let i = powerUps.length - 1; i >= 0; i--) {
                const powerUp = powerUps[i];
                if (!powerUp) continue; 

                powerUp.position.z += roadSpeed + (carSpeed / 100);

                powerUp.rotation.y += powerUp.userData.rotationSpeed;

                powerUp.position.y = powerUp.userData.initialY + Math.sin(Date.now() * powerUp.userData.bobbingSpeed * 0.005) * 0.2;

                if (powerUp.position.z > powerUpRemovalDistance) {
                    scene.remove(powerUp);
                    powerUps.splice(i, 1);
                }
            }

            const currentTime = Date.now();
            if (currentTime - lastPowerUpSpawnTime > (minSpawnInterval + Math.random() * (maxSpawnInterval - minSpawnInterval))) {
                const lane = lanes[Math.floor(Math.random() * lanes.length)];
                const zPos = camera.position.z - 200; 

                let overlap = false;
                const minDistanceBetweenPowerUps = 20; 
                for (const existingPowerUp of powerUps) {
                    if (Math.abs(existingPowerUp.position.x - lane) < laneWidth / 2 &&
                        Math.abs(existingPowerUp.position.z - zPos) < minDistanceBetweenPowerUps) {
                        overlap = true;
                        break;
                    }
                }
                for (const existingTrafficCar of trafficCars) { 
                    if (Math.abs(existingTrafficCar.position.x - lane) < laneWidth / 2 &&
                        Math.abs(existingTrafficCar.position.z - zPos) < (existingTrafficCar.userData.length / 2 + 5)) {
                        overlap = true;
                        break;
                    }
                }

                if (!overlap) {
                    const newPowerUp = createPowerUp(lane, zPos);
                    scene.add(newPowerUp);
                    powerUps.push(newPowerUp);
                    lastPowerUpSpawnTime = currentTime;
                }
            }
        }

        function fireRocket() {
            if (rockets <= 0) {
                console.log("Roket ateÅŸlenemedi: Yeterli roket yok. Mevcut roket: " + rockets);
                return;
            }
            if (Date.now() - lastRocketFireTime < rocketCooldown) {
                console.log("Roket ateÅŸlenemedi: Bekleme sÃ¼resi dolmadÄ±. Kalan sÃ¼re: " + (rocketCooldown - (Date.now() - lastRocketFireTime)) + "ms");
                return;
            }

            lastRocketFireTime = Date.now();
            rockets--; 
            document.getElementById('rocketsDisplay').textContent = rockets; 

            rocketsFiredCount++; 
            console.log(`Roket atÄ±ldÄ±: ${rocketsFiredCount}. Kalan roket: ${rockets}`);

            // Yeni FÃ¼ze Modeli
            const rocketMesh = new THREE.Group();

            // GÃ¶vde
            const bodyMat = new THREE.MeshStandardMaterial({ color: 0x888888, metalness: 0.8, roughness: 0.4 });
            const bodyGeom = new THREE.CylinderGeometry(0.2, 0.2, 1.8, 12);
            const bodyMesh = new THREE.Mesh(bodyGeom, bodyMat);
            rocketMesh.add(bodyMesh);

            // Sivri KÄ±rmÄ±zÄ± UÃ§
            const noseMat = new THREE.MeshStandardMaterial({ color: 0xFF0000, metalness: 0.5, roughness: 0.5 });
            const noseGeom = new THREE.ConeGeometry(0.2, 0.7, 12);
            const noseMesh = new THREE.Mesh(noseGeom, noseMat);
            noseMesh.position.y = 1.25; // GÃ¶vdenin ucuna
            rocketMesh.add(noseMesh);

            // Alev PartikÃ¼lleri
            const flameMaterial = new THREE.PointsMaterial({
                size: 0.8, // Daha bÃ¼yÃ¼k alev
                map: createFlameTexture(), // Doku ile daha gerÃ§ekÃ§i alev
                vertexColors: false, // Doku rengini kullan
                color: 0xFF8C00, // Turuncu alev
                transparent: true,
                opacity: 0.9,
                blending: THREE.AdditiveBlending,
                sizeAttenuation: true
            });
            const flameGeometry = new THREE.BufferGeometry();
            const flamePositions = new Float32Array(50 * 3);
            flameGeometry.setAttribute('position', new THREE.BufferAttribute(flamePositions, 3));

            const flameParticles = new THREE.Points(flameGeometry, flameMaterial);
            flameParticles.position.y = -1.0; // FÃ¼zenin arkasÄ±na
            rocketMesh.add(flameParticles);
            rocketMesh.userData.flame = flameParticles; // GÃ¼ncelleme iÃ§in referans


            // FÃ¼zenin baÅŸlangÄ±Ã§ pozisyonu ve yÃ¶nÃ¼
            rocketMesh.rotation.x = Math.PI / 2; // Yola yatay hale getir
            rocketMesh.position.copy(car.position);
            rocketMesh.position.y = 0.4; // Yere daha yakÄ±n
            rocketMesh.position.z -= 3.0;

            scene.add(rocketMesh);
            activeRocket = rocketMesh;

            if (powerUpRocketSoundBuffer) {
                playSound(powerUpRocketSoundBuffer, 0.8);
            }
        }

        function createRocketParticle(x, y, z) {
        }

        function updateRocket() {
            if (!activeRocket) return;

            activeRocket.position.z -= rocketBaseSpeed * 2;
            activeRocket.rotation.y += 0.2;

            // Alev animasyonu
            const flame = activeRocket.userData.flame;
            if (flame) {
                const positions = flame.geometry.attributes.position.array;
                for (let i = 0; i < positions.length / 3; i++) {
                    positions[i * 3 + 0] += (Math.random() - 0.5) * 0.1; // X yayÄ±lÄ±mÄ±
                    positions[i * 3 + 1] += (Math.random() - 0.5) * 0.1; // Y yayÄ±lÄ±mÄ± (fÃ¼zenin yerel Z'si)
                    positions[i * 3 + 2] -= Math.random() * 0.2; // Geriye doÄŸru uzama (fÃ¼zenin yerel Y'si)

                    // PartikÃ¼l Ã¶mrÃ¼ dolunca sÄ±fÄ±rla
                    if (positions[i * 3 + 2] < -2.5) {
                        positions[i * 3 + 0] = (Math.random() - 0.5) * 0.05;
                        positions[i * 3 + 1] = (Math.random() - 0.5) * 0.05;
                        positions[i * 3 + 2] = 0;
                    }
                }
                flame.geometry.attributes.position.needsUpdate = true;
                flame.material.opacity = Math.max(0, flame.material.opacity - 0.01);
            }


            const rocketBox = new THREE.Box3().setFromObject(activeRocket);

            for (let i = trafficCars.length - 1; i >= 0; i--) {
                const trafficCar = trafficCars[i];
                if (!trafficCar || !trafficCar.visible || trafficCar.userData.isPolice) continue; 

                trafficBox.setFromObject(trafficCar);

                if (rocketBox.intersectsBox(trafficBox)) {
                    createExplosion(trafficCar.position.x, trafficCar.position.y + 1, trafficCar.position.z); 
                    
                    if (trafficCar.userData.isPooled) {
                        releasePooledTrafficCar(trafficCar);
                        const index = trafficCars.indexOf(trafficCar);
                        if (index > -1) trafficCars.splice(index, 1);
                    } else { 
                        scene.remove(trafficCar);
                        const index = trafficCars.indexOf(trafficCar);
                        if (index > -1) trafficCars.splice(index, 1);
                    }

                    trafficCarsDestroyedByRocket++;
                    addScore(500); 
                    showScoreFeedback('ROKET Ä°SABETÄ°! +500', '#FF8C00'); 
                    
                    scene.remove(activeRocket);
                    activeRocket = null;
                    return; 
                }
            }

            if (activeRocket.position.z < camera.position.z - 300) { 
                scene.remove(activeRocket);
                activeRocket = null;
            }
        }

        function takeDamage(amount) {
            health -= amount;
            health = Math.max(0, health);
            updateHealthBar();
            if (health <= 0) {
                gameOver();
            }
        }

        function updateHealthBar() {
            const healthFillElement = document.getElementById('healthFill');
            const fillHeight = (health / maxHealth) * 100;
            const hue = (health / maxHealth) * 120;
            healthFillElement.style.height = `${fillHeight}%`;
            healthFillElement.style.background = `hsl(${hue}, 100%, 40%)`;
        }

        function checkCollisions() {
            if (!car || !gameRunning) return;
            const currentTime = Date.now();
            if (currentTime - lastCollisionTime < collisionCooldown) return;

            const p = {
                front: car.position.z - (playerCarLength / 2),
                rear: car.position.z + (playerCarLength / 2),
                left: car.position.x - (playerCarWidth / 2),
                right: car.position.x + (playerCarWidth / 2)
            };

            // 1. Bariyerlerle Ã‡arpÄ±ÅŸma KontrolÃ¼
            const leftBarrierX = -roadWidth / 2;
            const rightBarrierX = roadWidth / 2;
            if (p.right > rightBarrierX || p.left < leftBarrierX) {
                lastCollisionTime = currentTime;
                triggerCollisionShake(0.5, 30);
                takeDamage(10);
                carSpeed *= 0.8;
                car.position.x = Math.max(leftBarrierX + (playerCarWidth / 2), Math.min(rightBarrierX - (playerCarWidth / 2), car.position.x));
                return; // Bariyerle Ã§arpÄ±ÅŸma olduysa baÅŸka kontrol yapma
            }

            // 2. Trafik AraÃ§larÄ±yla Ã‡arpÄ±ÅŸma KontrolÃ¼
            for (let i = trafficCars.length - 1; i >= 0; i--) {
                const trafficCar = trafficCars[i];
                if (!trafficCar || !trafficCar.visible) continue;

                const t = {
                    front: trafficCar.position.z - (trafficCar.userData.length / 2),
                    rear: trafficCar.position.z + (trafficCar.userData.length / 2),
                    left: trafficCar.position.x - (trafficCar.userData.width / 2),
                    right: trafficCar.position.x + (trafficCar.userData.width / 2)
                };

                if (p.right > t.left && p.left < t.right && p.rear > t.front && p.front < t.rear) {
                    lastCollisionTime = currentTime;
                    
                    if (trafficCar.userData.isPolice && trafficCar.userData.isAggressiveRammer) {
                        createExplosion(trafficCar.position.x, trafficCar.position.y + 1, trafficCar.position.z);
                        if (activePoliceCar && activePoliceCar.userData.sirenSound) activePoliceCar.userData.sirenSound.stop();
                        releasePooledPoliceCar(trafficCar);
                        activePoliceCar = null;
                        trafficCars.splice(i, 1);
                        takeDamage(35);
                        triggerCollisionShake(0.8, 40);
                        continue; 
                    }

                    const relativeSpeed = carSpeed - (trafficCar.userData.speed || 0);
                    const isRearEnd = (p.front < t.rear) && relativeSpeed > 10;
                    takeDamage(isRearEnd ? 30 : 10);
                    triggerCollisionShake(isRearEnd ? 0.7 : 0.4, 30);
                    carSpeed *= 0.5;

                    const overlapX = Math.min(p.right, t.right) - Math.max(p.left, t.left);
                    const overlapZ = Math.min(p.rear, t.rear) - Math.max(p.front, t.front);
                    if (overlapX < overlapZ) car.position.x += (p.left < t.left ? -overlapX : overlapX) * 0.5;
                    else car.position.z += (p.front < t.front ? -overlapZ : overlapZ) * 0.5;
                }
            }
            
            // 3. GÃ¼Ã§lendirmeleri Toplama (DÃ–NGÃœNÃœN DIÅINDA)
            carBox.setFromObject(car); // Box3'Ã¼ burada bir kez ayarla
            for (let i = powerUps.length - 1; i >= 0; i--) {
                const powerUp = powerUps[i];
                if (!powerUp) continue;
                powerUpBox.setFromObject(powerUp);
                if (carBox.intersectsBox(powerUpBox)) {
                    const type = powerUp.userData.type;
                    if (type === 'rocket') {
                        rockets += 2;
                        document.getElementById('rocketsDisplay').textContent = rockets;
                        showScoreFeedback('ROKET ALINDI! +2', '#FFD700');
                        if(powerUpRocketSoundBuffer) playSound(powerUpRocketSoundBuffer, 0.7);
                    } else if (type === 'health') {
                        health = Math.min(maxHealth, health + 25);
                        updateHealthBar();
                        showScoreFeedback('CAN ALINDI! +25', '#00FF7F');
                        if(powerUpHealthSoundBuffer) playSound(powerUpHealthSoundBuffer, 0.7);
                    } else if (type === 'shield') {
                        activateShield();
                        showScoreFeedback('KALKAN ALINDI!', '#00BFFF');
                        if(powerUpShieldSoundBuffer) playSound(powerUpShieldSoundBuffer, 0.7);
                    }
                    scene.remove(powerUp);
                    powerUps.splice(i, 1);
                }
            }
        }


        function updateDayNightCycle() {
            const distancePassed = distance - previousDistanceForTime;
            timeOfDay = (timeOfDay + (distancePassed / dayDurationInGameMeters) * 24) % 24;
            previousDistanceForTime = distance;

            let ambientColor, directionalColor, fogColor, skyColor;
            let directionalIntensity, ambientIntensity;
            let fogNear, fogFar;
            let timeOfDayText = '';
            let timeOfDayEmoji = '';
            let scoreMultiplier = 1.0;
            let roadLineEmissiveIntensity;
            let barrierStripeEmissiveIntensity;
            let playerHeadlightIntensityValue = 0; 
            let trafficLightEmissiveIntensity = 0;
            let sunOpacity = 0, moonOpacity = 0, starsOpacity = 0;
            let sunLightIntensity = 0;

            const currentHour = Math.floor(timeOfDay);
            const currentMinute = Math.floor((timeOfDay - currentHour) * 60);

            if (timeOfDay >= 6 && timeOfDay < 18) { 
                const progress = (timeOfDay - 6) / 12;
                skyColor = new THREE.Color().lerpColors(new THREE.Color(0x1e3c72), new THREE.Color(0x2a5298), progress); // Koyu mavi gÃ¶kyÃ¼zÃ¼
                ambientColor = new THREE.Color().lerpColors(new THREE.Color(0x6060A0), new THREE.Color(0xAAAAFF), progress);
                directionalColor = new THREE.Color().lerpColors(new THREE.Color(0xFFCC88), new THREE.Color(0xFFFFFF), progress);
                directionalIntensity = THREE.MathUtils.lerp(0.8, 1.2, progress);
                ambientIntensity = THREE.MathUtils.lerp(0.5, 0.8, progress);
                fogColor = new THREE.Color().lerpColors(new THREE.Color(0x87CEEB), new THREE.Color(0xB0C4DE), progress); // Sis rengi gÃ¶kyÃ¼zÃ¼nden farklÄ±
                fogNear = 100; fogFar = 500;
                timeOfDayText = 'GÃ¼ndÃ¼z'; timeOfDayEmoji = 'â˜€ï¸'; scoreMultiplier = 1.0;
                roadLineEmissiveIntensity = 0.2; barrierStripeEmissiveIntensity = 0.3;
                playerHeadlightIntensityValue = 0; trafficLightEmissiveIntensity = 0;
                sunOpacity = Math.min(1, ((timeOfDay - 6)/2), (18-timeOfDay)/2); // Sabah ve akÅŸam yavaÅŸÃ§a belir/kaybol
                moonOpacity = 0;
                starsOpacity = 0;
                sunLightIntensity = sunOpacity * 1.2;
            } else if (timeOfDay >= 18 && timeOfDay < 20) { 
                const progress = (timeOfDay - 18) / 2;
                skyColor = new THREE.Color().lerpColors(new THREE.Color(0x2a5298), new THREE.Color(0x191970), progress); // Koyu maviden gece mavisine
                ambientColor = new THREE.Color().lerpColors(new THREE.Color(0xAAAAFF), new THREE.Color(0x303060), progress);
                directionalColor = new THREE.Color().lerpColors(new THREE.Color(0xFFFFFF), new THREE.Color(0xFF8C00), progress);
                directionalIntensity = THREE.MathUtils.lerp(1.2, 0.5, progress);
                ambientIntensity = THREE.MathUtils.lerp(0.8, 0.3, progress);
                fogColor = new THREE.Color().lerpColors(new THREE.Color(0xB0C4DE), new THREE.Color(0x606070), progress); // Sis rengi
                fogNear = 80; fogFar = 400;
                timeOfDayText = 'AkÅŸam'; timeOfDayEmoji = 'ğŸŒ‡'; scoreMultiplier = 1.2;
                roadLineEmissiveIntensity = THREE.MathUtils.lerp(0.2, 1.5, progress);
                barrierStripeEmissiveIntensity = THREE.MathUtils.lerp(0.3, 2.5, progress);
                playerHeadlightIntensityValue = THREE.MathUtils.lerp(0, 0.8, progress);
                trafficLightEmissiveIntensity = THREE.MathUtils.lerp(0, 1.5, progress);
                sunOpacity = 1 - progress;
                moonOpacity = progress;
                starsOpacity = progress;
                sunLightIntensity = sunOpacity * 1.2;
            } else if (timeOfDay >= 20 || timeOfDay < 4) { 
                const progress = (timeOfDay >= 20 ? (timeOfDay - 20) : (timeOfDay + 4)) / 8; 
                skyColor = new THREE.Color().lerpColors(new THREE.Color(0x191970), new THREE.Color(0x000000), progress); // Gece mavisi siyaha
                ambientColor = new THREE.Color().lerpColors(new THREE.Color(0x303060), new THREE.Color(0x101030), progress);
                directionalColor = new THREE.Color().lerpColors(new THREE.Color(0xFF8C00), new THREE.Color(0x050505), progress);
                directionalIntensity = THREE.MathUtils.lerp(0.5, 0.1, progress);
                ambientIntensity = THREE.MathUtils.lerp(0.3, 0.1, progress);
                fogColor = new THREE.Color().lerpColors(new THREE.Color(0x606070), new THREE.Color(0x101015), progress); // Gece sisi
                fogNear = 20; fogFar = 200;
                timeOfDayText = 'Gece'; timeOfDayEmoji = 'ğŸŒ™'; scoreMultiplier = 1.5;
                roadLineEmissiveIntensity = 1.8; barrierStripeEmissiveIntensity = 3.0;
                playerHeadlightIntensityValue = 1.0; trafficLightEmissiveIntensity = 1.5;
                sunOpacity = 0;
                moonOpacity = 1;
                starsOpacity = 1;
                sunLightIntensity = 0;
            } else { 
                const progress = (timeOfDay - 4) / 2;
                skyColor = new THREE.Color().lerpColors(new THREE.Color(0x000000), new THREE.Color(0x1e3c72), progress); // Siyahtan koyu maviye
                ambientColor = new THREE.Color().lerpColors(new THREE.Color(0x101030), new THREE.Color(0x6060A0), progress);
                directionalColor = new THREE.Color().lerpColors(new THREE.Color(0x050505), new THREE.Color(0xFFCC88), progress);
                directionalIntensity = THREE.MathUtils.lerp(0.1, 0.8, progress);
                ambientIntensity = THREE.MathUtils.lerp(0.1, 0.5, progress);
                fogColor = new THREE.Color().lerpColors(new THREE.Color(0x101015), new THREE.Color(0x87CEEB), progress); // Åafak sisi
                fogNear = 50; fogFar = 300;
                timeOfDayText = 'Åafak'; timeOfDayEmoji = 'ğŸŒ…'; scoreMultiplier = 1.2;
                roadLineEmissiveIntensity = THREE.MathUtils.lerp(1.8, 0.2, progress);
                barrierStripeEmissiveIntensity = THREE.MathUtils.lerp(3.0, 0.3, progress);
                playerHeadlightIntensityValue = THREE.MathUtils.lerp(1.0, 0, progress);
                trafficLightEmissiveIntensity = THREE.MathUtils.lerp(1.5, 0, progress);
                sunOpacity = progress;
                moonOpacity = 1 - progress;
                starsOpacity = 1 - progress;
                sunLightIntensity = sunOpacity * 1.2;
            }

            // DaÄŸlarÄ±n rengini sise gÃ¶re ayarla
            mountains.forEach(mountain => {
                if (mountain && mountain.children[0] && mountain.children[0].material) {
                    const baseMountainColor = new THREE.Color(0x6B8E23); // Orijinal renk
                    mountain.children[0].material.color.copy(baseMountainColor).lerp(fogColor, 0.4);
                    // AÄŸaÃ§larÄ±n rengini de ayarla
                    for(let i=1; i<mountain.children.length; i++) {
                        const baseTreeColor = new THREE.Color(0x006400);
                        mountain.children[i].material.color.copy(baseTreeColor).lerp(fogColor, 0.5);
                    }
                }
            });

            if (sun && moon && starField) {
                sun.material.opacity = sunOpacity;
                if (sunLight) sunLight.intensity = sunLightIntensity;
                moon.material.opacity = moonOpacity;
                starField.material.opacity = starsOpacity;
            }

            scene.children.forEach(obj => {
                if (obj instanceof THREE.AmbientLight) {
                    obj.color.copy(ambientColor);
                    obj.intensity = ambientIntensity;
                }
                if (obj instanceof THREE.DirectionalLight) {
                    obj.color.copy(directionalColor);
                    obj.intensity = directionalIntensity;
                    const angle = (timeOfDay / 24) * Math.PI * 2 - Math.PI/2; 
                    obj.position.set(Math.cos(angle) * 30, Math.sin(angle) * 20 + 15, 10); 
                }
            });

            if (skyDome && skyDome.material) {
                skyDome.material.color.set(fogColor);
            }

            renderer.setClearColor(fogColor);
            scene.fog.color.set(fogColor);
            scene.fog.near = fogNear;
            scene.fog.far = fogFar;

            car.traverse((object) => {
                if (object.material && object.userData.isLight) {
                    if (object.material instanceof THREE.MeshStandardMaterial || object.material instanceof THREE.MeshPhongMaterial) {
                        if (object.material.color.getHexString() === 'ffff88') { 
                            object.material.emissive.set(0xAAAA00);
                            object.material.emissiveIntensity = playerHeadlightIntensityValue;
                        }
                        else if (object.material.color.getHexString() === '8b0000') { 
                            object.material.emissive.set(0xFF0000); 
                            object.material.emissiveIntensity = 5.0; 
                        }
                        object.material.needsUpdate = true;
                    }
                }
            });

             trafficCars.forEach(tc => { 
                if (tc.userData.isPolice) {
                } else {
                    tc.traverse((object) => {
                        if (object.material && object.userData.isLight) {
                            if (object.material instanceof THREE.MeshStandardMaterial || object.material instanceof THREE.MeshPhongMaterial) {
                                if (object.material.color.getHexString() === 'ffff88') { 
                                    object.material.emissive.set(0xCCCC00);
                                    object.material.emissiveIntensity = trafficLightEmissiveIntensity;
                                }
                                else if (object.material.color.getHexString() === 'ff0000') { 
                                    object.material.emissive.set(0xAA0000);
                                    object.material.emissiveIntensity = trafficLightEmissiveIntensity;
                                }
                                object.material.needsUpdate = true;
                            }
                        }
                    });
                }
            });


            road.forEach(obj => {
                if (obj.userData.isRoadLine && obj.material instanceof THREE.MeshPhongMaterial) {
                    obj.material.emissiveIntensity = roadLineEmissiveIntensity;
                    obj.material.needsUpdate = true;
                }
            });

            barriers.forEach(obj => {
                if (obj.userData.isBarrierStripe && obj.material instanceof THREE.MeshPhongMaterial) {
                    obj.material.emissiveIntensity = barrierStripeEmissiveIntensity;
                    obj.material.needsUpdate = true;
                }
            });

            if (playerHeadlight) { 
                    playerHeadlight.intensity = playerHeadlightIntensityValue;
            }

            document.getElementById('timeOfDayDisplay').textContent = `${String(currentHour).padStart(2, '0')}:${String(currentMinute).padStart(2, '0')}`;
            document.getElementById('timeOfDayInfo').innerHTML = `${timeOfDayEmoji} ${timeOfDayText}: <span id="timeOfDayDisplay">${String(currentHour).padStart(2, '0')}:${String(currentMinute).padStart(2, '0')}</span>`;

            return scoreMultiplier;
        }


        function updateScoreAndLevel() {
            distance += carSpeed / 100;

            const currentScoreMultiplier = updateDayNightCycle();

            addScore(Math.floor(carSpeed / 50), currentScoreMultiplier);

            const newLevel = Math.floor(distance / 1000) + 1;
            if (newLevel > level) {
                level = newLevel;
                document.getElementById('level').textContent = level;
                baseTrafficSpeed += 0.02;
                maxSpeed += 10;
                policeDifficultyMultiplier += 0.1;
                showScoreFeedback(`SEVÄ°YE ${level}!`, '#FFA500');
            }

            document.getElementById('distance').textContent = Math.floor(distance);
            document.getElementById('scoreDisplay').textContent = score;
            document.getElementById('comboDisplay').textContent = combo;

            // Yeni hÄ±z gÃ¶stergesi
            if (newSpeedValueElement) {
                const speedValue = Math.floor(carSpeed);
                newSpeedValueElement.textContent = speedValue;

                let color = '#4CAF50'; // YeÅŸil (dÃ¼ÅŸÃ¼k hÄ±z)
                if (speedValue > 180) {
                    color = '#FF4500'; // KÄ±rmÄ±zÄ± (yÃ¼ksek hÄ±z)
                } else if (speedValue > 100) {
                    color = '#FFD700'; // SarÄ± (orta hÄ±z)
                }
                newSpeedValueElement.style.color = color;
            }

            /* Kokpit hÄ±z gÃ¶stergesi gÃ¼ncellemesi ve renk kodlamasÄ± */
            if (currentSpeedGauge) { 
                const speedValue = Math.floor(carSpeed);
                currentSpeedGauge.textContent = speedValue; 
                let color = '#00FF00'; 

                if (speedValue >= 0 && speedValue <= 90) {
                    color = '#00FF00'; 
                } else if (speedValue > 90 && speedValue <= 150) {
                    color = '#FFA500'; 
                } else { 
                    color = '#FF0000'; 
                }
                currentSpeedGauge.style.color = color; 
                
                if (gaugeRing) { 
                     gaugeRing.style.borderColor = color;
                }
            }

            if (combo > 0 && Date.now() - lastComboTime > 3000) combo = 0;
            if (combo > highCombo) highCombo = combo;

            trafficCars.forEach(trafficCar => {
                if (!trafficCar.userData.isPolice && trafficCar.visible) {
                    const distanceToTrafficCarZ = Math.abs(car.position.z - trafficCar.position.z);
                    const distanceToTrafficCarX = Math.abs(car.position.x - trafficCar.position.x);
                    const carHalfWidth = 1.3; 
                    const trafficCarHalfWidth = (trafficCar.userData.type === 'truck' || trafficCar.userData.type === 'bus' ? 1.4 : 1.0); 

                    if (distanceToTrafficCarZ < (5.0/2 + trafficCar.userData.length/2) && 
                        distanceToTrafficCarX < (carHalfWidth + trafficCarHalfWidth + 0.3) && 
                        distanceToTrafficCarX > (carHalfWidth + trafficCarHalfWidth - 0.5) && 
                        Math.sign(carSpeed) === Math.sign(baseTrafficSpeed) && carSpeed > 30) { 
                        
                        if (!trafficCar.userData.nearMissAwarded) { 
                            showCombo('YAKIN GEÃ‡Ä°Å!', 100);
                            trafficCar.userData.nearMissAwarded = true; 
                            setTimeout(() => { 
                                if(trafficCar.userData) trafficCar.userData.nearMissAwarded = false;
                            }, 2000); 
                        }
                    }
                }
            });

        }

        function addScore(points, multiplier = 1.0) {
            const comboMultiplier = 1 + (combo * 0.1);
            const totalPoints = Math.floor(points * comboMultiplier * multiplier);
            score += totalPoints;

            if (totalPoints > 50) {
                showScoreFeedback(`+${totalPoints}`, '#00FF00');
            }

            if (points > 20 && totalPoints > 0) { 
                combo++;
                lastComboTime = Date.now();
                if (combo % 5 === 0 && combo > 0) { 
                    showCombo(`${combo}X KOMBO!`, 100 + (combo * 10));
                }
            }
        }

        function showCombo(text, bonus) {
            const comboText = document.getElementById('comboText');
            comboText.textContent = `ğŸ’¥ ${text} ğŸ’¥`;
            comboText.style.display = 'block';
            comboText.style.animation = 'none';
            void comboText.offsetWidth;
            comboText.style.animation = 'comboAnim 1.5s cubic-bezier(0.25, 0.46, 0.45, 0.94) forwards';

            if (bonus) addScore(bonus, 1.0);
        }

        function showScoreFeedback(text, color) {
            const feedback = document.getElementById('scoreFeedback');
            let emoji = '';
            if (text.includes('+')) emoji = 'âœ…'; 
            else if (text.includes('SEVÄ°YE')) emoji = 'ğŸŒŸ'; 
            else if (text.includes('POLÄ°S')) emoji = 'ğŸš¨';
            else if (text.includes('RADAR')) emoji = 'ğŸ“¡';
            else if (text.includes('ROKET')) emoji = 'ğŸš€';

            feedback.textContent = `${emoji} ${text}`;
            feedback.style.color = color;
            feedback.style.textShadow = `0 0 5px ${color}80, 0 0 10px ${color}50`;
            feedback.style.animation = 'none';
            void feedback.offsetWidth;
            feedback.style.animation = 'scoreFeedbackAnim 1.0s ease-out forwards';
        }

        function checkRadar() {
            const radarDetectionRange = 10;
            const speedingThreshold = 120;

            radarPoles.forEach(radar => {
                if (!radar) return; 
                const distanceToRadar = car.position.z - radar.position.z;
                const radarX = radar.position.x;
                const carX = car.position.x;
                const currentSpeedKmH = Math.floor(carSpeed);

                if (distanceToRadar > -radarDetectionRange && distanceToRadar < radarDetectionRange &&
                    Math.abs(carX - radarX) < (roadsideWidth / 2 + 1) && 
                    currentSpeedKmH > speedingThreshold &&
                    (Date.now() - (radar.userData.lastHit || 0) > radar.userData.hitCooldown)) { 

                    const deductionAmount = Math.floor(score * 0.33); 
                    score = Math.max(0, score - deductionAmount);
                    document.getElementById('scoreDisplay').textContent = score;
                    showScoreFeedback(`RADAR CEZASI! -${deductionAmount}`, '#FF6347'); 
                    showSpeedingMessage(); 
                    
                    radar.userData.lastHit = Date.now();
                }
            });
        }


        function showSpeedingMessage() {
            const messageDiv = document.createElement('div');
            messageDiv.textContent = 'ğŸš¨ RADARA YAKALANDIN! ğŸš¨';
            messageDiv.style.cssText = `
                position: absolute;
                top: 25%;
                left: 50%;
                transform: translate(-50%, -50%);
                background: rgba(255, 0, 0, 0.8);
                color: white;
                padding: 20px 30px;
                border-radius: 10px;
                font-size: 32px;
                font-weight: bold;
                text-shadow: 2px 2px 5px rgba(0,0,0,0.7);
                z-index: 250;
                animation: fadeOut 2s forwards;
            `;
            document.body.appendChild(messageDiv);
            setTimeout(() => { messageDiv.remove(); }, 2000);
        }

        function createSkyDome() {
            const skyGeometry = new THREE.SphereGeometry(700, 32, 15); 
            const skyMaterial = new THREE.MeshBasicMaterial({
                color: 0x87CEEB, 
                side: THREE.BackSide,
                fog: false 
            });
            skyDome = new THREE.Mesh(skyGeometry, skyMaterial);
            scene.add(skyDome);
        }

        function createMountains() {
            const mountainMaterial = new THREE.MeshStandardMaterial({
                color: 0x6B8E23, 
                roughness: 0.9,
                metalness: 0.0
            });
            const peakMaterial = new THREE.MeshStandardMaterial({
                color: 0xA9A9A9, 
                roughness: 0.7,
                metalness: 0.1
            });

            const numMountains = 10; 
            const mountainBaseZ = -700; 
            const mountainSpacing = 200; 

            for (let i = 0; i < numMountains; i++) {
                const mountainGroup = new THREE.Group();
                const baseHeight = Math.random() * 50 + 70; 
                const baseWidth = Math.random() * 80 + 120; 

                const mountainGeometry = new THREE.ConeGeometry(baseWidth / 2, baseHeight, Math.floor(Math.random()*3)+5); 
                const mountainBody = new THREE.Mesh(mountainGeometry, mountainMaterial);
                mountainBody.position.y = baseHeight / 2 - 10; 
                mountainBody.castShadow = true;
                mountainGroup.add(mountainBody);

                const numPeaks = Math.floor(Math.random() * 2) + 1; 
                for (let j = 0; j < numPeaks; j++) {
                    if (Math.random() < 0.7) { 
                        const peakHeight = Math.random() * 20 + 20;
                        const peakWidth = Math.random() * 20 + 15;
                        const peakGeometry = new THREE.ConeGeometry(peakWidth / 2, peakHeight, 5);
                        const peak = new THREE.Mesh(peakGeometry, peakMaterial);
                        peak.position.set(
                            (Math.random() - 0.5) * (baseWidth * 0.3),
                            baseHeight + (peakHeight / 2) - 15, 
                            (Math.random() - 0.5) * (baseWidth * 0.15)
                        );
                        mountainBody.add(peak);
                    }
                }

                const xPos = (i % 2 === 0 ? -1 : 1) * (roadWidth / 2 + roadsideWidth + 80 + Math.random() * 100); 
                const zPos = camera.position.z + mountainBaseZ - (i * mountainSpacing) - (Math.random() * mountainSpacing / 2);

                mountainGroup.position.set(xPos, 0, zPos);
                addTreesToMountain(mountainGroup, baseWidth, baseHeight);
                scene.add(mountainGroup);
                mountains.push(mountainGroup);
            }
        }

        function addTreesToMountain(mountainGroup, mountainWidth, mountainHeight) {
            const numTrees = 15;
            const treeMaterial = new THREE.MeshLambertMaterial({ color: 0x006400 }); // Basit aÄŸaÃ§ rengi
            for(let i=0; i<numTrees; i++) {
                const treeHeight = Math.random() * 8 + 5;
                const treeRadius = treeHeight / 4;
                const treeGeometry = new THREE.ConeGeometry(treeRadius, treeHeight, 5);
                const tree = new THREE.Mesh(treeGeometry, treeMaterial);

                const angle = Math.random() * Math.PI * 2;
                const radius = (Math.random() * 0.4 + 0.1) * mountainWidth; // daÄŸÄ±n %10 ila %50 yarÄ±Ã§apÄ± arasÄ±na
                const x = Math.cos(angle) * radius;
                const z = Math.sin(angle) * radius;
                
                // YÃ¼ksekliÄŸi daÄŸÄ±n eÄŸimine gÃ¶re ayarla (basit bir yaklaÅŸÄ±m)
                const y = (1 - (radius / (mountainWidth*0.5))) * (mountainHeight * 0.4);

                tree.position.set(x, y, z);
                tree.rotation.y = Math.random() * Math.PI;
                mountainGroup.add(tree);
            }
        }

        function updateMountains() {
            const mountainRemovalDistance = camera.position.z + 100; 
            const mountainSpawnBehindDistance = mountains.length * 200; 

            mountains.forEach(mountain => {
                if (!mountain) return; 
                mountain.position.z += roadSpeed + (carSpeed / 100); 

                if (mountain.position.z > mountainRemovalDistance) {
                    mountain.position.z -= mountainSpawnBehindDistance + Math.random() * 50;
                    mountain.position.x = (Math.random() < 0.5 ? -1 : 1) * (roadWidth / 2 + roadsideWidth + 80 + Math.random() * 100);
                }
            });
        }

        function createCelestialBodies() {
            // GÃ¼neÅŸ
            const sunGeometry = new THREE.SphereGeometry(25, 32, 32); // Boyut bÃ¼yÃ¼tÃ¼ldÃ¼
            const sunMaterial = new THREE.MeshBasicMaterial({ 
                color: 0xFFD700, 
                transparent: true, 
                opacity: 0, 
                fog: false // Sis'ten etkilenmesin
            });
            sun = new THREE.Mesh(sunGeometry, sunMaterial);
            sun.position.set(0, 100, -500); // Kamera'ya gÃ¶re konum

            // GÃ¼neÅŸ IÅŸÄ±ÄŸÄ±
            sunLight = new THREE.PointLight(0xFFD700, 0, 1000, 2);
            sun.add(sunLight);

            camera.add(sun); // GÃ¼neÅŸi kameraya ekle
        }

        function update() {
            if (gameRunning) {
                updateCarPosition();
                updateTraffic();
                updateRoad();
                updateRoadsideElements();
                checkCollisions();
                updateScoreAndLevel();
                checkRadar();
                updatePowerUps();
                updateRocket();
                updatePoliceWarnings(); // YENÄ° FONKSÄ°YON Ã‡AÄRISI

                if (engineGainNode && audioContext && engineBuffer) {
                    const minSpeed = 0; const maxSpeedForSound = maxSpeed;
                    const minVolume = 0.5; const maxVolume = 1.0;
                    const minPlaybackRate = 0.8; const maxPlaybackRate = 1.5;

                    engineGainNode.gain.setValueAtTime(THREE.MathUtils.mapLinear(carSpeed, minSpeed, maxSpeedForSound, minVolume, maxVolume), audioContext.currentTime);
                    if(engineSource.playbackRate) 
                       engineSource.playbackRate.setValueAtTime(THREE.MathUtils.mapLinear(carSpeed, minSpeed, maxSpeedForSound, minPlaybackRate, maxPlaybackRate), audioContext.currentTime);
                }

                const baseCameraFollowY = 9;  
                const baseCameraFollowZ = 14; 
                let dynamicFollowZOffset = 0;
                if (carSpeed > SPEED_EFFECT_THRESHOLD * 0.6) { 
                    dynamicFollowZOffset = THREE.MathUtils.mapLinear(carSpeed, SPEED_EFFECT_THRESHOLD * 0.6, maxSpeed, 0, 5); 
                }
                
                let dynamicFollowXOffset = 0;
                const maxTiltCameraShift = 2.5; 
                if (Math.abs(carTilt) > maxCarTilt * 0.2) { 
                    dynamicFollowXOffset = -carTilt * (maxTiltCameraShift / maxCarTilt) * 2; 
                }

                const cameraFollowX = (car.position.x * 0.15) + dynamicFollowXOffset; 
                
                const cameraFollowY = baseCameraFollowY; 
                const cameraFollowZ = baseCameraFollowZ + dynamicFollowZOffset;
                const lerpFactor = 0.04; 

                camera.position.x = THREE.MathUtils.lerp(camera.position.x, cameraFollowX, lerpFactor);
                camera.position.y = THREE.MathUtils.lerp(camera.position.y, cameraFollowY, lerpFactor);
                camera.position.z = THREE.MathUtils.lerp(camera.position.z, cameraFollowZ, lerpFactor);

                const targetLookAtX = car.position.x * 0.05; 
                
                const targetLookAtY = 2; 
                const targetLookAtZ = -5;  
                let currentLookAtTarget = new THREE.Vector3();
                camera.getWorldDirection(currentLookAtTarget); 
                currentLookAtTarget.multiplyScalar(10).add(camera.position); 
                let newLookAtTarget = new THREE.Vector3(targetLookAtX, targetLookAtY, targetLookAtZ);
                currentLookAtTarget.lerp(newLookAtTarget, lerpFactor * 1.5); 
                camera.lookAt(currentLookAtTarget.x, currentLookAtTarget.y, currentLookAtTarget.z);

                if (carSpeed > SPEED_EFFECT_THRESHOLD) {
                    cameraShakeIntensity = THREE.MathUtils.mapLinear(carSpeed, SPEED_EFFECT_THRESHOLD, maxSpeed, 0, maxCameraShakeIntensity * 0.6); 
                } else {
                    cameraShakeIntensity = THREE.MathUtils.lerp(cameraShakeIntensity, 0, 0.1);
                }
                camera.position.y += (Math.sin(Date.now() * 0.015) * cameraShakeIntensity * 0.8); 
                camera.position.x += (Math.cos(Date.now() * 0.018) * cameraShakeIntensity * 0.4); 
                const tiltShakeFactor = 0.005; 
                camera.position.y += Math.abs(carTilt) * tiltShakeFactor;

                // Ã‡arpÄ±ÅŸma bazlÄ± kamera sarsÄ±ntÄ±sÄ±
                if (collisionShakeDuration > 0) {
                    const shakeFade = collisionShakeDuration / 20; // SarsÄ±ntÄ±nÄ±n zamanla azalmasÄ± iÃ§in
                    camera.position.x += (Math.random() - 0.5) * collisionShakeMagnitude * shakeFade;
                    camera.position.y += (Math.random() - 0.5) * collisionShakeMagnitude * shakeFade;
                    collisionShakeDuration--;
                    if (collisionShakeDuration <= 0) {
                        collisionShakeMagnitude = 0; // SarsÄ±ntÄ± bitince sÄ±fÄ±rla
                    }
                }
                
                if (skyDome) { 
                    skyDome.position.copy(camera.position); 
                }
                updateMountains();
            } 

            renderer.render(scene, camera);
            animationFrameId = requestAnimationFrame(update);
        }


        function render() { 
            renderer.render(scene, camera);
        }

        async function loadSound(urls) { 
            if (!audioContext) {
                console.warn("loadSound: AudioContext henÃ¼z baÅŸlatÄ±lmadÄ±.");
                return null;
            }

            let audioBuffer = null;
            for (const url of urls) {
                try {
                    const response = await fetch(url);
                    if (!response.ok) {
                        throw new Error(`HTTP hata kodu: ${response.status} iÃ§in ${url}`);
                    }
                    const arrayBuffer = await response.arrayBuffer();
                    audioBuffer = await audioContext.decodeAudioData(arrayBuffer);
                    console.log(`Ses yÃ¼klendi: ${url}`);
                    return audioBuffer; 
                } catch (error) {
                    console.warn(`Ses yÃ¼klenirken hata oluÅŸtu, diÄŸer formata geÃ§iliyor: ${url}. Hata: ${error.message}`); /* Daha detaylÄ± hata mesajÄ± */
                }
            }
            console.warn(`TÃ¼m ses formatlarÄ± yÃ¼klenirken hata oluÅŸtu. Bu ses Ã§almayacak.`); /* Hata yerine uyarÄ± */
            return null; 
        }

        function playSound(buffer, volume = 1.0, loop = false) {
            if (!audioContext || !buffer) { 
                console.warn("playSound: AudioContext veya ses buffer'Ä± eksik. Ses Ã§alÄ±namadÄ±.");
                return null;
            }

            const source = audioContext.createBufferSource();
            source.buffer = buffer;
            source.loop = loop;
            
            const gainNode = audioContext.createGain();
            gainNode.gain.setValueAtTime(volume, audioContext.currentTime);

            source.connect(gainNode);
            gainNode.connect(audioContext.destination);

            source.start(0);

            const soundControl = {
                source: source,
                gainNode: gainNode,
                playState: 'playing',
                stop: () => {
                    if (soundControl.playState === 'playing') {
                        source.stop();
                        source.disconnect(); 
                        gainNode.disconnect(); 
                        soundControl.playState = 'stopped';
                        console.log("Ses (playSound iÃ§inden) durduruldu.");
                    }
                },
                setVolume: (newVolume) => {
                    gainNode.gain.setValueAtTime(newVolume, audioContext.currentTime);
                }
            };
            return soundControl;
        }


        function initAudioAndLoadGame() {
            console.log("initAudioAndLoadGame fonksiyonu Ã§aÄŸrÄ±ldÄ±.");

            if (!audioContext) {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
            }

            if (audioContext.state === 'suspended') {
                audioContext.resume().catch(error => console.error("AudioContext devam ettirilemedi:", error));
            }

            // DOÄRU VE Ã‡ALIÅAN KENNEY ASSETS URL'LERÄ°
            Promise.all([
                loadSound(['https://atakancerrahoglu.github.io/Sounds/engine_sound.mp3']),
                loadSound(['https://atakancerrahoglu.github.io/Sounds/brake_sound.mp3']),
                loadSound(['https://atakancerrahoglu.github.io/Sounds/police_sound.mp3']),
                loadSound(['https://atakancerrahoglu.github.io/Sounds/intro.mp3']),
                loadSound(['https://cdn.jsdelivr.net/gh/kenney-assets/kenney-assets/Audio/Powerup/powerup_01.ogg']),
                loadSound(['https://cdn.jsdelivr.net/gh/kenney-assets/kenney-assets/Audio/Explosion/explosion_01.ogg']),
                loadSound(['https://cdn.jsdelivr.net/gh/kenney-assets/kenney-assets/Audio/Impact/impact_01.ogg']),
                loadSound(['https://cdn.jsdelivr.net/gh/kenney-assets/kenney-assets/Audio/Powerup/powerup_02.ogg']),
                loadSound(['https://cdn.jsdelivr.net/gh/kenney-assets/kenney-assets/Audio/Powerup/powerup_03.ogg']),
                loadSound(['https://cdn.jsdelivr.net/gh/kenney-assets/kenney-assets/Audio/UI/switch_01.ogg']),
                loadSound(['https://cdn.jsdelivr.net/gh/kenney-assets/kenney-assets/Audio/UI/click_01.ogg'])
            ]).then(buffers => {
                engineBuffer = buffers[0];
                brakeBuffer = buffers[1];
                policeSirenBuffer = buffers[2];
                introBuffer = buffers[3];
                powerUpRocketSoundBuffer = buffers[4];
                explosionSoundBuffer = buffers[5];
                crashSoundBuffer = buffers[6];
                powerUpHealthSoundBuffer = buffers[7];
                powerUpShieldSoundBuffer = buffers[8];
                menuSelectSoundBuffer = buffers[9];
                menuConfirmSoundBuffer = buffers[10];

                console.log("TÃ¼m ses buffer atamalarÄ± tamamlandÄ±.");

                if (introBuffer) {
                    if (introSource) introSource.stop();
                    introSource = audioContext.createBufferSource();
                    introSource.buffer = introBuffer;
                    introSource.loop = true;
                    introGainNode = audioContext.createGain();
                    introGainNode.gain.setValueAtTime(0.9, audioContext.currentTime);
                    introSource.connect(introGainNode);
                    introGainNode.connect(audioContext.destination);
                    introSource.start(0);
                    introSource.playState = 'playing';
                }
            }).catch(error => {
                console.error("BazÄ± sesler yÃ¼klenirken ciddi bir hata oluÅŸtu:", error);
            }).finally(() => {
                console.log("Ses yÃ¼kleme sÃ¼reci tamamlandÄ±, isim giriÅŸ ekranÄ± gÃ¶steriliyor.");
                showFirstEntryScreen();
            });
        }

        function startEngineSound() {
            if (engineSource) { 
                engineSource.stop();
                engineSource.disconnect();
                engineSource = null;
                engineGainNode = null;
            }

            if (!engineBuffer || !audioContext) {
                console.warn("Motor sesi baÅŸlatÄ±lamadÄ±: Buffer veya AudioContext yok.");
                return;
            }

            engineSource = audioContext.createBufferSource();
            engineSource.buffer = engineBuffer;
            engineSource.loop = true;

            engineGainNode = audioContext.createGain();
            engineSource.connect(engineGainNode);
            engineGainNode.connect(audioContext.destination);

            engineSource.start(0); 
            console.log("Motor sesi Web Audio API ile baÅŸlatÄ±ldÄ±.");
        }

        function triggerCollisionShake(magnitude, duration) {
            // Mevcut sarsÄ±ntÄ±nÄ±n Ã¼zerine ekle, daha gÃ¼Ã§lÃ¼ bir etki iÃ§in
            collisionShakeMagnitude += magnitude;
            // SÃ¼reyi en uzun olanla deÄŸiÅŸtir
            collisionShakeDuration = Math.max(collisionShakeDuration, duration);
        }

        async function getHighScores() {
            try {
                const response = await fetch(HIGH_SCORES_URL);
                if (!response.ok) {
                    console.error('Rekorlar alÄ±namadÄ±:', response.statusText);
                    return [];
                }
                const data = await response.json();
                return Array.isArray(data.scores) ? data.scores : [];
            } catch (e) {
                console.error('Rekorlar alÄ±nÄ±rken hata:', e);
                return [];
            }
        }

        async function saveHighScore(score, name) {
            try {
                const highScores = await getHighScores();
                highScores.push({ score, name, date: new Date().toISOString() });
                highScores.sort((a, b) => b.score - a.score);
                const topScores = highScores.slice(0, 5);

                await fetch(HIGH_SCORES_URL, {
                    method: 'PUT',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({ scores: topScores }),
                });
            } catch (e) {
                console.error('Rekor kaydedilirken hata:', e);
            }
        }

        async function displayHighScores() {
            const highScoreListElement = document.getElementById('highScoreList');
            highScoreListElement.innerHTML = '<li>Rekorlar yÃ¼kleniyor...</li>';

            try {
                const highScores = await getHighScores();
                highScoreListElement.innerHTML = '';

                if (highScores.length === 0) {
                    highScoreListElement.innerHTML = '<li>HenÃ¼z online rekor yok!</li>';
                    return;
                }

                highScores.forEach(entry => {
                    const li = document.createElement('li');
                    li.innerHTML = `${entry.name} <span class="score">${entry.score}</span>`;
                    highScoreListElement.appendChild(li);
                });
            } catch(e) {
                 highScoreListElement.innerHTML = '<li>Rekorlar yÃ¼klenemedi.</li>';
            }
        }

        function activateShield() {
            if (shieldActive) {
                clearTimeout(shieldTimeout);
            }
            shieldActive = true;
            if (shieldMesh) {
                shieldMesh.visible = true;
            }

            shieldTimeout = setTimeout(() => {
                shieldActive = false;
                if (shieldMesh) {
                    shieldMesh.visible = false;
                }
                showScoreFeedback('Kalkan Deaktif', '#AAAAAA');
            }, 5000); // 5 saniye
        }

        function createFlameTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 64;
            canvas.height = 64;
            const context = canvas.getContext('2d');
            const gradient = context.createRadialGradient(
                canvas.width / 2, canvas.height / 2, 0,
                canvas.width / 2, canvas.height / 2, canvas.width / 2
            );
            gradient.addColorStop(0, 'rgba(255, 200, 100, 1)');
            gradient.addColorStop(0.2, 'rgba(255, 140, 0, 1)');
            gradient.addColorStop(0.6, 'rgba(255, 69, 0, 0.7)');
            gradient.addColorStop(1, 'rgba(255, 0, 0, 0)');

            context.fillStyle = gradient;
            context.fillRect(0, 0, canvas.width, canvas.height);

            const texture = new THREE.CanvasTexture(canvas);
            return texture;
        }

        function startSpeedCorridor() {
            if (isSpeedCorridorActive) return;

            isSpeedCorridorActive = true;
            speedCorridorStartDistance = distance;
            // Bir sonraki koridor en az 15km sonra olacak
            nextSpeedCorridorSpawnDistance = distance + 15000 + (Math.random() * 5000);
            showScoreFeedback('HIZ KORÄ°DORU BAÅLADI!', '#00BFFF');

            // En sol ÅŸeridi temizle
            for (let i = trafficCars.length - 1; i >= 0; i--) {
                const car = trafficCars[i];
                if (Math.abs(car.position.x - lanes[0]) < laneWidth / 2) {
                    releasePooledTrafficCar(car);
                    trafficCars.splice(i, 1);
                }
            }

            // RampalÄ± kamyonu oluÅŸtur ve 2km ileriye yerleÅŸtir
            rampTruck = createRampTruck();
            rampTruck.position.set(lanes[0], 0, camera.position.z - 2000);
            scene.add(rampTruck);
        }

        function endSpeedCorridor() {
            if (!isSpeedCorridorActive) return;
            isSpeedCorridorActive = false;
            showScoreFeedback('HIZ KORÄ°DORU BÄ°TTÄ°!', '#AAAAAA');
            if (rampTruck) {
                scene.remove(rampTruck);
                rampTruck = null;
            }
        }

        function createRampTruck() {
            const truckGroup = new THREE.Group();

            // Kamyon gÃ¶vdesi (basit bir kutu)
            const truckBodyMat = new THREE.MeshStandardMaterial({color: 0x444444, metalness: 0.9, roughness: 0.5});
            const truckBodyGeom = new THREE.BoxGeometry(3, 3.5, 7);
            const truckBody = new THREE.Mesh(truckBodyGeom, truckBodyMat);
            truckBody.position.y = 1.75;
            truckGroup.add(truckBody);

            // Rampa
            const rampLength = 25;
            const rampHeight = 4.5;
            const rampMat = new THREE.MeshStandardMaterial({color: 0xCCCCCC, metalness: 0.2, roughness: 0.8});
            const rampGeom = new THREE.BoxGeometry(2.8, 0.5, rampLength);
            const ramp = new THREE.Mesh(rampGeom, rampMat);
            
            ramp.position.z = (7/2) + (rampLength/2); // Kamyonun arkasÄ±na
            ramp.position.y = rampHeight / 2 - 0.25;
            ramp.rotation.x = -Math.atan2(rampHeight, rampLength); // EÄŸim
            ramp.userData.isRamp = true; // Ã‡arpÄ±ÅŸma tespiti iÃ§in
            truckGroup.add(ramp);

            truckGroup.rotation.y = Math.PI;
            return truckGroup;
        }

        function createPowerUp(x, z) {
            // AÄŸÄ±rlÄ±klÄ± rastgele seÃ§im iÃ§in olasÄ±lÄ±k havuzu
            // 50% roket, 33.3% kalkan, 16.7% can
            const weightedPowerUpTypes = ['rocket', 'rocket', 'rocket', 'shield', 'shield', 'health'];
            const type = weightedPowerUpTypes[Math.floor(Math.random() * weightedPowerUpTypes.length)];
            
            console.log(`Yeni gÃ¼Ã§lendirme oluÅŸturuluyor: TÃœR = ${type}`);

            let powerUpMesh;
            let geometry, material;
            const emissiveIntensity = 0.7;
            const metalness = 0.6;
            const roughness = 0.4;

            switch (type) {
                case 'rocket':
                    geometry = new THREE.CylinderGeometry(0.6, 0.6, 1.5, 16); // Silindir ÅŸeklinde
                    material = new THREE.MeshStandardMaterial({
                        color: 0xFF4500, // Turuncu
                        emissive: 0xFF4500,
                        emissiveIntensity, metalness, roughness
                    });
                    powerUpMesh = new THREE.Mesh(geometry, material);
                    break;
                
                case 'health':
                    // ArtÄ± (+) iÅŸareti ÅŸeklinde bir grup oluÅŸtur
                    powerUpMesh = new THREE.Group();
                    const barGeo = new THREE.BoxGeometry(1.5, 0.5, 0.5);
                    material = new THREE.MeshStandardMaterial({
                        color: 0x00FF7F, // YeÅŸil
                        emissive: 0x00FF7F,
                        emissiveIntensity, metalness, roughness
                    });
                    const bar1 = new THREE.Mesh(barGeo, material);
                    const bar2 = new THREE.Mesh(barGeo, material);
                    bar2.rotation.y = Math.PI / 2; // Dikey Ã§ubuÄŸu oluÅŸturmak iÃ§in dÃ¶ndÃ¼r
                    powerUpMesh.add(bar1);
                    powerUpMesh.add(bar2);
                    break;

                case 'shield':
                    geometry = new THREE.TorusGeometry(0.8, 0.3, 16, 32); // Halka (Torus) ÅŸeklinde
                    material = new THREE.MeshStandardMaterial({
                        color: 0x00BFFF, // Mavi
                        emissive: 0x00BFFF,
                        emissiveIntensity, metalness, roughness
                    });
                    powerUpMesh = new THREE.Mesh(geometry, material);
                    powerUpMesh.rotation.x = Math.PI / 2; // Yola paralel durmasÄ± iÃ§in dÃ¶ndÃ¼r
                    break;
            }
            
            // Konum ve oyun iÃ§in gerekli verileri ayarla
            powerUpMesh.position.set(x, 1.5, z); // Kutuyu yola yerleÅŸtir (biraz daha yukarÄ±da)
            powerUpMesh.userData.type = type;
            powerUpMesh.userData.isPowerUp = true;
            powerUpMesh.userData.rotationSpeed = Math.random() * 0.05 + 0.02; 
            powerUpMesh.userData.bobbingSpeed = Math.random() * 0.05 + 0.03; 
            powerUpMesh.userData.initialY = 1.5; 

            return powerUpMesh;
        }

        function spawnAggressivePolice() {
            if (activePoliceCar) return;
            const newPoliceCar = getPooledPoliceCar();
            if (newPoliceCar) {
                newPoliceCar.position.set(car.position.x, 0, car.position.z - 6);
                newPoliceCar.rotation.y = Math.PI;
                Object.assign(newPoliceCar.userData, {
                    isAggressiveRammer: true,
                    rammingStartTime: Date.now(),
                    target: car
                });
                trafficCars.push(newPoliceCar);
                activePoliceCar = newPoliceCar;
                showScoreFeedback('!!! POLÄ°S SALDIRISI !!!', '#FF0000', 3000);

                if (policeSirenBuffer) {
                    // Polisin kendine ait ses kontrolÃ¼ nesnesini sakla
                    newPoliceCar.userData.sirenSound = playSound(policeSirenBuffer, 2.5, true);
                }
            }
        }

        function updatePoliceWarnings() {
            const currentTime = Date.now();
            if (gameRunning && !activePoliceCar && (currentTime - lastSirenWarningTime > sirenWarningInterval)) {
                lastSirenWarningTime = currentTime;
                
                if (sirenWarningCount >= 3) {
                    spawnAggressivePolice();
                    sirenWarningCount = 0;
                } else {
                    sirenWarningCount++;
                    if (policeSirenBuffer) {
                        if (shortSirenSound && shortSirenSound.playState === 'playing') shortSirenSound.stop();
                        shortSirenSound = playSound(policeSirenBuffer, 1.5, false);
                        setTimeout(() => {
                            if (shortSirenSound && shortSirenSound.playState === 'playing') shortSirenSound.stop();
                        }, 2000);
                    }
                    showScoreFeedback('Polis YakÄ±nlarda...', '#FFFF00', 2000);
                }
                updateSirenStars();
            }
        }

        function updateSirenStars() {
            sirenStarElements.forEach((star, index) => {
                if (index < sirenWarningCount) {
                    star.classList.add('filled');
                } else {
                    star.classList.remove('filled');
                }
            });
        }

        init();
    </script>
</body>
</html>
